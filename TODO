

Jun 3, 2018:
------------

- reload + renderall crashes!
    run valgrind, maybe it will find something
    ...nope, it's happening in SDL dynamic lib somewhere...


Jun 14, 2018:
-------------

- prismelrenderer_parse.c:
    fus_lexer_get_{prismel,rendergraph,mapper} shouldn't take a "name" param?
    Maybe reintroduce the *_map objects?
    No: introduce "variable" objects.
    They don't own their shape/prismel/mapper, and the latter don't have names.
    ^... YES THIS


Jun 23, 2018:
-------------

hexmap_submap_t: if these don't share collmaps, just modify collmaps'
    ox, oy instead of messing around with submap's pos?..

COLLMAP INDICES NEED TO USE SAME Y COORDS AS TRF_T
    (currently they are vertically flipped and it ruins everything)


Jun 25, 2018:
-------------

### prismelmappers whose rgraphs have n_frames > 1 ###

It seems obvious that the resulting n_frames should be the product of mapper & mappee shapes.
...we could make it an attribute of prismelmapper: how to treat animation.
    Options:
        - mapper's animation happens once per frame of mappee's animation
        - mappee's animation happens once per frame of mapper's animation
        - mapper + mappee animate simultaneously  <-- this is the default, cos its easiest?..
...ah, but "mapper" is not a rendergraph, it's a mapper.
We could define mapper's n_frames as the LCD of its rendergraphs' n_frames.


Jun 27, 2018:
-------------

mapper l.blu_double: we're expecting to see light-coloured prismels turned to
    white, others turned to light blue.
    But everything is turned to light blue.
    Is that because our double_sq, double_tri are defined with dark blue?
    (performs an experiment) ...YES.
    Well, ok but why?..
    -> because of that recursive step: mappers end up seeing how things
        are composed, it's up to us to make sure they *behave* as if they
        only see the colors in their sub-shapes' rendered bitmaps.
    -> ok, so what's the fix?
        ...idunno, but take a look at that thing in prismelrenderer.c which
        says:
            /* TODO: think about this and make sure it's correct */
        ...it's probably not correct, eh.

        UPDATE: It's not correct. I did abstract algebra at it until
        its incorrectness was proven. T__T


Jun 30, 2018:
-------------

WHAT'S NEEDED FOR A PROPER DEMO:

    - Music + SFX. Almost anything will do for now.
    - Get rid of hexmap "unit": unit starts as (1 0 0 0) and only
        mappers change it.
        Then add a way in the map.fus files to specify mapper cache
        entries, and that's how tilesets with different units can
        co-exist within same worldmap?..
        Not that simple. There are no "vert", "edge" prismels.
        ...although we could add them, I suppose.
        Things get a little annoying, since we have to start adding
        single-"tri" versions of every tile (and player state??),
        and each mapper needs to have solid mappings for prismels
        tri, vert, edge.
        I guess the fus syntax would be:

            shapes:
                "tile1":
                    prismels:
                        # default, one-"tri" version:
                        : "tri" (0 0 0 0) 0 f  2
                        # ...or even have no prismels at all?..
                        # But having one-"tri" versions is maybe nice
                        # for e.g. a minimap
                    mappings:
                        "curvy":
                            # We're now defining the shape which
                            # will be used for map ("curvy") ("tile1")
                            prismels:
                                # etc
                        "double":
                            # ...

    - Title screen. (Maybe allow setting controls, save/load game,
        character select, multiplayer, etc.)
    - Detect player "death", auto respawn them somewhere useful.
        - Bring back "die" state effect?..
        - Can we abuse player->cooldown and have the "jump" state
            trigger death after some amount of time?
            -> I prefer allowing player to respawn whenever they like,
                and also letting them fly off into space as far as they
                "want".
                So, once exploded, dead=true, and a message can show
                at bottom of screen "you died, press 1 to respawn" or
                whatever, but players are free to fly off into space
                and wait for that message, to see if they'll actually
                land on something.
                -> We need a way to display messages in hexgame.



Instead of "import" in .fus files, we should maybe add "require", or anyway
    imports should be idempotent.
So all you do is specify worldmap, and it loads rgraphs as required.


July 12, 2018:
--------------

hexcollmap "parts":
    - need to realloc collmap1 as necessary for collmap2 to fit. (in hexcollmap_draw)
    - maybe below "parts" and "collmap" we can have a "draw" section where
        we specify collmap filenames and coordinates.
        It can reuse existing hexcollmap_draw.
        The coordinates can use int_fancy.
        We can add a "randint" thing to int_fancy.
        And then we will have Wilderness.

July 24, 2018:
--------------

* Add fus_lexer_cleanup()... need to go add it everywhere T___T

* audiotest REPL: recover from syntax errors plz

* audiotest REPL: push user input onto an array of strings so they can @def

* audiotest REPL: @triangle's "addinc" param needs to avoid the pop!..
    e.g. @triangle: 7500 1000 15000 addinc1(-1)

    -> ok we fixed the pop, but add it back as an operation somehow...
        Like @pop(...) - because sometimes it sounds good! Like a bass kick.
        What are its parameters?..


Dec 9, 2018:
------------

Something is weird about the "-2+" etc in the following:

    "spit_dead":
        animation: once 12
        shapes:
            : "player_dead_particle" (0 1 3 1) 1 f  0+ (0 6)
            : "player_dead_particle" (0 1 3 1) 3 f -2+ (2 6)
            : "player_dead_particle" (0 1 3 1) 6 f -3+ (3 6)
            : "player_dead_particle" (0 1 3 1) 9 f -5+ (5 6)

...I think those should all either be "0+" or the non-negative versions
of themselves (if you see what I mean).


Dec 10, 2018:
-------------

Actor states should maybe come with a "pos" so we don't have to rely on
the position of the last recording to have played...

Actor recordings: if we get a fus format for ranges of frames, and a
half-decent tool for stepping through a recording (e.g. if player->keymap
>= 0 then the arrow keys control their recording, maybe left/right is
forward/back a frame, up/down jumps to start/end, action pauses/unpauses),
then we could specify on which frames the given rules of an actor state
should be run.


Dec 11, 2018:
-------------

Current objectives:

    * Display text on screen
        * Ok, we can do this now - so where all do we use it?
            * "press '1' to go back..."
            * Controls at start of game?
                Is current approach (Enter to hide/show) ok for now?
            * Talk to other players? Or everybody's silent?
    * Improve "actors"...
        * better recording tools
            * play/pause, step forward/back
            * recording format: multiple "keyframes"
            * split recording into 2 (insert keyframe)
        * actor states have a pos
        * actor states run through ruleset on multiple frames
        * actor variables
        * special actions which affect map
            * e.g. make a "door" appear in water house
    * Diggable tiles?
    * Rideable birds?


Dec 17, 2018:
-------------

Palette transitions which are intended to be "instantaneous"
(e.g. if !game->smooth_scroll || game->reset_camera) actually lag
behind camera pos by 1 frame.


Dec 24, 2018:
-------------

We need player->respawn_stateset_filename

Hardcoded "dead" anim: each stateset should be able to specify its
dead_anim_name, and if NULL, body can't die.

Improve roller's "grab" so it can get around easier, particularly
the pebbles area

Currently spider -> roller transformation is kinda hacky as far as
map design goes; in particular, there's no way to turn back.

    * Can we make doors which are only visible to rollers? Too hacky!

    * Can we have doors better indicate their effect?
        E.g. after submap is loaded, if its door_anim_filename is non-NULL,
        change it in some way, perhaps adding a body of the proper anim
        with no recording, so it just stands there showing you what you
        will become...

    * Perhaps we design the dodecas area such that rollers can't escape.
        That way we just need to add a "roller -> player" door somewhere
        within it.
        Like on the other side of a puzzle which can't be passed by
        spiders...
        It should be at the far left side where the other rollers are,
        so they act as a hint that you should head there as a roller!..
        THEY COULD BE ACTORS WHICH DETECT A FELLOW ROLLER ENTERING THE
        AREA!...
        *hyperventilating slightly*


Dec 31, 2018:
-------------

vars:

    Should be saved in recordings.
    So e.g. we can set vars of recordings in data/maps by editing the files.

    We want new getter/setter conds an effects:
        if:
            eval: get "x" < 3
            eval: get "name" == "joe"
            eval: get "is_active"
        then:
            set "x": get "x" + 1

    For "coll" cond with "bodies", we want something like:
        coll:
            bodies
            count: >= 3
            where: get his "x" < 3
            where: get his "name" == "joe"
            where: get his "group" == get my "group"
            where: get his "is_active" and: not get his "is_dead"
            ;; .....

    We also want some way for a state to affect other bodies:
        for bodies:
            where: get his "group" == get my "group"
            coll:
                ;; ....
        do:
            # If you only have 1 thing to do:
            set his "x": 3

            # If you have multiple things to do:
            : set his "x": 3
            : set my "guy": get his "name"

    Can we have a "do" block for each stateset, run when it's loaded?
    (So e.g. player/roller/whatever can have certain vars always set)

    TODO: How do we implement "crushing" with this?
        for bodies:
            where: get his "crushable"
            coll: ...
        do:
            set his state: "dead"

    We could implement "pickups" too, e.g.:
        for bodies:
            where: get his "uses_pickups"
            coll: ...
        do:
            : set his "heat": get his "heat" + 10
            : die

