{"version":3,"sources":["src/anim.c","src/hexmap.c","src/hexmap_hexcollmap.c","src/mathutil.h","src/util.c","src/lexer.c","src/write.c","src/vars.c","src/geom.c","src/vec4.c","src/hexspace.c","src/bounds.c","src/font.c","src/console.c","src/test_app.c","src/hexgame.c","src/hexgame_body.c","src/hexgame_player.c","src/hexgame_recording.c","src/hexgame_actor.c","src/prismelrenderer.c","src/prismelrenderer_parse.c","src/rendergraph.c","src/sdl_util.c","/home/bayersglassey/.emscripten_cache/asmjs/ports-builds/sdl2/include/SDL2/SDL_rect.h","src/main_demo.c"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAqBA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;AAoXA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAFA;AAAA;AAAA;;AAIA;AACA;;;;;;;;;;AA3XA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AASA;AAAA;AAAA;AACA;AAAA;;;AAAA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AAEA;AAAA;AACA;;;;;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAOA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AADA;AAAA;AAwRA;AAAA;;;AApRA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AADA;AAAA;AAmRA;AAAA;;;;AA9QA;AAAA;;;;;;AAGA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AACA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AADA;AAAA;AAEA;AAAA;;;;;AAGA;AAAA;;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AAGA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AACA;AAAA;;;;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAEA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAIA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;;;;;AAEA;;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AACA;;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAIA;AAAA;;;AACA;;AACA;AAAA;;AACA;;;AACA;AAAA;;;;;AACA;;;AAKA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;;AAIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;;;AAsCA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;;;AA9CA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAEA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;AACA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;;;AAGA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;;AAAA;AAAA;AAAA;;AACA;AAAA;;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AACA;AAAA;;;;;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AADA;AAAA;AAEA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAeA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;AAEA;AAAA;;;;;AAEA;;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AADA;AAAA;AAAA;;AAGA;AAAA;AAAA;AAAA;;;;;;;;AACA;;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AACA;;;AACA;AAAA;AAAA;AAAA;;;;;AAEA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AACA;;;AAQA;;;;;;AACA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAlBA;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AACA;;;AACA;;;;;;AAiBA;AAAA;AAAA;AAAA;;;;;;AAE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;;AANA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAMA;AAAA;;;AANA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAMA;AAAA;;;;AANA;AAAA;AAMA;AAAA;;;;AANA;AAMA;AAAA;;;;AANA;AAMA;AAAA;;;;AANA;AAAA;AAMA;AAAA;;;;AANA;AAAA;AAMA;AAAA;;;;AANA;AAAA;AAMA;AAAA;;;;AANA;AAAA;AAMA;AAAA;;;;AANA;AAAA;AAMA;AAAA;;;;AANA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAAA;;;;AANA;AAAA;AAMA;AAAA;;;;AANA;AAAA;AAMA;AAAA;;;;AANA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAMA;AAAA;;AALA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAKA;AAAA;;AALA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAKA;AAAA;;;AALA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAKA;AAAA;;;;AALA;AAAA;AAKA;AAAA;;;;AALA;AAKA;AAAA;;;;AALA;AAKA;AAAA;;;;AALA;AAAA;AAKA;AAAA;;;;AALA;AAAA;AAKA;AAAA;;;;AALA;AAAA;AAKA;AAAA;;;;AALA;AAAA;AAKA;AAAA;;;;AALA;AAAA;AAKA;AAAA;;;;AALA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AAAA;;;;AALA;AAAA;AAKA;AAAA;;;;AALA;AAAA;AAKA;AAAA;;;;AALA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAKA;AAAA;;AAJA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAIA;AAAA;;AAJA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAIA;AAAA;;;AAJA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;;;;;;;;AAAA;AAAA;AAIA;AAAA;;;;AAJA;AAAA;AAIA;AAAA;;;;AAJA;AAIA;AAAA;;;;AAJA;AAIA;AAAA;;;;AAJA;AAAA;AAIA;AAAA;;;;AAJA;AAAA;AAIA;AAAA;;;;AAJA;AAAA;AAIA;AAAA;;;;AAJA;AAAA;AAIA;AAAA;;;;AAJA;AAAA;AAIA;AAAA;;;;AAJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;AAAA;;;;AAJA;AAAA;AAIA;AAAA;;;;AAJA;AAAA;AAIA;AAAA;;;;AAJA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAIA;AAAA;;AADA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiDA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;;;;;AASA;AAAA;AAAA;AACA;;;;;;;;;;;;AAKA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;AAWA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;AAyrBA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;;;;;;;;;;;;;;;;AAxrBA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAA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A;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAMA;AAAA;;AAJA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;AAGA;AAAA;;AADA;AACA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA9QA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;;;;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;;;;AAGA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;;;;;AAGA;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AAEA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;AAIA;AAAA;AAAA;AAAA;;AAGA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;AAGA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AAEA;AAAA;AAAA;AACA;AAAA;;;;AAAA;AAAA;;;;AAGA;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;AAEA;AAAA;AAAA;AAAA;AAEA;AAAA;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;;;;AACA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;;;;AAEA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;;;;;AAEA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;AAGA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;AAGA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;AAGA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;AAGA;AAAA;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAFA;AAAA;AAGA;AAAA;;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;;;;AAGA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;AACA;AAAA;AAAA;AACA;AAAA;;AAAA;AAAA;;;;AAEA;AAAA;;;;;AAGA;AACA;AAAA;AAAA;AACA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;;;;;AACA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;;;;;AAEA;AAAA;AAAA;AADA;AAEA;AAAA;;;;;AAKA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;;;;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAA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AAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;;;AAEA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;;;;;;;;AAGA;;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAEA;AAAA;AAAA;AACA;AAAA;;;;;AAEA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AACA;AAAA;;AAEA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA;AAAA;;;;;AAIA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAMA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;;;AACA;AAAA;AAAA;AAAA;;;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;;;AAGA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;;;;;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA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;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;AA0qBA;AAAA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;AArVA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA3VA;AAAA;AAAA;AAAA;AACA;AAAA;;AA+CA;;AA9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;;AAAA;AAAA;AAAA;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;;AAAA;AAAA;;;;AACA;AAAA;AACA;;A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AAA;AD2DA;;AAEA;AAAA;AAAA;AACA;AAAA;AADA;AAEA;;;AAIA;AAAA;;AACA;AAAA;;AAEA;AAAA;;AAIA;AAAA;AAAA;AAAA;;AAHA;AAAA;AAGA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;AAzEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AADA;AAAA;AAAA;AAGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AADA;AAAA;AAAA;AAGA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;AAlEA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAEA;AAAA;;;AACA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AALA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAeA;;;AAZA;AAAA;AAAA;AAAA;;;;AACA;AAAA;;AAAA;AAAA;;;;AACA;AAAA;AAAA;AAAA;AAAA;;AACA;AAAA;AAAA;AAAA;;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AALA;AAAA;AAAA;;AAOA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AE5CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAAA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;;AAEA;AAAA;AAAA;;AACA;AAAA;AAAA;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AACA;AAAA;AAAA;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;;;AACA;AAAA;AAAA;;AACA;;;AACA;AAAA;AAAA;;AACA;;;AACA;AAAA;AAAA;;;;;AACA;AAAA;AAAA;AACA;AAAA;AAAA;;;;;AAGA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;;AAnCA;AAAA;AAAA;;;AAHA;AAAA;AAAA;;;AASA;AAAA;AAAA;AAAA;AACA;AAkFA;AAAA;;;AA5EA;AAAA;AAAA;AAAA;AACA;AA2EA;AAAA;;;AArEA;AAAA;AAAA;AAAA;AACA;AAoEA;AAAA;;;AA1DA;AAAA;AAAA;AAAA;AACA;AAyDA;AAAA;;;AApDA;AAAA;AAAA;AAAA;AACA;AAmDA;AAAA;;;AA/CA;AAAA;;AACA;AACA;AAAA;AAAA;AAAA;;AAIA;AAFA;AAAA;AAIA;AAAA;;AAKA;AAAA;AAAA;AAGA;AAAA;;AAOA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAFA;AAAA;;AAIA;AACA;AAAA;;AAGA;AACA;AAKA;AAAA;AACA;;AAEA;AAAA;;AAtBA;AACA;AACA;AADA;AAAA;;AAuBA;AAAA;;AAhCA;AACA;AACA;AADA;AAAA;;AAiCA;;AAEA;AAAA;AAAA;AAAA;AACA;AAAA;AACA;AAAA;;;;;;;;;;;AAhHA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;;AAEA","file":"main.html","sourcesContent":["\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#include \"anim.h\"\n#include \"array.h\"\n#include \"hexmap.h\"\n#include \"util.h\"\n#include \"prismelrenderer.h\"\n#include \"lexer.h\"\n#include \"lexer_macros.h\"\n\n\n\n/************\n * STATESET *\n ************/\n\nvoid stateset_cleanup(stateset_t *stateset){\n    free(stateset->filename);\n    ARRAY_FREE_PTR(state_t*, stateset->states, state_cleanup)\n}\n\nint stateset_init(stateset_t *stateset, char *filename){\n    stateset->filename = filename;\n    ARRAY_INIT(stateset->states)\n    stateset->is_projectile = false;\n    stateset->is_collectible = false;\n    return 0;\n}\n\nint stateset_load(stateset_t *stateset, char *filename,\n    prismelrenderer_t *prend, vecspace_t *space\n){\n    int err;\n    fus_lexer_t lexer;\n\n    char *text = load_file(filename);\n    if(text == NULL)return 1;\n\n    err = fus_lexer_init(&lexer, text, filename);\n    if(err)return err;\n\n    err = stateset_init(stateset, filename);\n    if(err)return err;\n\n    err = stateset_parse(stateset, &lexer, prend, space);\n    if(err)return err;\n\n    free(text);\n    return 0;\n}\n\nint stateset_parse(stateset_t *stateset, fus_lexer_t *lexer,\n    prismelrenderer_t *prend, vecspace_t *space\n){\n    INIT\n\n    if(GOT(\"projectile\")){\n        NEXT\n        stateset->is_projectile = true;\n    }\n\n    if(GOT(\"collectible\")){\n        NEXT\n        stateset->is_collectible = true;\n    }\n\n    while(1){\n        if(DONE)break;\n\n        char *name;\n        GET_NAME(name)\n        GET(\"(\")\n\n        rendergraph_t *rgraph = NULL;\n        if(GOT(\"rgraph\")){\n            char *rgraph_name;\n            NEXT\n            GET(\"(\")\n            GET_STR(rgraph_name)\n            GET(\")\")\n            rgraph = prismelrenderer_get_rendergraph(\n                prend, rgraph_name);\n            if(rgraph == NULL){\n                fprintf(stderr, \"Couldn't find shape: %s\\n\", rgraph_name);\n                free(rgraph_name); return 2;}\n            free(rgraph_name);\n        }\n\n        ARRAY_PUSH_NEW(state_t*, stateset->states, state)\n        err = state_init(state, stateset, name, rgraph);\n        if(err)return err;\n\n        if(GOT(\"unsafe\")){\n            NEXT\n            state->safe = false;\n        }\n        if(GOT(\"crushes\")){\n            NEXT\n            state->crushes = true;\n        }\n\n        if(GOT(\"hitbox\")){\n            NEXT\n            GET(\"(\")\n\n            hexcollmap_t *collmap = calloc(1, sizeof(*collmap));\n            if(collmap == NULL)return 1;\n            err = hexcollmap_init(collmap, space,\n                strdup(lexer->filename));\n            if(err)return err;\n            err = hexcollmap_parse(collmap, lexer, true);\n            if(err)return err;\n            state->hitbox = collmap;\n\n            GET(\")\")\n        }\n\n        while(1){\n            if(GOT(\")\"))break;\n\n            ARRAY_PUSH_NEW(state_rule_t*, state->rules, rule)\n            err = state_rule_init(rule, state);\n            if(err)return err;\n\n            GET(\"if\")\n            GET(\"(\")\n            while(1){\n                if(GOT(\")\")){\n                    break;\n                }else if(GOT(\"false\")){\n                    NEXT\n                    ARRAY_PUSH_NEW(state_cond_t*, rule->conds, cond)\n                    cond->type = state_cond_type_false;\n                }else if(GOT(\"key\")){\n                    NEXT\n                    GET(\"(\")\n\n                    bool yes = true;\n                    if(GOT(\"not\")){\n                        NEXT\n                        yes = false;\n                    }\n\n                    int kstate;\n                    if(GOT(\"isdown\")){\n                        kstate = 0;\n                    }else if(GOT(\"wasdown\")){\n                        kstate = 1;\n                    }else if(GOT(\"wentdown\")){\n                        kstate = 2;\n                    }else{\n                        return UNEXPECTED(\n                            \"isdown or wasdown or wentdown\");\n                    }\n                    NEXT\n\n                    char *name;\n                    GET_NAME(name)\n\n                    char c = name[0];\n                    if(strlen(name) != 1 || !strchr(ANIM_KEY_CS, c)){\n                        UNEXPECTED(\n                            \"one of the characters: \" ANIM_KEY_CS);\n                    }\n\n                    ARRAY_PUSH_NEW(state_cond_t*, rule->conds, cond)\n                    cond->type = state_cond_type_key;\n                    cond->u.key.kstate = kstate;\n                    cond->u.key.c = c;\n                    cond->u.key.yes = yes;\n                    free(name);\n\n                    GET(\")\")\n                }else if(GOT(\"coll\")){\n                    NEXT\n                    GET(\"(\")\n\n                    int flags = 0;\n\n                    if(GOT(\"water\")){\n                        NEXT\n                        flags ^= 4;\n                    }else if(GOT(\"bodies\")){\n                        NEXT\n                        flags ^= 8;\n                    }\n\n                    if(GOT(\"all\"))flags ^= 1;\n                    else if(GOT(\"any\"))/* don't do nuthin */;\n                    else return UNEXPECTED(\"all or any\");\n                    NEXT\n\n                    if(GOT(\"yes\"))flags ^= 2;\n                    else if(GOT(\"no\"))/* dinnae move a muscle */;\n                    else return UNEXPECTED(\"yes or no\");\n                    NEXT\n\n                    hexcollmap_t *collmap = calloc(1, sizeof(*collmap));\n                    if(collmap == NULL)return 1;\n                    err = hexcollmap_init(collmap, space,\n                        strdup(lexer->filename));\n                    if(err)return err;\n                    err = hexcollmap_parse(collmap, lexer, true);\n                    if(err)return err;\n\n                    GET(\")\")\n\n                    ARRAY_PUSH_NEW(state_cond_t*, rule->conds, cond)\n                    cond->type = state_cond_type_coll;\n                    cond->u.coll.collmap = collmap;\n                    cond->u.coll.flags = flags;\n                }else if(GOT(\"chance\")){\n                    NEXT\n                    GET(\"(\")\n                    int percent = 0;\n                    GET_INT(percent)\n                    GET(\"%\")\n                    GET(\")\")\n                    ARRAY_PUSH_NEW(state_cond_t*, rule->conds, cond)\n                    cond->type = state_cond_type_chance;\n                    cond->u.percent = percent;\n                }else{\n                    return UNEXPECTED(NULL);\n                }\n            }\n            NEXT\n\n            GET(\"then\")\n            GET(\"(\")\n            while(1){\n                if(GOT(\")\")){\n                    break;\n                }else if(GOT(\"print\")){\n                    NEXT\n                    GET(\"(\")\n                    char *msg;\n                    GET_STR(msg)\n                    ARRAY_PUSH_NEW(state_effect_t*, rule->effects, effect)\n                    effect->type = state_effect_type_print;\n                    effect->u.msg = msg;\n                    GET(\")\")\n                }else if(GOT(\"move\")){\n                    NEXT\n                    GET(\"(\")\n                    ARRAY_PUSH_NEW(state_effect_t*, rule->effects, effect)\n                    effect->type = state_effect_type_move;\n                    for(int i = 0; i < space->dims; i++){\n                        GET_INT(effect->u.vec[i]);\n                    }\n                    GET(\")\")\n                }else if(GOT(\"rot\")){\n                    NEXT\n                    GET(\"(\")\n                    int rot;\n                    GET_INT(rot)\n                    ARRAY_PUSH_NEW(state_effect_t*, rule->effects, effect)\n                    effect->type = state_effect_type_rot;\n                    effect->u.rot = rot_contain(space->rot_max, rot);\n                    GET(\")\")\n                }else if(GOT(\"turn\")){\n                    NEXT\n                    ARRAY_PUSH_NEW(state_effect_t*, rule->effects, effect)\n                    effect->type = state_effect_type_turn;\n                }else if(GOT(\"goto\")){\n                    NEXT\n\n                    bool immediate = false;\n                    if(GOT(\"immediate\")){\n                        NEXT\n                        immediate = true;\n                    }\n\n                    GET(\"(\")\n\n                    char *goto_name;\n                    GET_NAME(goto_name)\n\n                    ARRAY_PUSH_NEW(state_effect_t*, rule->effects, effect)\n                    effect->type = state_effect_type_goto;\n                    effect->u.gotto.name = goto_name;\n                    effect->u.gotto.immediate = immediate;\n\n                    GET(\")\")\n                }else if(GOT(\"delay\")){\n                    NEXT\n                    GET(\"(\")\n\n                    int delay;\n                    GET_INT(delay)\n\n                    ARRAY_PUSH_NEW(state_effect_t*, rule->effects, effect)\n                    effect->type = state_effect_type_delay;\n                    effect->u.delay = delay;\n\n                    GET(\")\")\n                }else if(GOT(\"action\")){\n                    NEXT\n                    GET(\"(\")\n\n                    char *action_name;\n                    GET_NAME(action_name)\n\n                    ARRAY_PUSH_NEW(state_effect_t*, rule->effects, effect)\n                    effect->type = state_effect_type_action;\n                    effect->u.action_name = action_name;\n\n                    GET(\")\")\n                }else if(GOT(\"die\")){\n                    NEXT\n                    ARRAY_PUSH_NEW(state_effect_t*, rule->effects, effect)\n                    effect->type = state_effect_type_die;\n                    if(GOT(\"mostly\")){\n                        NEXT\n                        effect->u.dead = BODY_MOSTLY_DEAD;\n                    }else effect->u.dead = BODY_ALL_DEAD;\n                }else if(GOT(\"play\")){\n                    NEXT\n                    GET(\"(\")\n\n                    char *play_filename;\n                    GET_STR(play_filename)\n\n                    ARRAY_PUSH_NEW(state_effect_t*, rule->effects, effect)\n                    effect->type = state_effect_type_play;\n                    effect->u.play_filename = play_filename;\n\n                    GET(\")\")\n                }else{\n                    return UNEXPECTED(NULL);\n                }\n            }\n            NEXT\n        }\n        NEXT\n    }\n    NEXT\n    return 0;\n}\n\nstate_t *stateset_get_state(stateset_t *stateset, const char *name){\n    for(int i = 0; i < stateset->states_len; i++){\n        state_t *state = stateset->states[i];\n        if(!strcmp(state->name, name))return state;\n    }\n    return NULL;\n}\n\n\n\n/*********\n * STATE *\n *********/\n\n\nconst char state_cond_type_false[] = \"false\";\nconst char state_cond_type_key[] = \"key\";\nconst char state_cond_type_coll[] = \"coll\";\nconst char state_cond_type_chance[] = \"chance\";\nconst char *state_cond_types[] = {\n    state_cond_type_false,\n    state_cond_type_key,\n    state_cond_type_coll,\n    state_cond_type_chance,\n    NULL\n};\n\n\nconst char state_effect_type_print[] = \"print\";\nconst char state_effect_type_move[] = \"move\";\nconst char state_effect_type_rot[] = \"rot\";\nconst char state_effect_type_turn[] = \"turn\";\nconst char state_effect_type_goto[] = \"goto\";\nconst char state_effect_type_delay[] = \"delay\";\nconst char state_effect_type_action[] = \"action\";\nconst char state_effect_type_play[] = \"play\";\nconst char state_effect_type_die[] = \"die\";\nconst char *state_effect_types[] = {\n    state_effect_type_print,\n    state_effect_type_move,\n    state_effect_type_rot,\n    state_effect_type_turn,\n    state_effect_type_goto,\n    state_effect_type_delay,\n    state_effect_type_action,\n    state_effect_type_play,\n    state_effect_type_die,\n    NULL\n};\n\n\nvoid state_cleanup(state_t *state){\n    free(state->name);\n    if(state->hitbox != NULL){\n        hexcollmap_cleanup(state->hitbox);\n        free(state->hitbox);\n    }\n    for(int i = 0; i < state->rules_len; i++){\n        state_rule_t *rule = state->rules[i];\n        state_rule_cleanup(rule);\n    }\n    free(state->rules);\n}\n\nint state_init(state_t *state, stateset_t *stateset, char *name,\n    rendergraph_t *rgraph\n){\n    state->stateset = stateset;\n    state->name = name;\n    state->rgraph = rgraph;\n    state->hitbox = NULL;\n    state->safe = true;\n    state->crushes = false;\n    ARRAY_INIT(state->rules)\n    return 0;\n}\n\n\nvoid state_rule_cleanup(state_rule_t *rule){\n    for(int i = 0; i < rule->conds_len; i++){\n        state_cond_t *cond = rule->conds[i];\n        if(cond->type == state_cond_type_coll){\n            hexcollmap_t *collmap = cond->u.coll.collmap;\n            if(collmap != NULL){\n                hexcollmap_cleanup(collmap);\n                free(collmap);\n            }\n        }\n    }\n    free(rule->conds);\n\n    for(int i = 0; i < rule->effects_len; i++){\n        state_effect_t *effect = rule->effects[i];\n        if(effect->type == state_effect_type_print){\n            free(effect->u.msg);\n        }else if(effect->type == state_effect_type_goto){\n            free(effect->u.gotto.name);\n        }else if(effect->type == state_effect_type_action){\n            free(effect->u.action_name);\n        }else if(effect->type == state_effect_type_play){\n            free(effect->u.play_filename);\n        }\n    }\n    free(rule->effects);\n}\n\nint state_rule_init(state_rule_t *rule, state_t *state){\n    rule->state = state;\n    ARRAY_INIT(rule->conds)\n    ARRAY_INIT(rule->effects)\n    return 0;\n}\n\n","\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#include \"hexmap.h\"\n#include \"hexgame.h\"\n#include \"lexer.h\"\n#include \"util.h\"\n#include \"mathutil.h\"\n#include \"geom.h\"\n#include \"vec4.h\"\n#include \"hexspace.h\"\n#include \"prismelrenderer.h\"\n\n\n/************\n * LOCATION *\n ************/\n\nvoid location_init(location_t *location){\n    vec_zero(location->pos);\n    location->rot = 0;\n    location->turn = false;\n    location->map_filename = NULL;\n}\n\nvoid location_cleanup(location_t *location){\n    free(location->map_filename);\n}\n\nvoid location_set(location_t *location, vecspace_t *space,\n    vec_t pos, rot_t rot, bool turn, char *map_filename\n){\n    vec_cpy(space->dims, location->pos, pos);\n    location->rot = rot;\n    location->turn = turn;\n    if(location->map_filename != map_filename){\n        free(location->map_filename);\n        location->map_filename = map_filename;\n    }\n}\n\n\n/******************\n * HEXMAP TILESET *\n ******************/\n\nvoid hexmap_tileset_cleanup(hexmap_tileset_t *tileset){\n    free(tileset->name);\n    ARRAY_FREE_PTR(hexmap_tileset_entry_t*, tileset->vert_entries, (void))\n    ARRAY_FREE_PTR(hexmap_tileset_entry_t*, tileset->edge_entries, (void))\n    ARRAY_FREE_PTR(hexmap_tileset_entry_t*, tileset->face_entries, (void))\n}\n\nint hexmap_tileset_init(hexmap_tileset_t *tileset, char *name){\n    tileset->name = name;\n    ARRAY_INIT(tileset->vert_entries)\n    ARRAY_INIT(tileset->edge_entries)\n    ARRAY_INIT(tileset->face_entries)\n    return 0;\n}\n\nstatic int hexmap_tileset_parse(hexmap_tileset_t *tileset,\n    prismelrenderer_t *prend, char *name,\n    fus_lexer_t *lexer\n){\n    int err;\n\n    err = hexmap_tileset_init(tileset, name);\n    if(err)return err;\n\n    /* parse vert, edge, face, rgraphs */\n    #define GET_RGRAPH(TYPE) { \\\n        err = fus_lexer_get(lexer, #TYPE\"s\"); \\\n        if(err)return err; \\\n        err = fus_lexer_get(lexer, \"(\"); \\\n        if(err)return err; \\\n        while(1){ \\\n            if(fus_lexer_got(lexer, \")\"))break; \\\n            \\\n            char tile_c; \\\n            err = fus_lexer_get_chr(lexer, &tile_c); \\\n            if(err)return err; \\\n            \\\n            err = fus_lexer_get(lexer, \"(\"); \\\n            if(err)return err; \\\n            ARRAY_PUSH_NEW(hexmap_tileset_entry_t*, \\\n                tileset->TYPE##_entries, entry) \\\n            entry->n_rgraphs = 0; \\\n            entry->tile_c = tile_c; \\\n            entry->frame_offset = 0; \\\n            if(fus_lexer_got(lexer, \"frame_offset\")){ \\\n                err = fus_lexer_next(lexer); \\\n                if(err)return err; \\\n                err = fus_lexer_get(lexer, \"(\"); \\\n                if(err)return err; \\\n                err = fus_lexer_get_int(lexer, &entry->frame_offset); \\\n                if(err)return err; \\\n                err = fus_lexer_get(lexer, \")\"); \\\n                if(err)return err; \\\n            } \\\n            while(1){ \\\n                if(!fus_lexer_got_str(lexer))break; \\\n                char *rgraph_name; \\\n                err = fus_lexer_get_str(lexer, &rgraph_name); \\\n                if(err)return err; \\\n                rendergraph_t *rgraph = \\\n                    prismelrenderer_get_rendergraph(prend, rgraph_name); \\\n                if(rgraph == NULL){ \\\n                    fus_lexer_err_info(lexer); \\\n                    fprintf(stderr, \"Couldn't find shape: %s\\n\", \\\n                        rgraph_name); \\\n                    free(rgraph_name); return 2;} \\\n                free(rgraph_name); \\\n                entry->rgraphs[entry->n_rgraphs] = rgraph; \\\n                entry->n_rgraphs++; \\\n            } \\\n            if(entry->n_rgraphs == 0){ \\\n                return fus_lexer_unexpected(lexer, \"str\");} \\\n            err = fus_lexer_get(lexer, \")\"); \\\n            if(err)return err; \\\n        } \\\n        err = fus_lexer_next(lexer); \\\n        if(err)return err; \\\n    }\n    GET_RGRAPH(vert)\n    GET_RGRAPH(edge)\n    GET_RGRAPH(face)\n    #undef GET_RGRAPH\n\n    return 0;\n}\n\nint hexmap_tileset_load(hexmap_tileset_t *tileset,\n    prismelrenderer_t *prend, const char *filename\n){\n    int err;\n    fus_lexer_t lexer;\n\n    char *text = load_file(filename);\n    if(text == NULL)return 1;\n\n    err = fus_lexer_init(&lexer, text, filename);\n    if(err)return err;\n\n    err = hexmap_tileset_parse(tileset, prend, strdup(filename),\n        &lexer);\n    if(err)return err;\n\n    free(text);\n    return 0;\n}\n\n#define HEXMAP_TILESET_GET_RGRAPH(TYPE) \\\n    void hexmap_tileset_get_rgraph_##TYPE(hexmap_tileset_t *tileset, \\\n        char tile_c, rot_t rot, \\\n        rendergraph_t **rgraph_ptr, bool *rot_ok_ptr, \\\n        int *frame_offset_ptr \\\n    ){ \\\n        /* rgraph: non-NULL if we found an entry with matching tile_c */ \\\n        /* rot_ok: whether the entry we found had an rgraph for the */ \\\n        /* requested rot; if false, rgraph is the entry's rgraph for */ \\\n        /* rot=0 and caller should rotate the rgraph manually */ \\\n        bool rot_ok = false; \\\n        int frame_offset = 0; \\\n        rendergraph_t *rgraph = NULL; \\\n        for(int i = 0; i < tileset->TYPE##_entries_len; i++){ \\\n            hexmap_tileset_entry_t *entry = tileset->TYPE##_entries[i]; \\\n            if(entry->tile_c != tile_c)continue; \\\n            if(entry->n_rgraphs > rot){ \\\n                rot_ok = true; \\\n                rgraph = entry->rgraphs[rot]; \\\n            }else rgraph = entry->rgraphs[0]; \\\n            frame_offset = entry->frame_offset; \\\n            break; \\\n        } \\\n        *rgraph_ptr = rgraph; \\\n        *rot_ok_ptr = rot_ok; \\\n        *frame_offset_ptr = frame_offset; \\\n    }\nHEXMAP_TILESET_GET_RGRAPH(vert)\nHEXMAP_TILESET_GET_RGRAPH(edge)\nHEXMAP_TILESET_GET_RGRAPH(face)\n\n\n\n/********************\n * HEXMAP RECORDING *\n ********************/\n\nvoid hexmap_recording_cleanup(hexmap_recording_t *recording){\n    free(recording->filename);\n}\n\nint hexmap_recording_init(hexmap_recording_t *recording, char *filename,\n    palettemapper_t *palmapper\n){\n    recording->filename = filename;\n    recording->palmapper = palmapper;\n    trf_zero(&recording->trf);\n    return 0;\n}\n\n\n\n/**********\n * HEXMAP *\n **********/\n\nvoid body_cleanup(struct body *body);\nvoid hexmap_cleanup(hexmap_t *map){\n    free(map->name);\n\n    ARRAY_FREE_PTR(body_t*, map->bodies, body_cleanup)\n\n    ARRAY_FREE_PTR(hexmap_submap_t*, map->submaps, hexmap_submap_cleanup)\n    ARRAY_FREE_PTR(hexmap_recording_t*, map->recordings,\n        hexmap_recording_cleanup)\n    ARRAY_FREE_PTR(hexmap_recording_t*, map->actor_recordings,\n        hexmap_recording_cleanup)\n}\n\nint hexmap_init(hexmap_t *map, hexgame_t *game, char *name,\n    vec_t unit\n){\n    int err;\n\n    prismelrenderer_t *prend = game->prend;\n    vecspace_t *space = &hexspace;\n\n    map->name = name;\n    map->game = game;\n    map->space = space;\n    vec_zero(map->spawn);\n\n    map->prend = prend;\n    vec_cpy(prend->space->dims, map->unit, unit);\n\n    ARRAY_INIT(map->bodies)\n    ARRAY_INIT(map->submaps)\n    ARRAY_INIT(map->recordings)\n    ARRAY_INIT(map->actor_recordings)\n    return 0;\n}\n\nint hexmap_load(hexmap_t *map, hexgame_t *game, const char *filename){\n    int err;\n    fus_lexer_t lexer;\n\n    char *text = load_file(filename);\n    if(text == NULL)return 1;\n\n    err = fus_lexer_init(&lexer, text, filename);\n    if(err)return err;\n\n    err = hexmap_parse(map, game, strdup(filename), &lexer);\n    if(err)return err;\n\n    /* Load actors */\n    for(int i = 0; i < map->actor_recordings_len; i++){\n        hexmap_recording_t *actor_recording =\n            map->actor_recordings[i];\n        const char *filename = actor_recording->filename;\n\n        ARRAY_PUSH_NEW(body_t*, map->bodies, body)\n        err = body_init(body, game, map, NULL, NULL,\n            actor_recording->palmapper);\n        if(err)return err;\n\n        ARRAY_PUSH_NEW(actor_t*, game->actors, actor)\n        err = actor_init(actor, map, body, filename, NULL);\n        if(err)return err;\n    }\n\n    /* Load recordings */\n    for(int i = 0; i < map->recordings_len; i++){\n        hexmap_recording_t *recording = map->recordings[i];\n        err = hexmap_load_recording(map, recording->filename,\n            recording->palmapper, true);\n        if(err)return err;\n    }\n\n    free(text);\n    return 0;\n}\n\nint hexmap_parse(hexmap_t *map, hexgame_t *game, char *name,\n    fus_lexer_t *lexer\n){\n    int err;\n\n    prismelrenderer_t *prend = game->prend;\n\n    /* parse unit */\n    vec_t unit;\n    err = fus_lexer_get(lexer, \"unit\");\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n    for(int i = 0; i < prend->space->dims; i++){\n        err = fus_lexer_get_int(lexer, &unit[i]);\n        if(err)return err;\n    }\n    err = fus_lexer_get(lexer, \")\");\n    if(err)return err;\n\n    /* init the map */\n    err = hexmap_init(map, game, name, unit);\n    if(err)return err;\n\n    /* parse spawn point */\n    char *spawn_filename = NULL;\n    err = fus_lexer_get(lexer, \"spawn\");\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n    if(fus_lexer_got_str(lexer)){\n        err = fus_lexer_get_str(lexer, &spawn_filename);\n        if(err)return err;\n    }else{\n        err = fus_lexer_get_vec(lexer, map->space, map->spawn);\n        if(err)return err;\n    }\n    err = fus_lexer_get(lexer, \")\");\n    if(err)return err;\n\n    /* default palette */\n    char *default_palette_filename;\n    err = fus_lexer_get(lexer, \"default_palette\");\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n    err = fus_lexer_get_str(lexer, &default_palette_filename);\n    if(err)return err;\n    err = fus_lexer_get(lexer, \")\");\n    if(err)return err;\n\n    /* default tileset */\n    char *default_tileset_filename;\n    err = fus_lexer_get(lexer, \"default_tileset\");\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n    err = fus_lexer_get_str(lexer, &default_tileset_filename);\n    if(err)return err;\n    err = fus_lexer_get(lexer, \")\");\n    if(err)return err;\n\n\n    /* parse actors */\n    if(fus_lexer_got(lexer, \"actors\")){\n    err = fus_lexer_next(lexer);\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n    while(1){\n        if(fus_lexer_got(lexer, \")\"))break;\n\n        char *filename;\n        palettemapper_t *palmapper = NULL;\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n        err = fus_lexer_get_str(lexer, &filename);\n        if(err)return err;\n        if(!fus_lexer_got(lexer, \")\")){\n            char *palmapper_name;\n            err = fus_lexer_get_str(lexer, &palmapper_name);\n            if(err)return err;\n            palmapper =\n                prismelrenderer_get_palmapper(prend, palmapper_name);\n            if(palmapper == NULL){\n                fprintf(stderr, \"Couldn't find palmapper: %s\\n\",\n                    palmapper_name);\n                free(palmapper_name); return 2;\n            }\n            free(palmapper_name);\n        }\n        err = fus_lexer_get(lexer, \")\");\n        if(err)return err;\n\n        ARRAY_PUSH_NEW(hexmap_recording_t*, map->actor_recordings,\n            recording)\n        err = hexmap_recording_init(recording,\n            filename, palmapper);\n        if(err)return err;\n    }\n    err = fus_lexer_next(lexer);\n    if(err)return err;\n    }\n\n\n    /* parse submaps */\n    err = fus_lexer_get(lexer, \"submaps\");\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n    while(1){\n        if(fus_lexer_got(lexer, \")\"))break;\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n        err = hexmap_parse_submap(map, lexer, true,\n            (vec_t){0}, (vec_t){0}, 0, NULL,\n            default_palette_filename, default_tileset_filename);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \")\");\n        if(err)return err;\n    }\n    err = fus_lexer_next(lexer);\n    if(err)return err;\n\n\n    /* maybe get spawn point from a submap */\n    if(spawn_filename != NULL){\n        hexmap_submap_t *spawn_submap = NULL;\n        for(int i = 0; i < map->submaps_len; i++){\n            hexmap_submap_t *submap = map->submaps[i];\n            if(strcmp(submap->filename, spawn_filename) == 0){\n                spawn_submap = submap; break;}\n        }\n        if(spawn_submap == NULL){\n            fprintf(stderr, \"Couldn't find submap with filename: %s\\n\",\n                spawn_filename);\n            return 2;}\n        vec_cpy(map->space->dims, map->spawn, spawn_submap->pos);\n        free(spawn_filename);\n    }\n\n\n    /* pheeew */\n    return 0;\n}\n\nint hexmap_parse_submap(hexmap_t *map, fus_lexer_t *lexer, bool solid,\n    vec_t parent_pos, vec_t parent_camera_pos, int parent_camera_type,\n    prismelmapper_t *parent_mapper, char *palette_filename,\n    char *tileset_filename\n){\n    int err;\n    vecspace_t *space = map->space;\n    prismelrenderer_t *prend = map->prend;\n\n    if(fus_lexer_got(lexer, \"skip\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        err = fus_lexer_parse_silent(lexer);\n        if(err)return err;\n        return 0;\n    }\n\n    if(fus_lexer_got(lexer, \"bg\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        solid = false;\n    }\n\n    char *submap_filename = NULL;\n    if(fus_lexer_got(lexer, \"file\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n        err = fus_lexer_get_str(lexer, &submap_filename);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \")\");\n        if(err)return err;\n    }\n\n    vec_t door_pos;\n    vec_zero(door_pos);\n    rot_t door_rot = 0;\n    bool door_turn = false;\n    char *door_map_filename = NULL;\n    char *door_anim_filename = NULL;\n    if(fus_lexer_got(lexer, \"door\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n        {\n            if(fus_lexer_got(lexer, \"map\")){\n                err = fus_lexer_next(lexer);\n                if(err)return err;\n                err = fus_lexer_get(lexer, \"(\");\n                if(err)return err;\n                err = fus_lexer_get_str(lexer, &door_map_filename);\n                if(err)return err;\n                err = fus_lexer_get(lexer, \")\");\n                if(err)return err;\n            }else{\n                /* Non-null door_map_filename indicates player should\n                \"teleport\" to door_pos, door_rot, door_turn */\n                door_map_filename = strdup(map->name);\n            }\n\n            if(fus_lexer_got(lexer, \"anim\")){\n                err = fus_lexer_next(lexer);\n                if(err)return err;\n                err = fus_lexer_get(lexer, \"(\");\n                if(err)return err;\n                err = fus_lexer_get_str(lexer, &door_anim_filename);\n                if(err)return err;\n                err = fus_lexer_get(lexer, \")\");\n                if(err)return err;\n            }\n\n            err = fus_lexer_get(lexer, \"pos\");\n            if(err)return err;\n            err = fus_lexer_get(lexer, \"(\");\n            if(err)return err;\n            err = fus_lexer_get_vec(lexer, space, door_pos);\n            if(err)return err;\n            err = fus_lexer_get(lexer, \")\");\n            if(err)return err;\n\n            err = fus_lexer_get(lexer, \"rot\");\n            if(err)return err;\n            err = fus_lexer_get(lexer, \"(\");\n            if(err)return err;\n            err = fus_lexer_get_int(lexer, &door_rot);\n            if(err)return err;\n            err = fus_lexer_get(lexer, \")\");\n            if(err)return err;\n\n            err = fus_lexer_get(lexer, \"turn\");\n            if(err)return err;\n            err = fus_lexer_get(lexer, \"(\");\n            if(err)return err;\n            err = fus_lexer_get_yesno(lexer, &door_turn);\n            if(err)return err;\n            err = fus_lexer_get(lexer, \")\");\n            if(err)return err;\n        }\n        err = fus_lexer_get(lexer, \")\");\n        if(err)return err;\n    }\n\n    vec_t pos = {0};\n    if(fus_lexer_got(lexer, \"pos\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n        err = fus_lexer_get_vec(lexer, space, pos);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \")\");\n        if(err)return err;\n    }\n    vec_add(space->dims, pos, parent_pos);\n\n    int camera_type = parent_camera_type;\n    vec_t camera_pos;\n    vec_cpy(space->dims, camera_pos, parent_camera_pos);\n    if(fus_lexer_got(lexer, \"camera\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n        if(fus_lexer_got(lexer, \"follow\")){\n            err = fus_lexer_next(lexer);\n            if(err)return err;\n            camera_type = 1;\n        }else{\n            err = fus_lexer_get_vec(lexer, space, camera_pos);\n            if(err)return err;\n            vec_add(space->dims, camera_pos, pos);\n        }\n        err = fus_lexer_get(lexer, \")\");\n        if(err)return err;\n    }\n\n    prismelmapper_t *mapper = parent_mapper;\n    if(fus_lexer_got(lexer, \"mapper\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n        err = fus_lexer_get_mapper(lexer, map->prend, NULL, &mapper);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \")\");\n        if(err)return err;\n    }\n\n    if(fus_lexer_got(lexer, \"palette\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n        err = fus_lexer_get_str(lexer, &palette_filename);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \")\");\n        if(err)return err;\n    }\n\n    if(fus_lexer_got(lexer, \"tileset\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n        err = fus_lexer_get_str(lexer, &tileset_filename);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \")\");\n        if(err)return err;\n    }\n\n    if(submap_filename != NULL){\n        ARRAY_PUSH_NEW(hexmap_submap_t*, map->submaps, submap)\n        err = hexmap_submap_init(map, submap, strdup(submap_filename),\n            solid, pos, camera_type, camera_pos, mapper,\n            palette_filename, tileset_filename);\n        if(err)return err;\n\n        /* load collmap */\n        err = hexcollmap_load(&submap->collmap, submap_filename);\n        if(err)return err;\n\n        /* render submap->rgraph_map */\n        err = hexmap_submap_create_rgraph(map, submap);\n        if(err)return err;\n\n        /* door stuff */\n        vec_cpy(space->dims, submap->door_pos, door_pos);\n        submap->door_rot = door_rot;\n        submap->door_turn = door_turn;\n        submap->door_map_filename = door_map_filename;\n        submap->door_anim_filename = door_anim_filename;\n    }\n\n    if(fus_lexer_got(lexer, \"recordings\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n        while(1){\n            if(fus_lexer_got(lexer, \")\"))break;\n\n            char *filename;\n            palettemapper_t *palmapper = NULL;\n            err = fus_lexer_get(lexer, \"(\");\n            if(err)return err;\n            err = fus_lexer_get_str(lexer, &filename);\n            if(err)return err;\n            if(!fus_lexer_got(lexer, \")\")){\n                char *palmapper_name;\n                err = fus_lexer_get_str(lexer, &palmapper_name);\n                if(err)return err;\n                palmapper =\n                    prismelrenderer_get_palmapper(prend, palmapper_name);\n                if(palmapper == NULL){\n                    fprintf(stderr, \"Couldn't find palmapper: %s\\n\",\n                        palmapper_name);\n                    free(palmapper_name); return 2;\n                }\n                free(palmapper_name);\n            }\n            err = fus_lexer_get(lexer, \")\");\n            if(err)return err;\n\n            ARRAY_PUSH_NEW(hexmap_recording_t*, map->recordings,\n                recording)\n            err = hexmap_recording_init(recording,\n                filename, palmapper);\n            if(err)return err;\n        }\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n    }\n\n    if(fus_lexer_got(lexer, \"submaps\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n        while(1){\n            if(fus_lexer_got(lexer, \")\"))break;\n            err = fus_lexer_get(lexer, \"(\");\n            if(err)return err;\n            err = hexmap_parse_submap(map, lexer, true, pos,\n                camera_pos, camera_type, mapper,\n                palette_filename, tileset_filename);\n            if(err)return err;\n            err = fus_lexer_get(lexer, \")\");\n            if(err)return err;\n        }\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n    }\n\n    return 0;\n}\n\nint hexmap_load_recording(hexmap_t *map, const char *filename,\n    palettemapper_t *palmapper, bool loop\n){\n    int err;\n\n    hexgame_t *game = map->game;\n\n    ARRAY_PUSH_NEW(body_t*, map->bodies, body)\n    err = body_init(body, game, map, NULL, NULL, palmapper);\n    if(err)return err;\n\n    err = recording_load(&body->recording, filename, body, loop);\n    if(err)return err;\n\n    err = body_play_recording(body);\n    if(err)return err;\n\n    return 0;\n}\n\nstatic int hexmap_collide_elem(hexmap_t *map, int all_type,\n    int x, int y, trf_t *trf,\n    hexcollmap_elem_t *elems2, int rot,\n    void (*normalize_elem)(trf_t *index),\n    hexcollmap_elem_t *(get_elem)(\n        hexcollmap_t *collmap, trf_t *index),\n    hexmap_submap_t **collide_savepoint_ptr,\n    hexmap_submap_t **collide_door_ptr,\n    hexmap_submap_t **collide_water_ptr\n){\n    /* Returns true (1) or false (0), or 2 if caller should continue\n    checking for a collision. */\n\n    vecspace_t *space = map->space;\n\n    for(int r2 = 0; r2 < rot; r2++){\n        if(!hexcollmap_elem_is_solid(&elems2[r2]))continue;\n\n        trf_t index;\n        hexspace_set(index.add, x, y);\n        index.rot = r2;\n        index.flip = false;\n\n        /* And now, because we were fools and defined */\n        /* the tile coords such that their Y is flipped */\n        /* compared to vecspaces, we need to flip that Y */\n        /* before calling trf_apply and then flip it back */\n        /* again: */\n        index.add[1] = -index.add[1];\n        trf_apply(space, &index, trf);\n        index.add[1] = -index.add[1];\n        normalize_elem(&index);\n\n        bool collide = false;\n        for(int i = 0; i < map->submaps_len; i++){\n            hexmap_submap_t *submap = map->submaps[i];\n            if(!submap->solid)continue;\n\n            hexcollmap_t *collmap1 = &submap->collmap;\n\n            trf_t subindex;\n            hexspace_set(subindex.add,\n                index.add[0] - submap->pos[0],\n                index.add[1] + submap->pos[1]);\n            subindex.rot = index.rot;\n            subindex.flip = index.flip;\n\n            hexcollmap_elem_t *elem = get_elem(collmap1, &subindex);\n            if(elem != NULL){\n                if(elem->tile_c == 'S')*collide_savepoint_ptr = submap;\n                if(elem->tile_c == 'D')*collide_door_ptr = submap;\n                if(elem->tile_c == 'w')*collide_water_ptr = submap;\n            }\n            if(hexcollmap_elem_is_solid(elem)){\n                collide = true; break;}\n        }\n        if(all_type != 2){\n            bool all = all_type;\n            if((all && !collide) || (!all && collide))return collide;\n        }else{\n            /* Just looking for savepoints & doors... */\n        }\n    }\n    return 2; /* Caller should keep looking for a collision */\n}\n\nstatic bool _hexmap_collide(hexmap_t *map, hexcollmap_t *collmap2,\n    trf_t *trf, int all_type,\n    hexmap_submap_t **collide_savepoint_ptr,\n    hexmap_submap_t **collide_door_ptr,\n    hexmap_submap_t **collide_water_ptr\n){\n\n    int ox2 = collmap2->ox;\n    int oy2 = collmap2->oy;\n    int w2 = collmap2->w;\n    int h2 = collmap2->h;\n\n    vecspace_t *space = map->space;\n\n    /* NOTE: for tile coords (ox, oy, x, y, w, h),\n    Y is reversed (down is positive, up is negative) */\n\n    for(int y2 = 0; y2 < h2; y2++){\n        for(int x2 = 0; x2 < w2; x2++){\n            hexcollmap_tile_t *tile2 = &collmap2->tiles[y2 * w2 + x2];\n\n            int collide;\n            int x = x2 - ox2;\n            int y = y2 - oy2;\n            collide = hexmap_collide_elem(map, all_type,\n                x, y, trf,\n                tile2->vert, 1,\n                hexcollmap_normalize_vert,\n                hexcollmap_get_vert,\n                collide_savepoint_ptr, collide_door_ptr,\n                collide_water_ptr);\n            if(collide != 2)return collide;\n            collide = hexmap_collide_elem(map, all_type,\n                x, y, trf,\n                tile2->edge, 3,\n                hexcollmap_normalize_edge,\n                hexcollmap_get_edge,\n                collide_savepoint_ptr, collide_door_ptr,\n                collide_water_ptr);\n            if(collide != 2)return collide;\n            collide = hexmap_collide_elem(map, all_type,\n                x, y, trf,\n                tile2->face, 2,\n                hexcollmap_normalize_face,\n                hexcollmap_get_face,\n                collide_savepoint_ptr, collide_door_ptr,\n                collide_water_ptr);\n            if(collide != 2)return collide;\n        }\n    }\n    if(all_type == 2){\n        /* Return value doesn't matter, we were just looking for\n        savepoints & doors */\n        return false;\n    }else{\n        bool all = all_type;\n        if(all)return true;\n        else return false;\n    }\n}\n\nbool hexmap_collide(hexmap_t *map, hexcollmap_t *collmap2,\n    trf_t *trf, bool all\n){\n    hexmap_submap_t *collide_savepoint;\n    hexmap_submap_t *collide_door;\n    hexmap_submap_t *collide_water;\n    return _hexmap_collide(map, collmap2, trf, all,\n        &collide_savepoint, &collide_door, &collide_water);\n}\n\nvoid hexmap_collide_special(hexmap_t *map, hexcollmap_t *collmap2,\n    trf_t *trf,\n    hexmap_submap_t **collide_savepoint_ptr,\n    hexmap_submap_t **collide_door_ptr,\n    hexmap_submap_t **collide_water_ptr\n){\n    int all_type = 2;\n    _hexmap_collide(map, collmap2, trf, all_type,\n        collide_savepoint_ptr, collide_door_ptr, collide_water_ptr);\n}\n\n\nint hexmap_step(hexmap_t *map){\n    int err;\n\n    hexgame_t *game = map->game;\n    vecspace_t *space = game->space;\n\n    /* Collide bodies with each other */\n    for(int i = 0; i < map->bodies_len; i++){\n        body_t *body = map->bodies[i];\n        if(body->state == NULL)continue;\n        hexcollmap_t *hitbox = body->state->hitbox;\n        if(hitbox == NULL)continue;\n\n        trf_t hitbox_trf;\n        body_init_trf(body, &hitbox_trf);\n\n        /* This body has a hitbox! So collide it against all other bodies'\n        hitboxes. */\n        for(int j = i + 1; j < map->bodies_len; j++){\n            body_t *body_other = map->bodies[j];\n            if(body_other->state == NULL)continue;\n            hexcollmap_t *hitbox_other = body_other->state->hitbox;\n            if(hitbox_other == NULL)continue;\n\n            trf_t hitbox_other_trf;\n            body_init_trf(body_other, &hitbox_other_trf);\n\n            /* The other body has a hitbox! Do the collision... */\n            bool collide = hexcollmap_collide(hitbox, &hitbox_trf,\n                hitbox_other, &hitbox_other_trf, space, false);\n            if(collide){\n                /* There was a collision!\n                Now we find out who was right... and who was dead. */\n                err = body_collide_against_body(body, body_other);\n                if(err)return err;\n                err = body_collide_against_body(body_other, body);\n                if(err)return err;\n            }\n        }\n    }\n\n    /* Do 1 gameplay step for each body */\n    for(int i = 0; i < map->bodies_len; i++){\n        body_t *body = map->bodies[i];\n        err = body_step(body, game);\n        if(err)return err;\n    }\n\n    return 0;\n}\n\n\n\n/*****************\n * HEXMAP SUBMAP *\n *****************/\n\nvoid hexmap_submap_cleanup(hexmap_submap_t *submap){\n    free(submap->filename);\n    free(submap->door_map_filename);\n    free(submap->door_anim_filename);\n    hexcollmap_cleanup(&submap->collmap);\n    palette_cleanup(&submap->palette);\n    hexmap_tileset_cleanup(&submap->tileset);\n}\n\nint hexmap_submap_init(hexmap_t *map, hexmap_submap_t *submap,\n    char *filename, bool solid, vec_t pos, int camera_type, vec_t camera_pos,\n    prismelmapper_t *mapper, char *palette_filename, char *tileset_filename\n){\n    int err;\n\n    submap->filename = filename;\n    vec_cpy(MAX_VEC_DIMS, submap->pos, pos);\n\n    submap->solid = solid;\n\n    submap->camera_type = camera_type;\n    vec_cpy(MAX_VEC_DIMS, submap->camera_pos, camera_pos);\n\n    err = hexcollmap_init(&submap->collmap, map->space, strdup(filename));\n    if(err)return err;\n\n    submap->rgraph_map = NULL;\n    submap->mapper = mapper;\n\n    err = palette_load(&submap->palette, palette_filename);\n    if(err)return err;\n\n    err = hexmap_tileset_load(&submap->tileset, map->prend,\n        tileset_filename);\n    if(err)return err;\n\n    vec_zero(submap->door_pos);\n    submap->door_rot = 0;\n    submap->door_turn = false;\n    submap->door_map_filename = NULL;\n    submap->door_anim_filename = NULL;\n\n    return 0;\n}\n\nstatic int add_tile_rgraph(rendergraph_t *rgraph, rendergraph_t *rgraph2,\n    vecspace_t *space, vec_t add, rot_t rot, int frame_i\n){\n    int err;\n    rendergraph_trf_t *rendergraph_trf;\n    err = rendergraph_push_rendergraph_trf(rgraph, &rendergraph_trf);\n    if(err)return err;\n    rendergraph_trf->rendergraph = rgraph2;\n    rendergraph_trf->trf.rot = rot;\n    rendergraph_trf->frame_i = frame_i;\n    vec_cpy(space->dims, rendergraph_trf->trf.add, add);\n    return 0;\n}\n\nint hexmap_submap_create_rgraph(hexmap_t *map, hexmap_submap_t *submap){\n    int err;\n\n    prismelrenderer_t *prend = map->prend;\n    vecspace_t *space = prend->space;\n    hexcollmap_t *collmap = &submap->collmap;\n\n    /* BIG OL' HACK: If any \"tile\" rgraphs are animated, we need the\n    map's rgraph to be animated also.\n    The most correct way to do this is I guess to compute the LCD of\n    the tile rgraphs' n_frames, and set the map's rgraph's n_frames\n    to that.\n    But for now we use a magic number which has \"many\" divisors.\n    That's a lot of bitmaps to cache for the map's rgraph, though...\n    if we're going to allow complicated map animations, maybe we\n    should disable bitmap caching for it (somehow). */\n    int n_frames = 24;\n\n    ARRAY_PUSH_NEW(rendergraph_t*, prend->rendergraphs, rgraph)\n    err = rendergraph_init(rgraph, strdup(submap->filename), prend, NULL,\n        rendergraph_animation_type_default,\n        n_frames);\n    if(err)return err;\n\n    hexmap_tileset_t *tileset = &submap->tileset;\n\n    for(int y = 0; y < collmap->h; y++){\n        for(int x = 0; x < collmap->w; x++){\n            int px = x - collmap->ox;\n            int py = y - collmap->oy;\n\n            vec_t v;\n            vec4_set(v, px + py, 0, -py, 0);\n            vec_mul(space, v, map->unit);\n\n            hexcollmap_tile_t *tile =\n                &collmap->tiles[y * collmap->w + x];\n\n            #define HEXMAP_ADD_TILE(PART, ROT) \\\n                for(int i = 0; i < ROT; i++){ \\\n                    hexcollmap_elem_t *elem = &tile->PART[i]; \\\n                    if(!hexcollmap_elem_is_visible(elem))continue; \\\n                    rendergraph_t *rgraph_tile; \\\n                    bool rot_ok; \\\n                    int frame_offset; \\\n                    hexmap_tileset_get_rgraph_##PART(tileset, \\\n                            elem->tile_c, i, \\\n                            &rgraph_tile, &rot_ok, &frame_offset); \\\n                    int frame_i = frame_offset? x: 0; \\\n                    if(rgraph_tile == NULL){ \\\n                        fprintf(stderr, \"Couldn't find \" #PART \" tile \" \\\n                            \"for character: %c\\n\", elem->tile_c); \\\n                        return 2;} \\\n                    err = add_tile_rgraph(rgraph, rgraph_tile, \\\n                        space, v, rot_ok? 0: i * 2, frame_i); \\\n                    if(err)return err; \\\n                }\n            HEXMAP_ADD_TILE(vert, 1)\n            HEXMAP_ADD_TILE(edge, 3)\n            HEXMAP_ADD_TILE(face, 2)\n            #undef HEXMAP_ADD_TILE\n        }\n    }\n\n    submap->rgraph_map = rgraph;\n    return 0;\n}\n\n","\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n#include \"hexmap.h\"\n#include \"lexer.h\"\n#include \"util.h\"\n#include \"mathutil.h\"\n#include \"geom.h\"\n#include \"vec4.h\"\n#include \"hexspace.h\"\n#include \"prismelrenderer.h\"\n\n\n\n/**************\n * HEXCOLLMAP *\n **************/\n\nint hexcollmap_part_init(hexcollmap_part_t *part,\n    char part_c, char *filename, int type\n){\n    part->part_c = part_c;\n    part->filename = filename;\n    part->type = type;\n    return 0;\n}\n\nvoid hexcollmap_part_cleanup(hexcollmap_part_t *part){\n    free(part->filename);\n}\n\n\nvoid hexcollmap_cleanup(hexcollmap_t *collmap){\n    free(collmap->name);\n    free(collmap->tiles);\n}\n\nint hexcollmap_init(hexcollmap_t *collmap, vecspace_t *space,\n    char *name\n){\n    memset(collmap, 0, sizeof(*collmap));\n    collmap->name = name;\n    collmap->space = space;\n    return 0;\n}\n\nvoid hexcollmap_dump(hexcollmap_t *collmap, FILE *f, int n_spaces){\n    char spaces[20];\n    get_spaces(spaces, 20, n_spaces);\n\n    fprintf(f, \"%shexcollmap: %p\\n\", spaces, collmap);\n    if(collmap == NULL)return;\n    fprintf(f, \"%s  origin: %i %i\\n\", spaces, collmap->ox, collmap->oy);\n    fprintf(f, \"%s  tiles:\\n\", spaces);\n    for(int y = 0; y < collmap->h; y++){\n        fprintf(f, \"%s    \", spaces);\n        for(int x = 0; x < collmap->w; x++){\n            hexcollmap_tile_t *tile = &collmap->tiles[y * collmap->w + x];\n            fprintf(f, \"[\");\n                for(int i = 0; i < 1; i++){\n                    fprintf(f, \"%c\", tile->vert[i].tile_c);}\n            fprintf(f, \"][\");\n                for(int i = 0; i < 3; i++){\n                    fprintf(f, \"%c\", tile->edge[i].tile_c);}\n            fprintf(f, \"][\");\n                for(int i = 0; i < 2; i++){\n                    fprintf(f, \"%c\", tile->face[i].tile_c);}\n            fprintf(f, \"] \");\n        }\n        fprintf(f, \"\\n\");\n    }\n}\n\nstatic bool represents_vert(char c){return c == '+';}\nstatic bool represents_edge(char c){return strchr(\"-/\\\\\", c) != NULL;}\nstatic bool represents_face(char c){return c == '*';}\n\nstatic char get_map_elem_type(int x, int y){\n    /* A poorly-named function which figures out whether a vert, edge, or\n    face is at the given hexcollmap coordinates */\n\n    /* What a tile looks like in the hexcollmap text format: */\n    //   \"  + - +    \"\n    //   \"   \\*/*\\   \"\n    //   \"   (+)- +  \"\n    /* ...where ( ) indicates the origin (x=0, y=0) */\n\n    /* apply the formula for a vertex */\n    int rem_x = _rem(x - y, 4);\n    int rem_y = _rem(y, 2);\n\n    if(rem_y == 0){\n        // + - + - + - ...\n        if(rem_x == 0)return '+';\n        if(rem_x == 2)return '-';\n    }else{\n        // \\*/*\\*/*\\* ...\n        if(rem_x == 0)return '\\\\';\n        if(rem_x == 1)return '*';\n        if(rem_x == 2)return '/';\n        if(rem_x == 3)return '*';\n    }\n    return ' ';\n}\n\nstatic void get_map_coords(int x, int y, char c,\n    int *mx_ptr, int *my_ptr, bool *is_face1_ptr\n){\n    bool is_face1 = false;\n\n    /* What a tile looks like in the hexcollmap text format: */\n    //   \"  + - +    \"\n    //   \"   \\*/*\\   \"\n    //   \"   (+)- +  \"\n    /* ...where ( ) indicates the origin (x=0, y=0) */\n\n    /* Step 1: find x, y of vertex */\n    if(c == '+'){\n    }else if(c == '-'){\n        x -= 1;\n    }else if(c == '/'){\n        x -= 1;\n        y += 1;\n    }else if(c == '\\\\'){\n        x += 1;\n        y += 1;\n    }else if(c == '*'){\n        /* assume we're the right-hand triangle */\n        x -= 2;\n        y += 1;\n        if(_rem(x + y, 4) != 0){\n            /* oh, actually we were the left-hand triangle */\n            x += 2;\n            is_face1 = true;\n        }\n    }\n\n    /* Step 2: apply the formula for a vertex */\n    *mx_ptr = _div(x - y, 4);\n    *my_ptr = _div(y, 2);\n    if(is_face1_ptr != NULL)*is_face1_ptr = is_face1;\n}\n\nstatic int hexcollmap_draw(hexcollmap_t *collmap1, hexcollmap_t *collmap2,\n    trf_t *trf, int draw_z\n){\n    int err;\n\n    int ox2 = collmap2->ox;\n    int oy2 = collmap2->oy;\n    int w2 = collmap2->w;\n    int h2 = collmap2->h;\n\n    vecspace_t *space = collmap1->space;\n\n    /* NOTE: for tile coords (ox, oy, x, y, w, h),\n    Y is reversed (down is positive, up is negative) */\n\n    for(int y2 = 0; y2 < h2; y2++){\n        for(int x2 = 0; x2 < w2; x2++){\n            hexcollmap_tile_t *tile2 = &collmap2->tiles[y2 * w2 + x2];\n\n            #define HEXCOLLMAP_DRAW(PART, ROT) \\\n                for(int r2 = 0; r2 < ROT; r2++){ \\\n                    hexcollmap_elem_t *elem2 = &tile2->PART[r2]; \\\n                    if(elem2->tile_c != 'x' && \\\n                        !hexcollmap_elem_is_visible(elem2)){ \\\n                            continue; } \\\n                    \\\n                    trf_t index; \\\n                    hexspace_set(index.add, x2 - ox2, y2 - oy2); \\\n                    index.rot = r2; \\\n                    index.flip = false; \\\n                    \\\n                    /* And now, because we were fools and defined */ \\\n                    /* the tile coords such that their Y is flipped */ \\\n                    /* compared to vecspaces, we need to flip that Y */ \\\n                    /* before calling trf_apply and then flip it back */ \\\n                    /* again: */ \\\n                    index.add[1] = -index.add[1]; \\\n                    trf_apply(space, &index, trf); \\\n                    index.add[1] = -index.add[1]; \\\n                    hexcollmap_normalize_##PART(&index); \\\n                    \\\n                    hexcollmap_elem_t *elem1 = \\\n                        hexcollmap_get_##PART(collmap1, &index); \\\n                    if(elem1 != NULL && draw_z >= elem1->z){ \\\n                        elem1->tile_c = elem2->tile_c; \\\n                        elem1->z = draw_z;} \\\n                }\n            HEXCOLLMAP_DRAW(vert, 1)\n            HEXCOLLMAP_DRAW(edge, 3)\n            HEXCOLLMAP_DRAW(face, 2)\n            #undef HEXCOLLMAP_DRAW\n        }\n    }\n    return 0;\n}\n\nstatic int hexcollmap_draw_part(hexcollmap_t *collmap,\n    hexcollmap_part_t *part, trf_t trf, int draw_z\n){\n    int err;\n    if(part->type == HEXCOLLMAP_PART_TYPE_HEXCOLLMAP){\n        /* If \"empty\" was specified for this part, then filename will\n        be NULL and we shouldn't do anything. */\n        if(part->filename == NULL)return 0;\n\n        hexcollmap_t part_collmap;\n        err = hexcollmap_init(&part_collmap,\n            collmap->space, strdup(part->filename));\n        if(err)return err;\n        err = hexcollmap_load(&part_collmap,\n            part->filename);\n        if(err)return err;\n        err = hexcollmap_draw(collmap, &part_collmap,\n            &trf, draw_z);\n        if(err)return err;\n        hexcollmap_cleanup(&part_collmap);\n    }else if(part->type == HEXCOLLMAP_PART_TYPE_RECORDING){\n        /* TODO */\n    }else{\n        fprintf(stderr, \"Unrecognized part type: %i\\n\", part->type);\n        return 2;\n    }\n\n    return 0;\n}\n\nstatic int hexcollmap_parse_lines(hexcollmap_t *collmap,\n    char **lines, int lines_len, hexcollmap_part_t **parts, int parts_len,\n    char default_vert_c, char default_edge_c, char default_face_c\n){\n    int err;\n\n    /* Iteration 1: Find origin */\n    int ox = -1;\n    int oy = -1;\n    for(int y = 0; y < lines_len; y++){\n        char *line = lines[y];\n        int line_len = strlen(line);\n        for(int x = 0; x < line_len; x++){\n            char c = line[x];\n            if(c == '('){\n                if(x+2 >= line_len || line[x+2] != ')'){\n                    fprintf(stderr, \"Line %i, char %i: '(' without \"\n                        \"matching ')'. Line: %s\\n\",\n                        y, x, line);\n                    return 2;\n                }\n                if(oy != -1){\n                    fprintf(stderr, \"Line %i, char %i: another '('.\"\n                        \" Line: %s\\n\", y, x, line);\n                    return 2;\n                }\n                ox = x + 1;\n                oy = y;\n                x += 2;\n            }else if(strchr(\" x.+/-\\\\*SDw%?\", c) != NULL){\n                /* these are all fine */\n            }else if(c == '['){\n                /* next line plz, \"tilebuckets\" don't affect the origin */\n                break;\n            }else{\n                fprintf(stderr, \"Line %i, char %i: unexpected character.\"\n                    \" Line: %s\\n\", y, x, line);\n                return 2;\n            }\n        }\n    }\n\n    /* Iteration 2: Find map bounds */\n    int map_t = 0;\n    int map_b = 0;\n    int map_l = 0;\n    int map_r = 0;\n    for(int y = 0; y < lines_len; y++){\n        char *line = lines[y];\n        int line_len = strlen(line);\n        for(int x = 0; x < line_len; x++){\n            char c = line[x];\n            if(strchr(\".+/-\\\\*SDw?\", c) != NULL){\n                int mx, my; bool is_face1;\n\n                /* savepoints, doors are just faces */\n                if(c == 'S' || c == 'D' || c == 'w')c = '*';\n\n                /* dots & part references are just verts */\n                if(c == '.' || c == '?')c = '+';\n\n                char elem_type = get_map_elem_type(x-ox, y-oy);\n                if(elem_type != c){\n                    fprintf(stderr, \"Line %i, char %i: character doesn't \"\n                        \"belong at these coordinates: got %c, expected %c\\n\",\n                        y, x, c, elem_type);\n                    return 2;}\n\n                get_map_coords(x-ox, y-oy, c,\n                    &mx, &my, &is_face1);\n                map_t = _min(map_t, my);\n                map_b = _max(map_b, my);\n                map_l = _min(map_l, mx);\n                map_r = _max(map_r, mx);\n            }else if(strchr(\" x.+/-\\\\*SDw%?()\", c) != NULL){\n                /* these are all fine */\n            }else if(c == '['){\n                /* next line plz, \"tilebuckets\" don't affect bounds */\n                break;\n            }\n        }\n    }\n\n    /* Intermission: initialize collmap with empty tile data */\n    /* ...Allocate map data */\n    int map_w = map_r - map_l + 1;\n    int map_h = map_b - map_t + 1;\n    int map_size = map_w * map_h;\n    hexcollmap_tile_t *tiles = calloc(map_size, sizeof(*tiles));\n    if(tiles == NULL)return 1;\n    /* ...Initialize tile elements */\n    for(int i = 0; i < map_size; i++){\n        for(int j = 0; j < 1; j++)tiles[i].vert[j].tile_c = ' ';\n        for(int j = 0; j < 3; j++)tiles[i].edge[j].tile_c = ' ';\n        for(int j = 0; j < 2; j++)tiles[i].face[j].tile_c = ' ';\n    }\n    /* ...Assign attributes */\n    collmap->ox = -map_l;\n    collmap->oy = -map_t;\n    collmap->w = map_w;\n    collmap->h = map_h;\n    collmap->tiles = tiles;\n\n    /* Iterations 3 & 4: The meat of it all - parse tile data */\n    for(int iter_i = 0; iter_i < 2; iter_i++){\n        /* While iter_i == 0, we parse regular tile data.\n        While iter_i == 1, we parse \"part references\", that is, the '?'\n        character, which loads & draws other collmaps over the tile data\n        we parsed while iter_i == 0. */\n        bool parsing_part_references = iter_i == 1;\n    for(int y = 0; y < lines_len; y++){\n        char *line = lines[y];\n        int line_len = strlen(line);\n\n        char *tilebucket = NULL;\n        bool tilebucket_active = false;\n            /* A \"tile bucket\" is a group of characters at the end\n            of the line, surrounded by square brackets, e.g. [1aq].\n            While parsing a line, the '%' character indicates that we\n            should find the next tile bucket; then, as we encounter\n            '-' '/' '\\' '+' '*' characters, we will use the characters\n            in the bucket one at a time as the tile_c character,\n            instead of the default tile_c.\n            While parsing a line, '?' works similarly to '%' except\n            that instead of modifying tile_c, it loads and draws other\n            collmaps over this one, according to the \"parts\" indicated\n            at the top of the file.\n            TODO: Clarify this comment... */\n\n        for(int x = 0; x < line_len; x++){\n            char c = line[x];\n            if(strchr(\"x+/-\\\\*SDw\", c) != NULL){\n                int mx, my; bool is_face1;\n\n                bool is_savepoint = c == 'S';\n                bool is_door = c == 'D';\n                bool is_water = c == 'w';\n                if(is_savepoint || is_door || is_water)c = '*';\n\n                bool is_hard_transparent = c == 'x';\n                if(is_hard_transparent)c = get_map_elem_type(x-ox, y-oy);\n\n                char tile_c =\n                    is_savepoint? 'S':\n                    is_door? 'D':\n                    is_water? 'w':\n                    is_hard_transparent? 'x':\n                    represents_vert(c)? default_vert_c:\n                    represents_edge(c)? default_edge_c:\n                    represents_face(c)? default_face_c:\n                    ' ';\n                    /* NOTE: The way we've implemented this, 'S' and 'D'\n                    can be overwritten by '%'. Maybe that's weird? Maybe if\n                    is_savepoint or is_door then we should skip the check\n                    for tilebucket_active entirely? */\n\n                int draw_z = 0;\n\n                if(tilebucket_active){\n                    /* Get next non-' ' character in current tile bucket. */\n                    char c2;\n                    while(c2 = *tilebucket, c2 == ' ')tilebucket++;\n                    if(c2 == ']'){\n                        tilebucket_active = false;\n                    }else if(!isprint(c2)){\n                        fprintf(stderr,\n                            \"Hexcollmap line %i, char %i: char %td: \",\n                            y+1, x+1, tilebucket-line+1);\n                        if(c2 == '\\0'){\n                            fprintf(stderr, \"Hit end of line\\n\");}\n                        else{fprintf(stderr,\n                            \"Hit unprintable character: %x\\n\", c2);}\n                        return 2;\n                    }else{\n                        tile_c = c2;\n                        tilebucket++;\n                        while(1){\n                            if(*tilebucket == '|'){\n                                tilebucket++;\n                                draw_z = atoi(tilebucket);\n                                while(isdigit(*tilebucket))tilebucket++;\n                            }else break;\n                        }\n                    }\n                }\n\n                if(!parsing_part_references){\n                    get_map_coords(x-ox, y-oy, c,\n                        &mx, &my, &is_face1);\n                    mx -= map_l;\n                    my -= map_t;\n                    hexcollmap_tile_t *tile = &tiles[my * map_w + mx];\n\n                    hexcollmap_elem_t *elem = NULL;\n                    if(c == '+'){\n                        elem = &tile->vert[0];\n                    }else if(c == '-'){\n                        elem = &tile->edge[0];\n                    }else if(c == '/'){\n                        elem = &tile->edge[1];\n                    }else if(c == '\\\\'){\n                        elem = &tile->edge[2];\n                    }else if(c == '*'){\n                        elem = &tile->face[is_face1? 1: 0];\n                    }\n                    if(elem != NULL){\n                        /* We don't expect elem to be NULL, but it never\n                        hurts to check */\n                        elem->tile_c = tile_c;\n                        elem->z = draw_z;\n                    }\n                }\n            }else if(c == '%' || c == '?'){\n\n                /* Find next tile bucket. */\n                char c2;\n                if(tilebucket == NULL){\n                    tilebucket = &line[x+1];\n                    while(c2 = *tilebucket, c2 != '\\0' && c2 != '['){\n                        tilebucket++;}\n                    if(c2 != '['){\n                        fprintf(stderr,\n                            \"Hexcollmap line %i, char %i: \", y+1, x+1);\n                        fprintf(stderr, \"Didn't find '[' in line\\n\");\n                        return 2;}\n                    tilebucket++;\n                }else{\n                    while(c2 = *tilebucket, c2 == ' ')tilebucket++;\n                    if(c2 != ']'){\n                        fprintf(stderr,\n                            \"Hexcollmap line %i, char %i: char %td: \",\n                            y+1, x+1, tilebucket-line+1);\n                        fprintf(stderr, \"Expected ']', got '%c'\\n\", c2);\n                        return 2;}\n                    tilebucket++;\n                    while(c2 = *tilebucket, c2 == ' ')tilebucket++;\n                    if(c2 != '['){\n                        fprintf(stderr,\n                            \"Hexcollmap line %i, char %i: char %td: \",\n                            y+1, x+1, tilebucket-line+1);\n                        fprintf(stderr, \"Expected '[', got '%c'\\n\", c2);\n                        return 2;}\n                    tilebucket++;\n                }\n\n                if(c == '%'){\n                    /* Activate the bucket we found. */\n                    tilebucket_active = true;\n                }else if(c == '?'){\n                    /* Load collmaps from the bucket we found and draw them\n                    onto current collmap. */\n\n                    /* loop through all characters in tilebucket */\n                    while(1){\n                        /* Get next non-' ' character in current tile bucket. */\n                        char c2;\n                        while(c2 = *tilebucket, c2 == ' ')tilebucket++;\n\n                        if(c2 == ']')break;\n\n                        if(!isprint(c2)){\n                            fprintf(stderr,\n                                \"Hexcollmap line %i, char %i: char %td: \",\n                                y+1, x+1, tilebucket-line+1);\n                            if(c2 == '\\0'){\n                                fprintf(stderr, \"Hit end of line\\n\");}\n                            else{fprintf(stderr,\n                                \"Hit unprintable character: %x\\n\", c2);}\n                            return 2;\n                        }\n\n                        tilebucket++;\n\n                        if(parsing_part_references){\n                            int mx, my; bool is_face1;\n                            get_map_coords(x-ox, y-oy, '+',\n                                &mx, &my, NULL);\n\n                            trf_t trf = {0};\n                            trf.add[0] = mx;\n                            trf.add[1] = -my;\n                            int draw_z = 0;\n                            while(1){\n                                if(*tilebucket == '^'){\n                                    tilebucket++;\n                                    rot_t rot_add = atoi(tilebucket);\n                                    trf.rot += rot_add;\n                                    while(isdigit(*tilebucket))tilebucket++;\n                                }else if(*tilebucket == '~'){\n                                    tilebucket++;\n                                    trf.flip = !trf.flip;\n                                }else if(*tilebucket == '|'){\n                                    tilebucket++;\n                                    draw_z = atoi(tilebucket);\n                                    while(isdigit(*tilebucket))tilebucket++;\n                                }else break;\n                            }\n\n                            /* Find and draw parts with given part_c */\n                            bool found = false;\n                            for(int i = 0; i < parts_len; i++){\n                                hexcollmap_part_t *part = parts[i];\n                                if(part->part_c != c2)continue;\n                                found = true;\n                                err = hexcollmap_draw_part(collmap,\n                                    part, trf, draw_z);\n                                if(err)return err;\n                            }\n                            if(!found){\n                                fprintf(stderr,\n                                    \"Hexcollmap line %i, char %i: char %td: \"\n                                    \"part not found: %c\\n\",\n                                    y+1, x+1, tilebucket-line+1, c2);\n                                return 2;\n                            }\n\n                        }\n                    }\n                }\n\n            }else if(c == '['){\n                /* We hit a tilebucket, so no more regular tile data on\n                this line. Next plz! */\n                break;\n            }\n        }\n    }\n    }\n\n    /* OKAY */\n    return 0;\n}\n\nint hexcollmap_parse(hexcollmap_t *collmap, fus_lexer_t *lexer,\n    bool just_coll\n){\n    int err;\n\n    char default_vert_c = '0';\n    char default_edge_c = '0';\n    char default_face_c = '0';\n\n    ARRAY_DECL(hexcollmap_part_t*, parts)\n    ARRAY_INIT(parts)\n\n    if(!just_coll){\n        if(fus_lexer_got(lexer, \"parts\")){\n            err = fus_lexer_next(lexer);\n            if(err)return err;\n\n            err = fus_lexer_get(lexer, \"(\");\n            if(err)return err;\n            while(1){\n                if(fus_lexer_got(lexer, \")\"))break;\n\n                char part_c;\n                err = fus_lexer_get_chr(lexer, &part_c);\n                if(err)return err;\n\n                int type = HEXCOLLMAP_PART_TYPE_HEXCOLLMAP;\n                char *filename = NULL;\n                err = fus_lexer_get(lexer, \"(\");\n                if(err)return err;\n                {\n                    if(fus_lexer_got(lexer, \"recording\")){\n                        err = fus_lexer_next(lexer);\n                        if(err)return err;\n                        type = HEXCOLLMAP_PART_TYPE_RECORDING;\n                    }\n\n                    if(fus_lexer_got(lexer, \"empty\")){\n                        err = fus_lexer_next(lexer);\n                        if(err)return err;\n                    }else{\n                        err = fus_lexer_get_str(lexer, &filename);\n                        if(err)return err;\n                    }\n                }\n                err = fus_lexer_get(lexer, \")\");\n                if(err)return err;\n\n                ARRAY_PUSH_NEW(hexcollmap_part_t*, parts, part)\n                err = hexcollmap_part_init(part, part_c,\n                    filename, type);\n                if(err)return err;\n            }\n            err = fus_lexer_next(lexer);\n            if(err)return err;\n        }\n\n        if(fus_lexer_got(lexer, \"default_vert\")){\n            err = fus_lexer_next(lexer);\n            if(err)return err;\n            err = fus_lexer_get(lexer, \"(\");\n            if(err)return err;\n            err = fus_lexer_get_chr(lexer, &default_vert_c);\n            if(err)return err;\n            err = fus_lexer_get(lexer, \")\");\n            if(err)return err;\n        }\n\n        if(fus_lexer_got(lexer, \"default_edge\")){\n            err = fus_lexer_next(lexer);\n            if(err)return err;\n            err = fus_lexer_get(lexer, \"(\");\n            if(err)return err;\n            err = fus_lexer_get_chr(lexer, &default_edge_c);\n            if(err)return err;\n            err = fus_lexer_get(lexer, \")\");\n            if(err)return err;\n        }\n\n        if(fus_lexer_got(lexer, \"default_face\")){\n            err = fus_lexer_next(lexer);\n            if(err)return err;\n            err = fus_lexer_get(lexer, \"(\");\n            if(err)return err;\n            err = fus_lexer_get_chr(lexer, &default_face_c);\n            if(err)return err;\n            err = fus_lexer_get(lexer, \")\");\n            if(err)return err;\n        }\n\n        err = fus_lexer_get(lexer, \"collmap\");\n        if(err)return err;\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n    }\n\n    /* set up dynamic array of lines */\n    int collmap_lines_len = 0;\n    int collmap_lines_size = 8;\n    char **collmap_lines = calloc(collmap_lines_size,\n        sizeof(*collmap_lines));\n    if(collmap_lines == NULL)return 1;\n\n    /* read in lines */\n    while(1){\n        if(fus_lexer_got(lexer, \")\"))break;\n\n        /* resize array of lines, if necessary */\n        if(collmap_lines_len >= collmap_lines_size){\n            int new_lines_size = collmap_lines_size * 2;\n            char **new_lines = realloc(collmap_lines,\n                sizeof(*collmap_lines) * new_lines_size);\n            if(new_lines == NULL)return 1;\n            for(int i = collmap_lines_size;\n                i < new_lines_size; i++){\n                    new_lines[i] = NULL;}\n            collmap_lines_size = new_lines_size;\n            collmap_lines = new_lines;\n        }\n\n        /* get new line from lexer */\n        collmap_lines_len++;\n        err = fus_lexer_get_str(lexer,\n            &collmap_lines[collmap_lines_len - 1]);\n        if(err)return err;\n    }\n\n    /* parse lines */\n    err = hexcollmap_parse_lines(collmap,\n        collmap_lines, collmap_lines_len, parts, parts_len,\n        default_vert_c, default_edge_c, default_face_c);\n    if(err){\n        fus_lexer_err_info(lexer);\n        fprintf(stderr, \"Couldn't parse hexcollmap lines\\n\");\n        return err;}\n\n    if(!just_coll){\n        err = fus_lexer_get(lexer, \")\");\n        if(err)return err;\n    }\n\n    /* free lines and dynamic array thereof */\n    for(int i = 0; i < collmap_lines_len; i++){\n        free(collmap_lines[i]);\n        collmap_lines[i] = NULL;}\n    free(collmap_lines);\n\n\n    ARRAY_FREE_PTR(hexcollmap_part_t*, parts, hexcollmap_part_cleanup)\n\n    return 0;\n}\n\nint hexcollmap_load(hexcollmap_t *collmap, const char *filename){\n    int err;\n    fus_lexer_t lexer;\n\n    char *text = load_file(filename);\n    if(text == NULL)return 1;\n\n    err = fus_lexer_init(&lexer, text, filename);\n    if(err)return err;\n\n    err = hexcollmap_parse(collmap, &lexer, false);\n    if(err)return err;\n\n    free(text);\n    return 0;\n}\n\nvoid hexcollmap_normalize_vert(trf_t *index){\n    index->rot = 0;\n    index->flip = false;\n}\n\nvoid hexcollmap_normalize_edge(trf_t *index){\n    index->flip = false;\n    if(index->rot == 3){\n        index->rot = 0; index->add[0]--;\n    }else if(index->rot == 4){\n        index->rot = 1; index->add[0]--; index->add[1]++;\n    }else if(index->rot == 5){\n        index->rot = 2; index->add[1]++;\n    }\n}\n\nvoid hexcollmap_normalize_face(trf_t *index){\n    if(index->flip){\n        index->flip = false;\n        index->rot = rot_contain(6, index->rot - 1);\n    }\n    if(index->rot == 2){\n        index->rot = 0; index->add[0]--;\n    }else if(index->rot == 3){\n        index->rot = 1; index->add[0]--; index->add[1]++;\n    }else if(index->rot == 4){\n        index->rot = 0; index->add[0]--; index->add[1]++;\n    }else if(index->rot == 5){\n        index->rot = 1; index->add[1]++;\n    }\n}\n\nhexcollmap_tile_t *hexcollmap_get_tile(hexcollmap_t *collmap, trf_t *index){\n    int x = collmap->ox + index->add[0];\n    int y = collmap->oy + index->add[1];\n    if(x < 0 || x >= collmap->w || y < 0 || y >= collmap->h)return NULL;\n    return &collmap->tiles[y * collmap->w + x];\n}\n\nhexcollmap_elem_t *hexcollmap_get_vert(hexcollmap_t *collmap, trf_t *index){\n    hexcollmap_tile_t *tile = hexcollmap_get_tile(collmap, index);\n    if(tile == NULL)return NULL;\n    return &tile->vert[index->rot];\n}\n\nhexcollmap_elem_t *hexcollmap_get_edge(hexcollmap_t *collmap, trf_t *index){\n    hexcollmap_tile_t *tile = hexcollmap_get_tile(collmap, index);\n    if(tile == NULL)return NULL;\n    return &tile->edge[index->rot];\n}\n\nhexcollmap_elem_t *hexcollmap_get_face(hexcollmap_t *collmap, trf_t *index){\n    hexcollmap_tile_t *tile = hexcollmap_get_tile(collmap, index);\n    if(tile == NULL)return NULL;\n    return &tile->face[index->rot];\n}\n\nbool hexcollmap_elem_is_visible(hexcollmap_elem_t *elem){\n    if(elem == NULL)return false;\n    char tile_c = elem->tile_c;\n    return tile_c != ' ' && tile_c != 'x';\n}\n\nbool hexcollmap_elem_is_solid(hexcollmap_elem_t *elem){\n    if(elem == NULL)return false;\n    char tile_c = elem->tile_c;\n    return strchr(\" xSDw\", tile_c) == NULL;\n}\n\nstatic int hexcollmap_collide_elem(hexcollmap_t *collmap1, bool all,\n    vecspace_t *space, int x, int y, trf_t *trf,\n    hexcollmap_elem_t *elems2, int rot,\n    void (*normalize_elem)(trf_t *index),\n    hexcollmap_elem_t *(get_elem)(\n        hexcollmap_t *collmap, trf_t *index)\n){\n    /* Returns true (1) or false (0), or 2 if caller should continue\n    checking for a collision. */\n\n    for(int r2 = 0; r2 < rot; r2++){\n        if(!hexcollmap_elem_is_solid(&elems2[r2]))continue;\n\n        trf_t index;\n        hexspace_set(index.add, x, y);\n        index.rot = r2;\n        index.flip = false;\n\n        /* And now, because we were fools and defined */\n        /* the tile coords such that their Y is flipped */\n        /* compared to vecspaces, we need to flip that Y */\n        /* before calling trf_apply and then flip it back */\n        /* again: */\n        index.add[1] = -index.add[1];\n        trf_apply(space, &index, trf);\n        index.add[1] = -index.add[1];\n        normalize_elem(&index);\n\n        bool collide = false;\n        hexcollmap_elem_t *elem = get_elem(collmap1, &index);\n        collide = hexcollmap_elem_is_solid(elem);\n\n        if((all && !collide) || (!all && collide))return collide;\n    }\n    return 2; /* Caller should keep looking for a collision */\n}\n\nbool hexcollmap_collide(\n    hexcollmap_t *collmap1, trf_t *trf1,\n    hexcollmap_t *collmap2, trf_t *trf2,\n    vecspace_t *space, bool all\n){\n    int ox2 = collmap2->ox;\n    int oy2 = collmap2->oy;\n    int w2 = collmap2->w;\n    int h2 = collmap2->h;\n\n    //return false;\n\n    /* NOTE: for tile coords (ox, oy, x, y, w, h),\n    Y is reversed (down is positive, up is negative) */\n\n    trf_t trf;\n    trf_cpy(space, &trf, trf2);\n    trf_apply_inv(space, &trf, trf1);\n\n    for(int y2 = 0; y2 < h2; y2++){\n        for(int x2 = 0; x2 < w2; x2++){\n            hexcollmap_tile_t *tile2 = &collmap2->tiles[y2 * w2 + x2];\n\n            int collide;\n            int x = x2 - ox2;\n            int y = y2 - oy2;\n            collide = hexcollmap_collide_elem(collmap1, all,\n                space, x, y, &trf,\n                tile2->vert, 1,\n                hexcollmap_normalize_vert,\n                hexcollmap_get_vert);\n            if(collide != 2)return collide;\n            collide = hexcollmap_collide_elem(collmap1, all,\n                space, x, y, &trf,\n                tile2->edge, 3,\n                hexcollmap_normalize_edge,\n                hexcollmap_get_edge);\n            if(collide != 2)return collide;\n            collide = hexcollmap_collide_elem(collmap1, all,\n                space, x, y, &trf,\n                tile2->face, 2,\n                hexcollmap_normalize_face,\n                hexcollmap_get_face);\n            if(collide != 2)return collide;\n        }\n    }\n    if(all)return true;\n    else return false;\n}\n\n","\nstatic int _min(int x, int y){\n    return x < y? x: y;\n}\n\nstatic int _max(int x, int y){\n    return x > y? x: y;\n}\n\nstatic int _div(int x, int y){\n    /* y is assumed to be non-negative */\n    if(x < 0)return (x - (y-1)) / y;\n    return x / y;\n}\n\nstatic int _rem(int x, int y){\n    /* y is assumed to be non-negative */\n    if(x < 0)return (y - 1) + (x - (y-1)) % y;\n    return x % y;\n}\n","\n#include <stdlib.h>\n#include <stdio.h>\n#include <stdbool.h>\n#include <string.h>\n\n#include <SDL2/SDL.h>\n\n#include \"util.h\"\n\nint int_min(int x, int y){\n    return x < y? x: y;\n}\n\nint int_max(int x, int y){\n    return x > y? x: y;\n}\n\nint linear_interpolation(int x0, int x1, int t, int t_max){\n    int diff = x1 - x0;\n    return x0 + diff * t / t_max;\n}\n\nvoid interpolate_color(SDL_Color *c, Uint8 r, Uint8 g, Uint8 b,\n    int t, int t_max\n){\n    c->r = linear_interpolation(c->r, r, t, t_max);\n    c->g = linear_interpolation(c->g, g, t, t_max);\n    c->b = linear_interpolation(c->b, b, t, t_max);\n}\n\nint strlen_of_int(int i){\n    /* Basically log(i), except that strlen of \"0\" is 1, and strlen of a\n    negative number includes a space for the '-' */\n    if(i == 0)return 1;\n    if(i < 0)return strlen_of_int(-i) + 1;\n    int len = 0;\n    while(i != 0){\n        len++;\n    i /= 10;\n    }\n    return len;\n}\n\nvoid strncpy_of_int(char *s, int i, int i_len){\n    /* i_len should be strlen_of_int(i) */\n    if(i == 0){\n        *s = '0';\n        return;}\n    if(i < 0){\n        *s = '-';\n        strncpy_of_int(s+1, -i, i_len-1);\n        return;}\n    while(i_len > 0){\n        s[i_len - 1] = '0' + i % 10;\n        i /= 10;\n        i_len--;\n    }\n}\n\nint getln(char buf[], int buf_len){\n    if(!fgets(buf, buf_len, stdin)){\n        perror(\"fgets failed\");\n        return 1;\n    }\n    buf[strcspn(buf, \"\\n\")] = '\\0';\n    return 0;\n}\n\nchar *load_file(const char *filename){\n    FILE *f = fopen(filename, \"r\");\n    long f_size;\n    char *f_buffer;\n    size_t n_read_bytes;\n    if(f == NULL){\n        fprintf(stderr, \"Could not open file: %s\\n\", filename);\n        return NULL;\n    }\n\n    fseek(f, 0, SEEK_END);\n    f_size = ftell(f);\n    fseek(f, 0, SEEK_SET);\n\n    f_buffer = calloc(f_size + 1, 1);\n    if(f_buffer == NULL){\n        fprintf(stderr, \"Could not allocate buffer for file: %s (%li bytes)\\n\", filename, f_size);\n        fclose(f);\n        return NULL;\n    }\n    n_read_bytes = fread(f_buffer, 1, f_size, f);\n    fclose(f);\n    return f_buffer;\n}\n\nbool streq(const char *s1, const char *s2){\n    if(s1 == NULL || s2 == NULL)return s1 == s2;\n    return strcmp(s1, s2) == 0;\n}\n\nchar *strdup(const char *s1){\n    char *s2 = malloc(strlen(s1) + 1);\n    if(s2 == NULL)return NULL;\n    strcpy(s2, s1);\n    return s2;\n}\n\nvoid get_spaces(char *spaces, int max_spaces, int n_spaces){\n    if(n_spaces > max_spaces){\n        fprintf(stderr, \"Can't handle %i spaces - max %i\\n\",\n            n_spaces, max_spaces);\n        n_spaces = max_spaces;\n    }\n    for(int i = 0; i < n_spaces; i++)spaces[i] = ' ';\n    spaces[n_spaces] = '\\0';\n}\n\nvoid palette_printf(SDL_Palette *pal){\n    for(int i = 0; i < pal->ncolors; i++){\n        SDL_Color *c = &pal->colors[i];\n        printf(\"%i: (%i, %i, %i, %i)\\n\", i, c->r, c->g, c->b, c->a);\n    }\n}\n\nSDL_Surface *surface8_create(int w, int h,\n    bool use_rle, bool use_colorkey, SDL_Palette *pal\n){\n    SDL_Surface *surface = SDL_CreateRGBSurface(\n        0, w, h, 8, 0, 0, 0, 0);\n    RET_NULL_IF_SDL_NULL(surface);\n\n    if(use_rle){\n        RET_NULL_IF_SDL_NZ(use_rle\n            && SDL_SetSurfaceRLE(surface, 1));}\n\n    if(use_colorkey){\n        RET_NULL_IF_SDL_NZ(SDL_SetColorKey(surface, SDL_TRUE, 0));}\n    //if(use_colorkey){\n    //    RET_NULL_IF_SDL_NZ(SDL_SetColorKey(surface, SDL_TRUE,\n    //        use_rle? SDL_RLEACCEL: 0));}\n\n    RET_NULL_IF_SDL_NZ(SDL_SetSurfacePalette(surface, pal));\n    return surface;\n}\n\nSDL_Surface *surface32_create(int w, int h,\n    bool use_rle, bool use_colorkey\n){\n    SDL_Surface *surface = SDL_CreateRGBSurface(\n        0, w, h, 32, 0, 0, 0, 0);\n    RET_NULL_IF_SDL_NULL(surface);\n    if(use_rle){\n        RET_NULL_IF_SDL_NZ(SDL_SetSurfaceRLE(surface, 1));}\n    if(use_colorkey){\n        RET_NULL_IF_SDL_NZ(SDL_SetColorKey(surface, SDL_TRUE, 0));}\n    return surface;\n}\n\nUint8 *surface8_get_pixel_ptr(SDL_Surface *surface, int x, int y){\n    if(x < 0 || y < 0 || x >= surface->w || y >= surface->h){\n        fprintf(stderr,\n            \"%s: out of bounds: x=%i, y=%i, surface->w=%i, surface->h=%i\",\n            __func__, x, y, surface->w, surface->h);\n        return (Uint8 *)surface->pixels;\n    }\n    return (Uint8 *)surface->pixels + y*surface->pitch + x;\n}\n\nUint32 *surface32_get_pixel_ptr(SDL_Surface *surface, int x, int y){\n    if(x < 0 || y < 0 || x >= surface->w || y >= surface->h){\n        fprintf(stderr,\n            \"%s: out of bounds: x=%i, y=%i, surface->w=%i, surface->h=%i\",\n            __func__, x, y, surface->w, surface->h);\n        return (Uint32 *)surface->pixels;\n    }\n    return (Uint32 *)(\n        (Uint8 *)surface->pixels + y*surface->pitch + x*(32/8)\n    );\n}\n","\n\n#include \"lexer.h\"\n\n\nstatic size_t fus_strnlen(const char *s, size_t maxlen){\n    size_t len = 0;\n    while(len < maxlen && s[len] != '\\0')len++;\n    return len;\n}\n\nstatic char *fus_strndup(const char *s1, size_t len){\n    size_t s_len = fus_strnlen(s1, len);\n    char *s2 = malloc(s_len + 1);\n    if(s2 == NULL)return NULL;\n    strncpy(s2, s1, len);\n    s2[s_len] = '\\0';\n    return s2;\n}\n\n\n\nconst int INITIAL_INDENTS_SIZE = 32;\n\nstatic int fus_lexer_get_indent(fus_lexer_t *lexer);\n\nvoid fus_lexer_cleanup(fus_lexer_t *lexer){\n    free(lexer->indents);\n}\n\nint fus_lexer_init(fus_lexer_t *lexer, const char *text,\n    const char *filename\n){\n    int err;\n\n    lexer->debug = false;\n\n    int indents_size = INITIAL_INDENTS_SIZE;\n    int *indents = calloc(indents_size, sizeof(indents));\n    if(indents == NULL)return 1;\n\n    lexer->filename = filename;\n    lexer->text = text;\n    lexer->text_len = strlen(text);\n    lexer->token = NULL;\n    lexer->token_len = 0;\n    lexer->token_type = FUS_LEXER_TOKEN_DONE;\n    lexer->pos = 0;\n    lexer->row = 0;\n    lexer->col = 0;\n    lexer->indent = 0;\n    lexer->indents_size = indents_size;\n    lexer->n_indents = 0;\n    lexer->indents = indents;\n    lexer->returning_indents = 0;\n\n    err = fus_lexer_get_indent(lexer);\n    if(err)return err;\n    err = fus_lexer_next(lexer);\n    if(err)return err;\n    return 0;\n}\n\nint fus_lexer_copy(fus_lexer_t *lexer, fus_lexer_t *lexer2){\n    lexer->debug = lexer2->debug;\n    lexer->filename = lexer2->filename;\n    lexer->text = lexer2->text;\n    lexer->text_len = lexer2->text_len;\n    lexer->token = lexer2->token;\n    lexer->token_len = lexer2->token_len;\n    lexer->token_type = lexer2->token_type;\n    lexer->pos = lexer2->pos;\n    lexer->row = lexer2->row;\n    lexer->col = lexer2->col;\n\n    int indents_size = lexer2->indents_size;\n    int *new_indents = malloc(sizeof(*new_indents) * indents_size);\n    if(new_indents == NULL)return 1;\n    for(int i = 0; i < indents_size; i++){\n        new_indents[i] = lexer2->indents[i];}\n\n    lexer->indent = lexer2->indent;\n    lexer->indents_size = lexer2->indents_size;\n    lexer->n_indents = lexer2->n_indents;\n    lexer->indents = new_indents;\n    lexer->returning_indents = lexer2->returning_indents;\n\n    return 0;\n}\n\nvoid fus_lexer_dump(fus_lexer_t *lexer, FILE *f){\n    fprintf(f, \"lexer: %p\\n\", lexer);\n    if(lexer == NULL)return;\n    fprintf(f, \"  text = ...\\n\");\n    fprintf(f, \"  pos = %i\\n\", lexer->pos);\n    fprintf(f, \"  row = %i\\n\", lexer->row);\n    fprintf(f, \"  col = %i\\n\", lexer->col);\n    fprintf(f, \"  indent = %i\\n\", lexer->indent);\n    fprintf(f, \"  indents_size = %i\\n\", lexer->indents_size);\n    fprintf(f, \"  n_indents = %i\\n\", lexer->n_indents);\n    fprintf(f, \"  indents:\\n\");\n    for(int i = 0; i < lexer->n_indents; i++){\n        fprintf(f, \"    %i\\n\", lexer->indents[i]);\n    }\n    fprintf(f, \"  returning_indents = %i\\n\", lexer->returning_indents);\n}\n\nvoid fus_lexer_info(fus_lexer_t *lexer, FILE *f){\n    fprintf(f, \"%s: row %i: col %i: \",\n        lexer->filename,\n        lexer->row + 1,\n        lexer->col - lexer->token_len + 1);\n}\n\nvoid fus_lexer_err_info(fus_lexer_t *lexer){\n    fprintf(stderr, \"Lexer error: \");\n    fus_lexer_info(lexer, stderr);\n}\n\nint fus_lexer_get_pos(fus_lexer_t *lexer){\n    /* \"public getter\" */\n    return lexer->pos;\n}\n\nvoid fus_lexer_set_pos(fus_lexer_t *lexer, int pos){\n    /* \"public setter\" */\n    lexer->pos = pos;\n}\n\nstatic void fus_lexer_start_token(fus_lexer_t *lexer){\n    lexer->token = lexer->text + lexer->pos;\n    lexer->token_len = 0;\n}\n\nstatic void fus_lexer_end_token(fus_lexer_t *lexer){\n    int token_startpos = lexer->token - lexer->text;\n    lexer->token_len = lexer->pos - token_startpos;\n}\n\nstatic void fus_lexer_set_token(\n    fus_lexer_t *lexer,\n    const char *token\n){\n    lexer->token = token;\n    lexer->token_len = strlen(token);\n}\n\nstatic int fus_lexer_push_indent(\n    fus_lexer_t *lexer,\n    int indent\n){\n    if(lexer->n_indents >= lexer->indents_size){\n        int indents_size = lexer->indents_size;\n        int new_indents_size = indents_size * 2;\n        int *new_indents = realloc(lexer->indents,\n            new_indents_size * sizeof(new_indents));\n        if(new_indents == NULL)return 1;\n        memset(new_indents + indents_size, 0, indents_size);\n        lexer->indents = new_indents;\n        lexer->indents_size = new_indents_size;\n    }\n\n    lexer->n_indents++;\n    lexer->indents[lexer->n_indents-1] = indent;\n    return 0;\n}\n\nstatic int fus_lexer_pop_indent(fus_lexer_t *lexer){\n    if(lexer->n_indents == 0){\n        fus_lexer_err_info(lexer); fprintf(stderr,\n            \"Tried to pop an indent, but indents stack is empty\\n\");\n        return 2;\n    }\n    lexer->n_indents--;\n    return 0;\n}\n\n\nstatic char fus_lexer_peek(fus_lexer_t *lexer){\n    return lexer->text[lexer->pos + 1];\n}\n\nstatic char fus_lexer_eat(fus_lexer_t *lexer){\n    char c = lexer->text[lexer->pos];\n    lexer->pos++;\n    if(c == '\\n'){\n        lexer->row++;\n        lexer->col = 0;\n    }else{\n        lexer->col++;\n    }\n    return c;\n}\n\nstatic int fus_lexer_get_indent(fus_lexer_t *lexer){\n    int indent = 0;\n    while(lexer->pos < lexer->text_len){\n        char c = lexer->text[lexer->pos];\n        if(c == ' '){\n            indent++;\n            fus_lexer_eat(lexer);\n        }else if(c == '\\n'){\n            /* blank lines don't count towards indentation --\n            just reset the indentation and restart on next line */\n            indent = 0;\n            fus_lexer_eat(lexer);\n        }else if(c != '\\0' && isspace(c)){\n            fus_lexer_err_info(lexer); fprintf(stderr,\n                \"Indented with whitespace other than ' ' \"\n                \"(#32): #%i\\n\", (int)c);\n            return 2;\n        }else{\n            break;\n        }\n    }\n    lexer->indent = indent;\n    return 0;\n}\n\nstatic void fus_lexer_eat_whitespace(fus_lexer_t *lexer){\n    while(lexer->pos < lexer->text_len){\n        char c = lexer->text[lexer->pos];\n        if(c == '\\0' || isgraph(c))break;\n        fus_lexer_eat(lexer);\n    }\n}\n\nstatic void fus_lexer_eat_comment(fus_lexer_t *lexer){\n    /* eat leading '#' */\n    fus_lexer_eat(lexer);\n\n    while(lexer->pos < lexer->text_len){\n        char c = lexer->text[lexer->pos];\n        if(c == '\\n')break;\n        fus_lexer_eat(lexer);\n    }\n}\n\nstatic void fus_lexer_parse_sym(fus_lexer_t *lexer){\n    fus_lexer_start_token(lexer);\n    while(lexer->pos < lexer->text_len){\n        char c = lexer->text[lexer->pos];\n        if(c != '_' && !isalnum(c))break;\n        fus_lexer_eat(lexer);\n    }\n    fus_lexer_end_token(lexer);\n}\n\nstatic void fus_lexer_parse_int(fus_lexer_t *lexer){\n    fus_lexer_start_token(lexer);\n\n    /* eat leading '-' if present */\n    if(lexer->text[lexer->pos] == '-')fus_lexer_eat(lexer);\n\n    while(lexer->pos < lexer->text_len){\n        char c = lexer->text[lexer->pos];\n        if(!isdigit(c))break;\n        fus_lexer_eat(lexer);\n    }\n    fus_lexer_end_token(lexer);\n}\n\nstatic void fus_lexer_parse_op(fus_lexer_t *lexer){\n    fus_lexer_start_token(lexer);\n    while(lexer->pos < lexer->text_len){\n        char c = lexer->text[lexer->pos];\n        if(c == '(' || c == ')' || c == ':'\n            || !isgraph(c) || isalnum(c))break;\n        fus_lexer_eat(lexer);\n    }\n    fus_lexer_end_token(lexer);\n}\n\nstatic int fus_lexer_parse_str(fus_lexer_t *lexer){\n    fus_lexer_start_token(lexer);\n\n    /* Include leading '\"' */\n    fus_lexer_eat(lexer);\n\n    while(1){\n        char c = lexer->text[lexer->pos];\n        if(c == '\\0'){\n            goto err_eof;\n        }else if(c == '\\n'){\n            goto err_eol;\n        }else if(c == '\"'){\n            fus_lexer_eat(lexer);\n            break;\n        }else if(c == '\\\\'){\n            fus_lexer_eat(lexer);\n            char c = lexer->text[lexer->pos];\n            if(c == '\\0'){\n                goto err_eof;\n            }else if(c == '\\n'){\n                goto err_eol;\n            }\n        }\n        fus_lexer_eat(lexer);\n    }\n    fus_lexer_end_token(lexer);\n    return 0;\nerr_eol:\n    fus_lexer_err_info(lexer); fprintf(stderr,\n        \"Reached newline while parsing str\\n\");\n    return 2;\nerr_eof:\n    fus_lexer_err_info(lexer); fprintf(stderr,\n        \"Reached end of text while parsing str\\n\");\n    return 2;\n}\n\nstatic int fus_lexer_parse_blockstr(fus_lexer_t *lexer){\n    fus_lexer_start_token(lexer);\n\n    /* Include leading \";;\" */\n    fus_lexer_eat(lexer);\n    fus_lexer_eat(lexer);\n\n    while(lexer->pos < lexer->text_len){\n        char c = lexer->text[lexer->pos];\n        if(c == '\\0'){\n            break;\n        }else if(c == '\\n'){\n            break;\n        }\n        fus_lexer_eat(lexer);\n    }\n    fus_lexer_end_token(lexer);\n    return 0;\n}\n\nint fus_lexer_next(fus_lexer_t *lexer){\n    int err;\n    while(1){\n        /* return \"(\" or \")\" token based on indents? */\n        if(lexer->returning_indents != 0)break;\n\n        char c = lexer->text[lexer->pos];\n        if(c == '\\0' || c == '\\n'){\n            if(c == '\\n')fus_lexer_eat(lexer);\n\n            err = fus_lexer_get_indent(lexer);\n            if(err)return err;\n            int new_indent = lexer->indent;\n            while(lexer->n_indents > 0){\n                int indent = lexer->indents[lexer->n_indents-1];\n                if(new_indent <= indent){\n                    err = fus_lexer_pop_indent(lexer);\n                    if(err)return err;\n                    lexer->returning_indents--;\n                }else{\n                    break;\n                }\n            }\n\n            if(c == '\\0'){\n                /* Reached end of file; report with NULL token */\n                lexer->token = NULL;\n                lexer->token_len = 0;\n                lexer->token_type = FUS_LEXER_TOKEN_DONE;\n                break;\n            }\n        }else if(isspace(c)){\n            fus_lexer_eat_whitespace(lexer);\n        }else if(c == ':'){\n            fus_lexer_eat(lexer);\n            lexer->returning_indents++;\n            fus_lexer_push_indent(lexer, lexer->indent);\n            break;\n        }else if(c == '(' || c == ')'){\n            fus_lexer_start_token(lexer);\n            fus_lexer_eat(lexer);\n            fus_lexer_end_token(lexer);\n            lexer->token_type = c == '('? FUS_LEXER_TOKEN_OPEN: FUS_LEXER_TOKEN_CLOSE;\n            break;\n        }else if(c == '_' || isalpha(c)){\n            fus_lexer_parse_sym(lexer);\n            lexer->token_type = FUS_LEXER_TOKEN_SYM;\n            break;\n        }else if(isdigit(c) || (\n            c == '-' && isdigit(fus_lexer_peek(lexer))\n        )){\n            fus_lexer_parse_int(lexer);\n            lexer->token_type = FUS_LEXER_TOKEN_INT;\n            break;\n        }else if(c == '#'){\n            fus_lexer_eat_comment(lexer);\n        }else if(c == '\"'){\n            err = fus_lexer_parse_str(lexer);\n            if(err)return err;\n            lexer->token_type = FUS_LEXER_TOKEN_STR;\n            break;\n        }else if(c == ';' && fus_lexer_peek(lexer) == ';'){\n            err = fus_lexer_parse_blockstr(lexer);\n            if(err)return err;\n            lexer->token_type = FUS_LEXER_TOKEN_BLOCKSTR;\n            break;\n        }else{\n            fus_lexer_parse_op(lexer);\n            lexer->token_type = FUS_LEXER_TOKEN_OP;\n            break;\n        }\n    }\n\n    if(lexer->returning_indents > 0){\n        lexer->token_type = FUS_LEXER_TOKEN_OPEN;\n        fus_lexer_set_token(lexer, \"(\");\n        lexer->returning_indents--;\n    }\n    if(lexer->returning_indents < 0){\n        lexer->token_type = FUS_LEXER_TOKEN_CLOSE;\n        fus_lexer_set_token(lexer, \")\");\n        lexer->returning_indents++;\n    }\n\n    return 0;\n}\n\nbool fus_lexer_done(fus_lexer_t *lexer){\n    return lexer->token == NULL;\n}\n\nbool fus_lexer_got(fus_lexer_t *lexer, const char *text){\n    if(lexer->token == NULL || text == NULL){\n        return lexer->token == text;\n    }\n    return\n        lexer->token_len == strlen(text) &&\n        strncmp(lexer->token, text, lexer->token_len) == 0\n    ;\n}\n\nbool fus_lexer_got_name(fus_lexer_t *lexer){\n    return lexer->token_type == FUS_LEXER_TOKEN_SYM;\n}\n\nbool fus_lexer_got_str(fus_lexer_t *lexer){\n    return\n        lexer->token_type == FUS_LEXER_TOKEN_STR ||\n        lexer->token_type == FUS_LEXER_TOKEN_BLOCKSTR;\n}\n\nbool fus_lexer_got_int(fus_lexer_t *lexer){\n    return lexer->token_type == FUS_LEXER_TOKEN_INT;\n}\n\nvoid fus_lexer_show(fus_lexer_t *lexer, FILE *f){\n    if(lexer->token == NULL){\n        fprintf(f, \"end of input\");\n    }else{\n        fprintf(f, \"\\\"%.*s\\\"\", lexer->token_len, lexer->token);\n    }\n}\n\nint fus_lexer_get(fus_lexer_t *lexer, const char *text){\n    if(!fus_lexer_got(lexer, text)){\n        fus_lexer_err_info(lexer); fprintf(stderr,\n            \"Expected \\\"%s\\\", but got: \", text);\n        fus_lexer_show(lexer, stderr); fprintf(stderr, \"\\n\");\n        return 2;\n    }\n    return fus_lexer_next(lexer);\n}\n\nint fus_lexer_get_name(fus_lexer_t *lexer, char **name){\n    if(!fus_lexer_got_name(lexer)){\n        fus_lexer_err_info(lexer); fprintf(stderr,\n            \"Expected name, but got: \");\n        fus_lexer_show(lexer, stderr); fprintf(stderr, \"\\n\");\n        return 2;\n    }\n    *name = fus_strndup(lexer->token, lexer->token_len);\n    if(*name == NULL)return 1;\n    return fus_lexer_next(lexer);\n}\n\nint fus_lexer_get_str(fus_lexer_t *lexer, char **s){\n    if(lexer->token_type == FUS_LEXER_TOKEN_STR){\n        const char *token = lexer->token;\n        int token_len = lexer->token_len;\n\n        /* Length of s is length of token without the surrounding\n        '\"' characters */\n        int s_len = token_len - 2;\n\n        char *ss0 = malloc(s_len + 1);\n        if(ss0 == NULL)return 1;\n        char *ss = ss0;\n\n        for(int i = 1; i < token_len - 1; i++){\n            char c = token[i];\n            if(c == '\\\\'){\n                i++;\n                c = token[i];\n            }\n            *ss = c;\n            ss++;\n        }\n\n        *ss = '\\0';\n        *s = ss0;\n    }else if(lexer->token_type == FUS_LEXER_TOKEN_BLOCKSTR){\n        const char *token = lexer->token;\n        int token_len = lexer->token_len;\n\n        /* Length of s is length of token without the leading \";;\" */\n        int s_len = token_len - 2;\n\n        char *ss = fus_strndup(token+2, s_len);\n        if(ss == NULL)return 1;\n\n        *s = ss;\n    }else{\n        fus_lexer_err_info(lexer); fprintf(stderr,\n            \"Expected str, but got: \");\n        fus_lexer_show(lexer, stderr); fprintf(stderr, \"\\n\");\n        return 2;\n    }\n    return fus_lexer_next(lexer);\n}\n\nint fus_lexer_get_chr(fus_lexer_t *lexer, char *c){\n    int err;\n    char *s;\n    err = fus_lexer_get_str(lexer, &s);\n    if(err)return err;\n    if(strlen(s) != 1){\n        fus_lexer_err_info(lexer); fprintf(stderr,\n            \"Expected chr, but got: \");\n        fus_lexer_show(lexer, stderr); fprintf(stderr, \"\\n\");\n        return 2;\n    }\n    *c = s[0];\n    free(s);\n    return 0;\n}\n\nint fus_lexer_get_int(fus_lexer_t *lexer, int *i){\n    if(!fus_lexer_got_int(lexer)){\n        fus_lexer_err_info(lexer); fprintf(stderr,\n            \"Expected int, but got: \");\n        fus_lexer_show(lexer, stderr); fprintf(stderr, \"\\n\");\n        return 2;\n    }\n    *i = atoi(lexer->token);\n    return fus_lexer_next(lexer);\n}\n\nstatic int _fus_lexer_get_bool(fus_lexer_t *lexer, bool *b,\n    const char *t, const char *f\n){\n    if(fus_lexer_got(lexer, t)){\n        *b = true;\n    }else if(fus_lexer_got(lexer, f)){\n        *b = false;\n    }else{\n        fus_lexer_err_info(lexer); fprintf(stderr,\n            \"Expected bool (%s or %s), but got: \", t, f);\n        fus_lexer_show(lexer, stderr); fprintf(stderr, \"\\n\");\n        return 2;\n    }\n    return fus_lexer_next(lexer);\n}\n\nint fus_lexer_get_bool(fus_lexer_t *lexer, bool *b){\n    return _fus_lexer_get_bool(lexer, b, \"t\", \"f\");\n}\n\nint fus_lexer_get_yesno(fus_lexer_t *lexer, bool *b){\n    return _fus_lexer_get_bool(lexer, b, \"y\", \"n\");\n}\n\nint fus_lexer_get_int_fancy(fus_lexer_t *lexer, int *i_ptr){\n    int err;\n    if(fus_lexer_got_int(lexer)){\n        err = fus_lexer_get_int(lexer, i_ptr);\n        if(err)goto err;\n    }else{\n        int i = 0;\n        err = fus_lexer_get(lexer, \"eval\");\n        if(err)goto err;\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)goto err;\n        while(1){\n            if(fus_lexer_got(lexer, \")\"))break;\n\n            bool neg = false;\n            if(fus_lexer_got(lexer, \"+\")){\n                err = fus_lexer_next(lexer);\n                if(err)return err;\n                neg = false;\n            }else if(fus_lexer_got(lexer, \"-\")){\n                err = fus_lexer_next(lexer);\n                if(err)return err;\n                neg = true;\n            }\n\n            int add;\n            err = fus_lexer_get_int(lexer, &add);\n            if(err)goto err;\n\n            if(fus_lexer_got(lexer, \"*\")){\n                err = fus_lexer_next(lexer);\n                if(err)return err;\n                int mul;\n                err = fus_lexer_get_int(lexer, &mul);\n                if(err)goto err;\n                add *= mul;\n            }\n\n            i += neg? -add: add;\n        }\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        *i_ptr = i;\n    }\n    return 0;\nerr:\n    fus_lexer_err_info(lexer);\n    fprintf(stderr, \"(...while parsing fancy int)\\n\");\n    return err;\n}\n\nint fus_lexer_get_int_range(fus_lexer_t *lexer, int maxlen,\n    int *i_ptr, int *len_ptr\n){\n    int err;\n\n    int i = 0;\n    int len = 1;\n\n    if(fus_lexer_got(lexer, \"*\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        len = maxlen;\n    }else{\n        err = fus_lexer_get_int(lexer, &i);\n        if(err)return err;\n        if(i < 0 || i > maxlen){\n            fus_lexer_err_info(lexer);\n            fprintf(stderr,\n                \"Expected int within 0..%i, got: %.*s\\n\",\n                maxlen, lexer->token_len, lexer->token);\n            return 2;}\n\n        if(fus_lexer_got(lexer, \",\")){\n            err = fus_lexer_next(lexer);\n            if(err)return err;\n            err = fus_lexer_get_int(lexer, &len);\n            if(err)return err;\n            if(len < 0 || i + len > maxlen){\n                fus_lexer_err_info(lexer);\n                fprintf(stderr,\n                    \"Expected int within 0..%i, got: %.*s\\n\",\n                    maxlen-i, lexer->token_len, lexer->token);\n                return 2;}\n        }\n    }\n\n    *i_ptr = i;\n    *len_ptr = len;\n    return 0;\n}\n\nint fus_lexer_get_attr_int(fus_lexer_t *lexer, const char *attr, int *i,\n    bool optional\n){\n    int err;\n    if(fus_lexer_got(lexer, attr)){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n        err = fus_lexer_get_int(lexer, i);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \")\");\n        if(err)return err;\n    }else if(!optional){\n        fus_lexer_err_info(lexer); fprintf(stderr,\n            \"Expected int attribute \\\"%s\\\", but got: \", attr);\n        fus_lexer_show(lexer, stderr); fprintf(stderr, \"\\n\");\n        return 2;\n    }\n    return 0;\n}\n\nstatic int _fus_lexer_get_attr_bool(fus_lexer_t *lexer, const char *attr, bool *b,\n    bool optional, const char *t, const char *f\n){\n    int err;\n    if(fus_lexer_got(lexer, attr)){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n        err = fus_lexer_get_bool(lexer, b);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \")\");\n        if(err)return err;\n    }else if(!optional){\n        fus_lexer_err_info(lexer); fprintf(stderr,\n            \"Expected bool attribute \\\"%s\\\", but got: \", attr);\n        fus_lexer_show(lexer, stderr); fprintf(stderr, \"\\n\");\n        return 2;\n    }\n    return 0;\n}\n\nint fus_lexer_get_attr_yesno(fus_lexer_t *lexer, const char *attr, bool *b,\n    bool optional\n){\n    return _fus_lexer_get_attr_bool(lexer, attr, b, optional, \"y\", \"n\");\n}\n\nint fus_lexer_get_attr_bool(fus_lexer_t *lexer, const char *attr, bool *b,\n    bool optional\n){\n    return _fus_lexer_get_attr_bool(lexer, attr, b, optional, \"t\", \"f\");\n}\n\nint fus_lexer_unexpected(fus_lexer_t *lexer, const char *expected){\n    fus_lexer_err_info(lexer);\n    if(expected == NULL)fprintf(stderr, \"Unexpected: \");\n    else fprintf(stderr, \"Expected %s, but got: \", expected);\n    fus_lexer_show(lexer, stderr); fprintf(stderr, \"\\n\");\n    return 2;\n}\n\nint fus_lexer_parse_silent(fus_lexer_t *lexer){\n    int depth = 1;\n    while(1){\n        int err;\n\n        if(fus_lexer_got(lexer, \"(\")){\n            err = fus_lexer_next(lexer);\n            if(err)return err;\n            depth++;\n        }else if(fus_lexer_got(lexer, \")\")){\n            depth--;\n            if(depth == 0)break;\n            err = fus_lexer_next(lexer);\n            if(err)return err;\n        }else if(fus_lexer_done(lexer)){\n            return fus_lexer_unexpected(lexer, NULL);\n        }else{\n            /* eat atoms silently */\n            err = fus_lexer_next(lexer);\n            if(err)return err;\n        }\n    }\n    return 0;\n}\n","\n#include <stdio.h>\n#include <string.h>\n\n#include \"write.h\"\n\n\nvoid fus_write_str(FILE *f, const char *s){\n    fputc('\\\"', f);\n    char c;\n    while(c = *s, c != '\\0'){\n        if(c == '\\n'){\n            fputs(\"\\\\n\", f);\n        }else if(c == '\\\"' || c == '\\\\'){\n            fputc('\\\\', f);\n            fputc(c, f);\n        }else{\n            fputc(c, f);\n        }\n        s++;\n    }\n    fputc('\\\"', f);\n}\n\nvoid fus_write_str_padded(FILE *f, const char *s, int w){\n    int s_len = strlen(s);\n    if(s_len + 2 < w){\n        for(int i = 0; i < w - s_len - 2; i++)putc(' ', f);\n    }\n    fus_write_str(f, s);\n}\n\n","\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#include \"util.h\"\n#include \"vars.h\"\n\n\n/*******\n * VAR *\n *******/\n\nvoid var_cleanup(var_t *var){\n    free(var->key);\n    var_unset(var);\n}\n\nint var_init(var_t *var, char *key){\n    var->key = key;\n    var->type = 'n';\n    return 0;\n}\n\n\nvoid var_unset(var_t *var){\n    if(var->type == 's')free(var->value.s);\n}\n\nvoid var_set_null(var_t *var){\n    var_unset(var);\n    var->type = 'n';\n}\nvoid var_set_bool(var_t *var, bool b){\n    var_unset(var);\n    var->type = 'b';\n    var->value.b = b;\n}\nvoid var_set_int(var_t *var, int i){\n    var_unset(var);\n    var->type = 'i';\n    var->value.i = i;\n}\nvoid var_set_str(var_t *var, char *s){\n    var_unset(var);\n    var->type = 's';\n    var->value.s = s;\n}\n\n\n/********\n * VARS *\n ********/\n\nvoid vars_cleanup(vars_t *vars){\n    ARRAY_FREE_PTR(var_t*, vars->vars, var_cleanup)\n}\n\nint vars_init(vars_t *vars){\n    ARRAY_INIT(vars->vars)\n    return 0;\n}\n\nint vars_add(vars_t *vars, char *key, var_t **var_ptr){\n    ARRAY_PUSH_NEW(var_t*, vars->vars, var)\n    *var_ptr = var;\n    return 0;\n}\n\nvar_t *vars_get(vars_t *vars, const char *key){\n    for(int i = 0; i < vars->vars_len; i++){\n        var_t *var = vars->vars[i];\n        if(!strcmp(var->key, key))return var;\n    }\n    return NULL;\n}\n\nvar_t *vars_get_or_add(vars_t *vars, const char *key){\n    var_t *var = vars_get(vars, key);\n    if(!var){\n        char *new_key = strdup(key);\n        if(new_key == NULL){\n            perror(\"vars_get_or_add\");\n            return NULL;\n        }\n        int err = vars_add(vars, new_key, &var);\n        if(err)return NULL;\n    }\n    return var;\n}\n\n\nbool vars_get_bool(vars_t *vars, const char *key){\n    var_t *var = vars_get(vars, key);\n    if(var == NULL)return false;\n    return var->value.b;\n}\nint vars_get_int(vars_t *vars, const char *key){\n    var_t *var = vars_get(vars, key);\n    if(var == NULL)return 0;\n    return var->value.i;\n}\nconst char *vars_get_str(vars_t *vars, const char *key){\n    var_t *var = vars_get(vars, key);\n\n    /* Do we want to be accurate (there is no string) or safe\n    (empty string)?.. */\n    //if(var == NULL)return NULL;\n    if(var == NULL)return \"\";\n\n    return var->value.s;\n}\n\nint vars_set_null(vars_t *vars, const char *key){\n    var_t *var = vars_get_or_add(vars, key);\n    if(var == NULL)return 1;\n    var_set_null(var);\n    return 0;\n}\nint vars_set_bool(vars_t *vars, const char *key, bool b){\n    var_t *var = vars_get_or_add(vars, key);\n    if(var == NULL)return 1;\n    var_set_bool(var, b);\n    return 0;\n}\nint vars_set_int(vars_t *vars, const char *key, int i){\n    var_t *var = vars_get_or_add(vars, key);\n    if(var == NULL)return 1;\n    var_set_int(var, i);\n    return 0;\n}\nint vars_set_str(vars_t *vars, const char *key, char *s){\n    var_t *var = vars_get_or_add(vars, key);\n    if(var == NULL)return 1;\n    var_set_str(var, s);\n    return 0;\n}\n\n","\n/*\n\n    Can we derive vec_rot, vec_flip for a given space from a set of\n    equations in its dims?\n\n    Or like -- R(A) is always B, R(B) is always C, and all we need to specify\n    is R(D) because that's the last dim.\n\n    It should also be possible to derive flip given the definition of flip(B)\n    a.k.a. F(R(A)).\n\n    Hmmmm.\n\n*/\n\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#include \"geom.h\"\n#include \"lexer.h\"\n\n\n/* For theoretical speed boost, but possible errors, turn this off */\n#ifndef GEOM_ROT_SAFE\n#define GEOM_ROT_SAFE true\n#endif\n\n\nrot_t rot_contain(int rot_max, rot_t r){\n#   if GEOM_ROT_SAFE\n        while(r < 0)r += rot_max;\n        while(r >= rot_max)r -= rot_max;\n        return r;\n#   else\n        return r > rot_max? rot_max - r: r;\n#   endif\n}\n\nrot_t rot_rot(int rot_max, rot_t r1, rot_t r2){\n    return rot_contain(rot_max, r1 + r2);\n}\n\nbool rot_eq(int rot_max, rot_t r1, rot_t r2){\n    return rot_contain(rot_max, r1) == rot_contain(rot_max, r2);\n}\n\n\n\nvoid vec_zero(vec_t v){\n    for(int i = MAX_VEC_DIMS - 1; i >= 0; i--){\n        v[i] = 0;\n    }\n}\n\nvoid vec_neg(int dims, vec_t v){\n    for(int i = dims - 1; i >= 0; i--){\n        v[i] = -v[i];\n    }\n}\n\nvoid vec_fprintf(FILE *f, int dims, vec_t v){\n    fprintf(f, \"[% i\", v[0]);\n    for(int i = 1; i < dims; i++){\n        fprintf(f, \" % i\", v[i]);\n    }\n    fprintf(f, \"]\");\n}\n\nvoid vec_printf(int dims, vec_t v){\n    vec_fprintf(stdout, dims, v);\n}\n\nvoid vec_cpy(int dims, vec_t v, vec_t w){\n    for(int i = dims - 1; i >= 0; i--){\n        v[i] = w[i];\n    }\n}\n\nvoid vec_add(int dims, vec_t v, vec_t w){\n    for(int i = dims - 1; i >= 0; i--){\n        v[i] += w[i];\n    }\n}\n\nvoid vec_sub(int dims, vec_t v, vec_t w){\n    for(int i = dims - 1; i >= 0; i--){\n        v[i] -= w[i];\n    }\n}\n\nvoid vec_addn(int dims, vec_t v, vec_t w, int n){\n    for(int i = dims - 1; i >= 0; i--){\n        v[i] += w[i] * n;\n    }\n}\n\nbool vec_eq(int dims, vec_t v, vec_t w){\n    for(int i = dims - 1; i >= 0; i--){\n        if(v[i] != w[i])return false;\n    }\n    return true;\n}\n\nvoid vec_nmul(int dims, vec_t v, int n){\n    for(int i = dims - 1; i >= 0; i--){\n        v[i] *= n;\n    }\n}\n\n\nvoid vec_apply(const vecspace_t *space, vec_t v, trf_t *t){\n    space->vec_flip(v, t->flip);\n    space->vec_rot(v, t->rot);\n    vec_add(space->dims, v, t->add);\n}\n\nvoid vec_apply_inv(const vecspace_t *space, vec_t v, trf_t *t){\n    vec_sub(space->dims, v, t->add);\n    space->vec_rot(v, rot_inv(space->rot_max, t->rot));\n    space->vec_flip(v, t->flip);\n}\n\nvoid vec_mul(const vecspace_t *space, vec_t v, vec_t w){\n    int dims = space->dims;\n\n    vec_t v0;\n    vec_cpy(dims, v0, v);\n\n    vec_nmul(dims, v, w[0]);\n\n    for(int i = 1; i < dims; i++){\n        space->vec_rot(v0, 1);\n        vec_addn(dims, v, v0, w[i]);\n    }\n}\n\n\n\nvoid boundbox_init(boundbox_t box, int dims){\n    for(int i = 0; i < dims; i++){\n        box[i*2] = 0;\n        box[i*2+1] = 0;\n    }\n}\n\nvoid boundbox_fprintf(FILE *f, int dims, boundbox_t box){\n    fprintf(f, \"[% i % i\", box[0], box[1]);\n    for(int i = 1; i < dims; i++){\n        fprintf(f, \" | % i % i\", box[i*2], box[i*2+1]);\n    }\n    fprintf(f, \"]\");\n}\n\nvoid boundbox_printf(int dims, boundbox_t box){\n    boundbox_fprintf(stdout, dims, box);\n}\n\n\n\nvoid trf_zero(trf_t *trf){\n    vec_zero(trf->add);\n    trf->rot = 0;\n    trf->flip = false;\n}\n\nvoid trf_cpy(const vecspace_t *space, trf_t *trf1, trf_t *trf2){\n    vec_cpy(space->dims, trf1->add, trf2->add);\n    trf1->rot = trf2->rot;\n    trf1->flip = trf2->flip;\n}\n\nvoid trf_fprintf(FILE *f, int dims, trf_t *trf){\n    fprintf(f, \"%s %2i \", trf->flip? \"T\": \"F\", trf->rot);\n    vec_fprintf(f, dims, trf->add);\n}\n\nvoid trf_printf(int dims, trf_t *trf){\n    trf_fprintf(stdout, dims, trf);\n}\n\nbool trf_eq(const vecspace_t *space, trf_t *t, trf_t *s){\n    return\n        !!t->flip == !!s->flip &&\n        rot_eq(space->rot_max, t->rot, s->rot) &&\n        vec_eq(space->dims, t->add, s->add);\n}\n\nvoid trf_inv(const vecspace_t *space, trf_t *t){\n    flip_t f = t->flip;\n    rot_t r = rot_inv(space->rot_max, t->rot);\n    space->vec_rot(t->add, r);\n    space->vec_flip(t->add, f);\n    vec_neg(space->dims, t->add);\n    t->flip = f;\n    t->rot = rot_flip(space->rot_max, f, r);\n}\n\nvoid trf_apply(const vecspace_t *space, trf_t *t, trf_t *s){\n    if(s->flip){\n        t->flip = flip_inv(t->flip);\n        t->rot = rot_inv(space->rot_max, t->rot);\n        space->vec_flip(t->add, s->flip);\n    }\n    t->rot = rot_rot(space->rot_max, t->rot, s->rot);\n    space->vec_rot(t->add, s->rot);\n    vec_add(space->dims, t->add, s->add);\n}\n\nvoid trf_apply_inv(const vecspace_t *space, trf_t *t, trf_t *s){\n    vec_sub(space->dims, t->add, s->add);\n    rot_t r = rot_inv(space->rot_max, s->rot);\n    space->vec_rot(t->add, r);\n    t->rot = rot_rot(space->rot_max, t->rot, r);\n    if(s->flip){\n        t->flip = flip_inv(t->flip);\n        t->rot = rot_inv(space->rot_max, t->rot);\n        space->vec_flip(t->add, s->flip);\n    }\n}\n\n\n\n/*********\n * LEXER *\n *********/\n\nstatic int fus_lexer_get_vec_simple(fus_lexer_t *lexer,\n    vecspace_t *space, vec_t vec\n){\n    int err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n    for(int i = 0; i < space->dims; i++){\n        err = fus_lexer_get_int(lexer, &vec[i]);\n        if(err)return err;\n    }\n    err = fus_lexer_get(lexer, \")\");\n    if(err)return err;\n\n    return 0;\n}\n\nint fus_lexer_get_vec(fus_lexer_t *lexer, vecspace_t *space, vec_t vec){\n    int err;\n\n    if(fus_lexer_got(lexer, \"(\")){\n        return fus_lexer_get_vec_simple(lexer, space, vec);}\n\n    err = fus_lexer_get(lexer, \"eval\");\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n\n    vec_zero(vec);\n    while(1){\n        vec_t add;\n\n        err = fus_lexer_get_vec_simple(lexer, space, add);\n        if(err)return err;\n\n        if(fus_lexer_got(lexer, \"*\")){\n            err = fus_lexer_next(lexer);\n            if(err)return err;\n            int n;\n            err = fus_lexer_get_int(lexer, &n);\n            if(err)return err;\n\n            vec_nmul(space->dims, add, n);\n        }\n\n        vec_add(space->dims, vec, add);\n\n        if(fus_lexer_got(lexer, \")\"))break;\n\n        err = fus_lexer_get(lexer, \"+\");\n        if(err)return err;\n    }\n    err = fus_lexer_next(lexer);\n    if(err)return err;\n\n    return 0;\n}\n","\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#include \"vec4.h\"\n\n\nvecspace_t vec4 = {\n    VEC4_DIMS,\n    VEC4_ROT_MAX,\n    vec4_rot,\n    vec4_flip,\n    vec4_render\n};\n\n\nvoid vec4_set(vec_t v, int a, int b, int c, int d){\n    v[0] = a;\n    v[1] = b;\n    v[2] = c;\n    v[3] = d;\n}\n\nvoid vec4_rot1(vec_t v){\n    int a = v[0];\n    int b = v[1];\n    int c = v[2];\n    int d = v[3];\n    v[0] = -d;\n    v[1] = a;\n    v[2] = b + d;\n    v[3] = c;\n}\n\nvoid vec4_rot(vec_t v, rot_t r){\n    /* Let's be saaafe */\n    r = rot_contain(VEC4_ROT_MAX, r);\n    for(int i = r; i > 0; i--)vec4_rot1(v);\n}\n\nvoid vec4_flip1(vec_t v){\n    int a = v[0];\n    int b = v[1];\n    int c = v[2];\n    int d = v[3];\n    v[0] = a + c;\n    v[2] = -c;\n    v[3] = -b - d;\n}\n\nvoid vec4_flip(vec_t v, flip_t flip){\n    if(flip)vec4_flip1(v);\n}\n\nvoid vec4_render(vec_t v, int *x, int *y){\n    *x =  (v[0] + v[1]) * 2 + v[2];\n    *y = -(v[3] + v[2]) * 2 - v[1];\n}\n","\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#include \"hexspace.h\"\n\n\n/*\n\n  Y +\n     \\\n     (+)- +\n          X\n\n*/\n\n\nvecspace_t hexspace = {\n    HEXSPACE_DIMS,\n    HEXSPACE_ROT_MAX,\n    hexspace_rot,\n    hexspace_flip,\n    hexspace_render\n};\n\n\nvoid hexspace_set(vec_t v, int x, int y){\n    v[0] = x;\n    v[1] = y;\n}\n\nvoid hexspace_rot1(vec_t v){\n    /* RX = X + Y */\n    /* RY = -X */\n    int x = v[0] - v[1];\n    int y = v[0];\n    v[0] = x;\n    v[1] = y;\n}\n\nvoid hexspace_rot(vec_t v, rot_t r){\n    /* Let's be saaafe */\n    r = rot_contain(HEXSPACE_ROT_MAX, r);\n\n    for(int i = r; i > 0; i--)hexspace_rot1(v);\n}\n\nvoid hexspace_flip1(vec_t v){\n    /* RX = X */\n    /* RY = -X - Y */\n    int x = v[0] - v[1];\n    int y = -v[1];\n    v[0] = x;\n    v[1] = y;\n}\n\nvoid hexspace_flip(vec_t v, flip_t flip){\n    if(flip)hexspace_flip1(v);\n}\n\nvoid hexspace_render(vec_t v, int *x, int *y){\n    /* Basically we transform hexspace to vec4, then render that.\n    Hexspace to vec4: X -> A, Y -> C - A */\n\n    *x = 2 * v[0] - v[1];\n    *y = -2 * v[1];\n}\n\nvoid hexspace_angle(vec_t v, rot_t *rot_ptr, int *dist, int *angle){\n    if(v[0] == 0 && v[1] == 0){\n        /* Doesn't make sense to get the angle at the origin; but\n        we do return dist, which will be zero, and caller can check that,\n        ignoring rot and angle unless dist > 0. */\n        *rot_ptr = 0;\n        *dist = 0;\n        *angle = 0;\n        return;\n    }\n    vec_t v_cpy;\n    vec_cpy(HEXSPACE_DIMS, v_cpy, v);\n    rot_t rot = HEXSPACE_ROT_MAX;\n    while(\n        v_cpy[0] < 0 ||\n        v_cpy[1] < 0 ||\n        v_cpy[1] >= v_cpy[0]\n    ){\n        hexspace_rot1(v_cpy);\n        rot--;\n    }\n    if(rot == HEXSPACE_ROT_MAX)rot = 0;\n    *rot_ptr = rot;\n    *dist = v_cpy[0];\n    *angle = v_cpy[1];\n}\n\nint hexspace_dist(vec_t v, vec_t w){\n    rot_t rot;\n    int angle, dist;\n    vec_t diff;\n    vec_cpy(HEXSPACE_DIMS, diff, v);\n    vec_sub(HEXSPACE_DIMS, diff, w);\n    hexspace_angle(diff, &rot, &dist, &angle);\n    return dist;\n}\n\n\nvoid vec4_vec_from_hexspace(vec_t v, vec_t w){\n    /* Hexspace to vec4: X -> A, Y -> C - A */\n    v[0] = w[0] - w[1];\n    v[1] = 0;\n    v[2] = w[1];\n    v[3] = 0;\n}\n\nrot_t vec4_rot_from_hexspace(rot_t r){\n    return r * 2;\n}\n\n","\n#include <stdio.h>\n#include <stdbool.h>\n\n#include \"bounds.h\"\n\n\nvoid boundary_box_clear(boundary_box_t *b){\n    b->l = b->r = b->t = b->b = 0;\n}\n\nvoid position_box_clear(position_box_t *b){\n    b->x = b->y = b->w = b->h = 0;\n}\n\nvoid boundary_box_set(boundary_box_t *box, int l, int r, int t, int b){\n    box->l = l;\n    box->r = r;\n    box->t = t;\n    box->b = b;\n}\n\nvoid position_box_set(position_box_t *box, int x, int y, int w, int h){\n    box->x = x;\n    box->y = y;\n    box->w = w;\n    box->h = h;\n}\n\nvoid boundary_box_fprintf(FILE *f, boundary_box_t *b){\n    fprintf(f, \"{.l=% 2i, .r=% 2i, .t=% 2i, .b=% 2i}\",\n        b->l, b->r, b->t, b->b);\n}\n\nvoid position_box_fprintf(FILE *f, position_box_t *b){\n    fprintf(f, \"{.x=% 2i, .y=% 2i, .w=% 2i, .h=% 2i}\",\n        b->x, b->y, b->w, b->h);\n}\n\nvoid boundary_box_printf(boundary_box_t *b){\n    boundary_box_fprintf(stdout, b);\n}\n\nvoid position_box_printf(position_box_t *b){\n    position_box_fprintf(stdout, b);\n}\n\nbool boundary_box_eq(boundary_box_t *b1, boundary_box_t *b2){\n    return\n        b1->l == b2->l &&\n        b1->r == b2->r &&\n        b1->t == b2->t &&\n        b1->b == b2->b\n    ;\n}\n\nbool position_box_eq(position_box_t *b1, position_box_t *b2){\n    return\n        b1->x == b2->x &&\n        b1->y == b2->y &&\n        b1->w == b2->w &&\n        b1->h == b2->h\n    ;\n}\n\nvoid boundary_box_from_position_box(boundary_box_t *bbox, position_box_t *pbox){\n    bbox->l = -pbox->x;\n    bbox->t = -pbox->y;\n    bbox->r =  pbox->w - pbox->x;\n    bbox->b =  pbox->h - pbox->y;\n}\n\nvoid position_box_from_boundary_box(position_box_t *pbox, boundary_box_t *bbox){\n    pbox->x = -bbox->l;\n    pbox->y = -bbox->t;\n    pbox->w =  bbox->r - bbox->l;\n    pbox->h =  bbox->b - bbox->t;\n}\n\nvoid boundary_box_union(boundary_box_t *b1, boundary_box_t *b2){\n    if(b2->l < b1->l)b1->l = b2->l;\n    if(b2->r > b1->r)b1->r = b2->r;\n    if(b2->t < b1->t)b1->t = b2->t;\n    if(b2->b > b1->b)b1->b = b2->b;\n}\n\nvoid position_box_shift(position_box_t *b, int x, int y){\n    b->x += x;\n    b->y += y;\n}\n\nvoid boundary_box_shift(boundary_box_t *b, int x, int y){\n    b->l += x;\n    b->r += x;\n    b->t += y;\n    b->b += y;\n}\n\n","\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <stdarg.h>\n\n#include <SDL2/SDL.h>\n\n\n#include \"util.h\"\n#include \"lexer.h\"\n#include \"font.h\"\n\n\n\nvoid font_get_char_coords(font_t *font, char c, int *char_x, int *char_y){\n    int char_index = (unsigned)c;\n    *char_x = char_index % 16;\n    *char_y = char_index / 16;\n}\n\n\nint font_load(font_t *font, const char *filename, SDL_Palette *pal){\n    font->char_w = 0;\n    font->char_h = 0;\n    font->pal = pal;\n    font->surface = NULL;\n\n    int err;\n    fus_lexer_t lexer;\n\n    char *text = load_file(filename);\n    if(text == NULL)return 1;\n\n    err = fus_lexer_init(&lexer, text, filename);\n    if(err)return err;\n\n    err = font_parse(font, &lexer);\n    if(err)return err;\n\n    free(text);\n    return 0;\n}\n\nint font_parse(font_t *font, fus_lexer_t *lexer){\n    int err;\n\n\n    /*****************\n     * GET CHAR W, H *\n     *****************/\n\n    int char_w, char_h;\n\n    err = fus_lexer_get(lexer, \"char_w\");\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n    err = fus_lexer_get_int(lexer, &char_w);\n    if(err)return err;\n    err = fus_lexer_get(lexer, \")\");\n    if(err)return err;\n\n    err = fus_lexer_get(lexer, \"char_h\");\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n    err = fus_lexer_get_int(lexer, &char_h);\n    if(err)return err;\n    err = fus_lexer_get(lexer, \")\");\n    if(err)return err;\n\n\n    /******************\n     * CREATE SURFACE *\n     ******************/\n\n    static const int n_chars_x = 16;\n    static const int n_chars_y = 16;\n\n    SDL_Surface *surface = surface8_create(\n        char_w * n_chars_x, char_h * n_chars_y, true, true, font->pal);\n    if(surface == NULL)return 2;\n\n    SDL_LockSurface(surface);\n    SDL_memset(surface->pixels, 0, surface->h * surface->pitch);\n\n    Uint8 color_values[3] = {1+8, 1+7, 1+15};\n\n\n    /************************\n     * PARSE & RENDER CHARS *\n     ************************/\n\n    err = fus_lexer_get(lexer, \"chars\");\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n\n    while(1){\n        if(fus_lexer_got(lexer, \")\"))break;\n\n        char char_c;\n        err = fus_lexer_get_chr(lexer, &char_c);\n        if(err)return err;\n\n        int char_x, char_y;\n        font_get_char_coords(font, char_c, &char_x, &char_y);\n\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n\n        for(int y = 0; y < char_h; y++){\n            char *line;\n            err = fus_lexer_get_str(lexer, &line);\n            if(err)return err;\n            int line_w = strlen(line);\n            if(line_w != char_w){\n                fus_lexer_err_info(lexer);\n                fprintf(stderr, \"Bad line width: %i, expected %i\\n\",\n                    line_w, char_w);\n                return 2;}\n\n            Uint8 *p = surface8_get_pixel_ptr(surface,\n                char_x * char_w,\n                char_y * char_h + y);\n\n            for(int x = 0; x < char_w; x++){\n                char c = line[x];\n                if(c >= '0' && c <= '2'){\n                    p[x] = color_values[c - '0'];\n                }else if(c == ' '){\n                    /* ok */\n                }else{\n                    fus_lexer_unexpected(lexer, \"'0', '1', '2', or ' '\");\n                    return 2;\n                }\n            }\n\n            free(line);\n        }\n\n        err = fus_lexer_get(lexer, \")\");\n        if(err)return err;\n    }\n    err = fus_lexer_next(lexer);\n    if(err)return err;\n\n\n    /*************\n     * FINISH UP *\n     *************/\n\n    SDL_UnlockSurface(surface);\n\n    font->char_w = char_w;\n    font->char_h = char_h;\n    font->surface = surface;\n    return 0;\n}\n\nvoid font_blitter_newline(font_blitter_t *blitter){\n    blitter->col = 0;\n    blitter->row++;\n}\n\nvoid font_blitter_move_right(font_blitter_t *blitter){\n    blitter->col++;\n}\n\nvoid font_blitchar(font_t *font, SDL_Surface *render_surface,\n    int x, int y, char c\n){\n    int char_w = font->char_w;\n    int char_h = font->char_h;\n\n    int char_x, char_y;\n    font_get_char_coords(font, toupper(c),\n        &char_x, &char_y);\n\n    SDL_Rect src_rect = {\n        char_x * char_w,\n        char_y * char_h,\n        char_w, char_h\n    };\n    SDL_Rect dst_rect = {\n        x, y,\n        char_w, char_h\n    };\n    SDL_BlitSurface(font->surface, &src_rect,\n        render_surface, &dst_rect);\n}\n\nvoid font_blitter_blitchar(font_blitter_t *blitter, char c){\n    font_t *font = blitter->font;\n\n    if(c == '\\n'){\n        font_blitter_newline(blitter);\n        return;\n    }\n\n    font_blitchar(font, blitter->render_surface,\n        blitter->x0 + blitter->col * font->char_w,\n        blitter->y0 + blitter->row * font->char_h,\n        c);\n    font_blitter_move_right(blitter);\n}\n\nvoid font_blitmsg(font_t *font, SDL_Surface *render_surface,\n    int x0, int y0, const char *msg, ...\n){\n    int char_w = font->char_w;\n    int char_h = font->char_h;\n    font_blitter_t blitter = {font, render_surface, x0, y0, 0, 0};\n\n    va_list args;\n    va_start(args, msg);\n\n    char c;\n    while(c = *msg, c != '\\0'){\n        if(c == '%'){\n            msg++;\n            c = *msg;\n            if(c != '%'){\n                if(c == 'i'){\n                    int i = va_arg(args, int);\n\n                    /* 2^64 has 20 digits in base 10 */\n                    static const int max_digits = 20;\n                    int digits[max_digits];\n                    int digit_i = 0;\n\n                    /* in case i == 0 */\n                    digits[0] = 0;\n\n                    if(i < 0){\n                        i = -i;\n                        font_blitter_blitchar(&blitter, '-');\n                    }\n\n                    while(i > 0 && digit_i < max_digits){\n                        digits[digit_i] = i % 10;\n                        i /= 10;\n                        digit_i++;\n                    }\n\n                    if(digit_i > 0)digit_i--;\n                    while(digit_i >= 0){\n                        char c = '0' + digits[digit_i];\n                        font_blitter_blitchar(&blitter, c);\n                        digit_i--;\n                    }\n                }else if(c == 'c'){\n                    char c = va_arg(args, int);\n                    font_blitter_blitchar(&blitter, c);\n                }else if(c == 's'){\n                    char *s = va_arg(args, char *);\n                    char c;\n                    while(c = *s, c != '\\0'){\n                        font_blitter_blitchar(&blitter, c);\n                        s++;\n                    }\n                }else{\n                    fprintf(stderr,\n                        \"font_blitmsg: Unsupported format string: %%%c\\n\", c);\n                    goto done;\n                }\n                msg++;\n                continue;\n            }\n        }\n\n        font_blitter_blitchar(&blitter, c);\n        msg++;\n    }\n\ndone:\n    va_end(args);\n}\n","\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#include <SDL2/SDL.h>\n\n#include \"console.h\"\n#include \"font.h\"\n\n\n\nvoid console_clear(console_t *console){\n    int text_len = console->cols * console->rows;\n    for(int i = 0; i < text_len; i++)console->text[i] = ' ';\n    console->col = 0;\n    console->row = 0;\n}\n\nvoid console_clear_line(console_t *console){\n    int cols = console->cols;\n    char *text = console->text + console->row * cols;\n    for(int i = 0; i < cols; i++)text[i] = ' ';\n    console->col = 0;\n}\n\nint console_init(console_t *console, int cols, int rows, int input_maxlen){\n    int text_len = cols * rows;\n\n    char *text = calloc(text_len + 1, sizeof(*text));\n    if(text == NULL)return 1;\n    for(int i = 0; i < text_len; i++)text[i] = ' ';\n\n    char *input = calloc(input_maxlen + 1, sizeof(*text));\n    if(input == NULL)return 1;\n\n    console->cols = cols;\n    console->rows = rows;\n\n    console->text = text;\n    console->col = 0;\n    console->row = 0;\n\n    console->input = input;\n    console->input_i = 0;\n    console->input_len = 0;\n    console->input_maxlen = input_maxlen;\n    return 0;\n}\n\nint console_get_index(console_t *console, int col, int row){\n    return row * console->cols + col;\n}\n\nint console_get_text_i(console_t *console){\n    return console_get_index(console, console->col, console->row);\n}\n\nvoid console_move_up(console_t *console){\n    if(console->row < 1)console->row = console->rows - 1;\n    else console->row--;\n}\n\nvoid console_move_down(console_t *console){\n    if(console->row >= console->rows - 1)console->row = 0;\n    else console->row++;\n    console_clear_line(console);\n}\n\nvoid console_move_left(console_t *console){\n    if(console->col < 1){\n        console->col = console->cols - 1;\n        console_move_up(console);\n    }else{\n        console->col--;\n    }\n}\n\nvoid console_move_right(console_t *console){\n    if(console->col >= console->cols - 1){\n        console->col = 0;\n        console_move_down(console);\n    }else{\n        console->col++;\n    }\n}\n\nvoid console_newline(console_t *console){\n    console->col = 0;\n    console_move_down(console);\n}\n\nvoid console_write_char(console_t *console, char c){\n    if(c == '\\n'){\n        console_newline(console);\n    }else if(c == '\\0'){\n        /* Don't show EOF */\n    }else{\n        int text_i = console_get_text_i(console);\n        console->text[text_i] = c;\n        console_move_right(console);\n    }\n}\n\nvoid console_write_msg(console_t *console, const char *msg){\n    while(*msg != '\\0'){\n        console_write_char(console, *msg);\n        msg++;\n    }\n}\n\nvoid console_backspace(console_t *console){\n    console_move_left(console);\n    int text_i = console_get_text_i(console);\n    console->text[text_i] = ' ';\n}\n\nvoid console_delete(console_t *console){\n    if(console->input_i >= console->input_len - 1)return;\n    int text_i = console_get_text_i(console);\n    console->text[text_i] = ' ';\n    console_move_left(console);\n}\n\nvoid console_input_char(console_t *console, char c){\n    if(console->input_len >= console->input_maxlen)return;\n    for(int i = console->input_len; i > console->input_i; i--){\n        console->input[i] = console->input[i - 1];\n    }\n    console->input[console->input_i] = c;\n    console->input_i++;\n    console->input_len++;\n    console_write_char(console, c);\n}\n\nvoid console_input_backspace(console_t *console){\n    if(console->input_len < 1)return;\n    for(int i = console->input_i - 1; i < console->input_len; i++){\n        console->input[i] = console->input[i + 1];\n    }\n    console->input_i--;\n    console->input_len--;\n    console_backspace(console);\n}\n\nvoid console_input_delete(console_t *console){\n    if(console->input_len < 1)return;\n    for(int i = console->input_i; i < console->input_len; i++){\n        console->input[i] = console->input[i + 1];\n    }\n    console->input_i--;\n    console->input_len--;\n    console_delete(console);\n}\n\nvoid console_input_clear(console_t *console){\n    int input_len = console->input_len;\n    for(int i = 0; i < input_len; i++)console->input[i] = '\\0';\n    console->input_i = 0;\n    console->input_len = 0;\n}\n\n\n\nvoid console_blit(console_t *console, font_t *font, SDL_Surface *render_surface,\n    int x0, int y0\n){\n    int char_w = font->char_w;\n    int char_h = font->char_h;\n\n    int cols = console->cols;\n    int rows = console->rows;\n    char *text = console->text + (console->row + 1) * cols;\n    char *text_end = console->text + cols * rows;\n\n    int y = y0;\n    for(int row = 0; row < rows; row++){\n        int x = x0;\n        if(text >= text_end)text = console->text;\n        for(int col = 0; col < cols; col++){\n            font_blitchar(font, render_surface, x, y, *text);\n            text++;\n            x += char_w;\n        }\n        y += char_h;\n    }\n}\n\n","\n#include <stdio.h>\n#include <stdbool.h>\n#include <SDL2/SDL.h>\n\n#include \"test_app.h\"\n#include \"prismelrenderer.h\"\n#include \"rendergraph.h\"\n#include \"array.h\"\n#include \"vec4.h\"\n#include \"font.h\"\n#include \"console.h\"\n#include \"util.h\"\n#include \"anim.h\"\n#include \"hexmap.h\"\n#include \"hexgame.h\"\n#include \"hexspace.h\"\n\n\n#define MAX_ZOOM 4\n\n\nvoid test_app_cleanup(test_app_t *app){\n    palette_cleanup(&app->palette);\n    SDL_FreePalette(app->sdl_palette);\n    prismelrenderer_cleanup(&app->prend);\n    hexgame_cleanup(&app->hexgame);\n}\n\nstatic void test_app_init_input(test_app_t *app){\n    app->keydown_shift = false;\n    app->keydown_ctrl = false;\n    app->keydown_u = 0;\n    app->keydown_d = 0;\n    app->keydown_l = 0;\n    app->keydown_r = 0;\n}\n\nint test_app_init(test_app_t *app, int scw, int sch, int delay_goal,\n    SDL_Window *window, SDL_Renderer *renderer, const char *prend_filename,\n    const char *stateset_filename, const char *hexmap_filename,\n    bool use_textures, bool cache_bitmaps, int n_players\n){\n    int err;\n\n    app->scw = scw;\n    app->sch = sch;\n    app->delay_goal = delay_goal;\n\n    app->window = window;\n    app->renderer = renderer;\n    app->prend_filename = prend_filename;\n    app->stateset_filename = stateset_filename;\n    app->hexmap_filename = hexmap_filename;\n\n    SDL_Palette *sdl_palette = SDL_AllocPalette(256);\n    app->sdl_palette = sdl_palette;\n    RET_IF_SDL_NULL(sdl_palette);\n\n    palette_t *palette = &app->palette;\n    err = palette_load(palette, \"data/pal1.fus\");\n    if(err)return err;\n\n    if(use_textures){\n        app->surface = NULL;\n    }else{\n        app->surface = surface8_create(scw, sch, false, false,\n            app->sdl_palette);\n        if(app->surface == NULL)return 1;\n    }\n\n    font_t *font = &app->font;\n    err = font_load(font, \"data/font.fus\", sdl_palette);\n    if(err)return err;\n\n    console_t *console = &app->console;\n    err = console_init(console, 80, 40, 20000);\n    if(err)return err;\n\n    prismelrenderer_t *prend = &app->prend;\n    err = prismelrenderer_init(prend, &vec4);\n    if(err)return err;\n    err = prismelrenderer_load(prend, app->prend_filename);\n    if(err)return err;\n    if(prend->rendergraphs_len < 1){\n        fprintf(stderr, \"No rendergraphs in %s\\n\", app->prend_filename);\n        return 2;}\n\n    prend->cache_bitmaps = cache_bitmaps;\n\n    hexgame_t *game = &app->hexgame;\n    err = hexgame_init(game, prend, app->hexmap_filename);\n    if(err)return err;\n\n    hexmap_t *map = game->maps[0];\n    vecspace_t *space = map->space;\n\n    for(int i = 0; i < n_players; i++){\n        static char respawn_filename[] = \"respawn_N.txt\";\n        respawn_filename[8] = '0' + i;\n\n        vec_t respawn_pos;\n        rot_t respawn_rot = 0;\n        bool respawn_turn = false;\n        char *respawn_map_filename = NULL;\n        vec_cpy(space->dims, respawn_pos, map->spawn);\n        err = player_respawn_load(respawn_filename,\n            respawn_pos, &respawn_rot, &respawn_turn,\n            &respawn_map_filename);\n        if(err){\n            /* If there was an \"err\", don't panic -- just keep default\n            spawn location we got from map. */\n            respawn_map_filename = strdup(map->name);\n        }\n\n        hexmap_t *respawn_map;\n        err = hexgame_get_or_load_map(game, respawn_map_filename,\n            &respawn_map);\n        if(err)return err;\n\n        ARRAY_PUSH_NEW(body_t*, respawn_map->bodies, body)\n        err = body_init(body, game, respawn_map,\n            strdup(app->stateset_filename), NULL, NULL);\n        if(err)return err;\n\n        ARRAY_PUSH_NEW(player_t*, game->players, player)\n        err = player_init(player, body, i,\n            respawn_pos, respawn_rot, respawn_turn,\n            respawn_map_filename, respawn_filename);\n        if(err)return err;\n    }\n\n    {\n        /* Find first body for player 0 (going to point camera at it) */\n        body_t *body = NULL;\n        for(int i = 0; i < game->players_len; i++){\n            player_t *player = game->players[i];\n            if(player->keymap != 0)continue;\n            body = player->body;\n            break;\n        }\n\n        /* Create camera */\n        ARRAY_PUSH_NEW(camera_t*, game->cameras, camera)\n        err = camera_init(camera, game, map, body);\n        if(err)return err;\n\n        app->camera = camera;\n    }\n\n    app->cur_rgraph_i = 0;\n    app->x0 = 0;\n    app->y0 = 0;\n    app->rot = 0;\n    app->flip = false;\n    app->zoom = 1;\n    app->frame_i = 0;\n    app->loop = true;\n    app->hexgame_running = true;\n    app->show_controls = true;\n\n    test_app_init_input(app);\n\n    app->render_surface = surface32_create(app->scw, app->sch,\n        false, true);\n    if(app->render_surface == NULL)return 2;\n\n    return 0;\n}\n\n\nint test_app_process_console_input(test_app_t *app){\n    int err;\n\n    rendergraph_t *rgraph =\n        app->prend.rendergraphs[app->cur_rgraph_i];\n\n    fus_lexer_t _lexer;\n    fus_lexer_t *lexer = &_lexer;\n    err = fus_lexer_init(lexer, app->console.input, \"<console input>\");\n    if(err)goto lexer_err;\n\n    if(fus_lexer_got(lexer, \"exit\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        app->loop = false;\n    }else if(fus_lexer_got(lexer, \"cls\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        console_clear(&app->console);\n    }else if(fus_lexer_got(lexer, \"run\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        console_write_msg(&app->console, \"Try F5\\n\");\n        return 0;\n    }else if(fus_lexer_got(lexer, \"add_player\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        char *stateset_filename;\n\n        if(!fus_lexer_done(lexer)){\n            err = fus_lexer_get_str(lexer, &stateset_filename);\n            if(err)goto lexer_err;\n        }else{\n            stateset_filename = strdup(app->stateset_filename);\n        }\n\n        hexgame_t *game = &app->hexgame;\n        /* HACK: we just grab maps[0] */\n        hexmap_t *map = game->maps[0];\n        vec_ptr_t respawn_pos = map->spawn;\n        rot_t respawn_rot = 0;\n        bool respawn_turn = false;\n        char *respawn_map_filename = NULL;\n        if(game->players_len > 0){\n            /* HACK: we just grab players[0] */\n            player_t *player = game->players[0];\n            respawn_pos = player->respawn_location.pos;\n            respawn_rot = player->respawn_location.rot;\n            respawn_turn = player->respawn_location.turn;\n            respawn_map_filename = strdup(player->respawn_location.map_filename);\n        }else{\n            respawn_map_filename = strdup(map->name);\n        }\n\n        hexmap_t *respawn_map;\n        err = hexgame_get_or_load_map(game, respawn_map_filename,\n            &respawn_map);\n        if(err)return err;\n\n        int keymap = -1;\n        for(int i = 0; i < game->players_len; i++){\n            player_t *player = game->players[i];\n            if(player->keymap > keymap)keymap = player->keymap;\n        }\n        keymap++;\n\n        ARRAY_PUSH_NEW(body_t*, respawn_map->bodies, body)\n        err = body_init(body, game, respawn_map, stateset_filename,\n            NULL, NULL);\n        if(err)return err;\n\n        ARRAY_PUSH_NEW(player_t*, game->players, player)\n        err = player_init(player, body, keymap,\n            respawn_pos, respawn_rot, respawn_turn, respawn_map_filename,\n            NULL);\n        if(err)return err;\n    }else if(fus_lexer_got(lexer, \"save\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        char *filename = NULL;\n\n        if(!fus_lexer_done(lexer)){\n            err = fus_lexer_get_str(lexer, &filename);\n            if(err)goto lexer_err;\n        }\n\n        if(filename == NULL){\n            err = prismelrenderer_write(&app->prend, stdout);\n            if(err)return err;\n        }else{\n            err = prismelrenderer_save(&app->prend, filename);\n            if(err)return err;\n        }\n    }else if(fus_lexer_got(lexer, \"dump\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        int dump_bitmaps = 1;\n        int dump_what = 0; /* rgraph, prend */\n        while(1){\n            if(fus_lexer_done(lexer))break;\n            else if(fus_lexer_got(lexer, \"rgraph\"))dump_what = 0;\n            else if(fus_lexer_got(lexer, \"prend\"))dump_what = 1;\n            else if(fus_lexer_got(lexer, \"nobitmaps\"))dump_bitmaps = 0;\n            else if(fus_lexer_got(lexer, \"surfaces\")){\n                /* WARNING: doing this with \"prend\" after \"renderall\" causes\n                my laptop to hang... */\n                dump_bitmaps = 2;}\n            else {\n                console_write_msg(&app->console, \"Dumper says: idunno\\n\");\n                dump_what = -1; break;}\n            err = fus_lexer_next(lexer);\n            if(err)return err;\n        }\n        if(dump_what == 0){\n            rendergraph_dump(rgraph, stdout, 0, dump_bitmaps);\n        }else if(dump_what == 1){\n            prismelrenderer_dump(&app->prend, stdout, dump_bitmaps);\n        }\n    }else if(fus_lexer_got(lexer, \"map\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        char *mapper_name;\n        char *mapped_rgraph_name;\n        char *resulting_rgraph_name = NULL;\n\n        err = fus_lexer_get_str(lexer, &mapper_name);\n        if(err)return err;\n        err = fus_lexer_get_str(lexer, &mapped_rgraph_name);\n        if(err)return err;\n        if(!fus_lexer_done(lexer)){\n            err = fus_lexer_get_str(lexer, &resulting_rgraph_name);\n            if(err)return err;\n        }\n\n        prismelmapper_t *mapper = prismelrenderer_get_mapper(\n            &app->prend, mapper_name);\n        if(mapper == NULL){\n            fprintf(stderr, \"Couldn't find mapper: %s\\n\", mapper_name);\n            return 2;}\n        rendergraph_t *mapped_rgraph = prismelrenderer_get_rendergraph(\n            &app->prend, mapped_rgraph_name);\n        if(mapped_rgraph == NULL){\n            fprintf(stderr, \"Couldn't find shape: %s\\n\",\n                mapped_rgraph_name);\n            return 2;}\n\n        free(mapper_name);\n        free(mapped_rgraph_name);\n\n        rendergraph_t *rgraph;\n        err = prismelmapper_apply_to_rendergraph(mapper, &app->prend,\n            mapped_rgraph, resulting_rgraph_name, app->prend.space,\n            NULL, &rgraph);\n        if(err)return err;\n    }else if(fus_lexer_got(lexer, \"renderall\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        SDL_Renderer *renderer = NULL;\n        err = prismelrenderer_render_all_bitmaps(\n            &app->prend, app->sdl_palette);\n        if(err)return err;\n    }else if(fus_lexer_got(lexer, \"get_shape\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        char *name;\n        err = fus_lexer_get_str(lexer, &name);\n        if(err)return err;\n        bool found = false;\n        for(int i = 0; i < app->prend.rendergraphs_len; i++){\n            rendergraph_t *rgraph = app->prend.rendergraphs[i];\n            if(!strcmp(rgraph->name, name)){\n                app->cur_rgraph_i = i;\n                found = true;\n                break;\n            }\n        }\n        if(!found){\n            fprintf(stderr, \"Couldn't find shape: %s\\n\", name);\n            return 2;}\n        return 0;\n    }else{\n        fus_lexer_unexpected(lexer, NULL);\n        console_write_msg(&app->console, \"Sorry, what?\\n\");\n        return 0;\n    }\n\n    console_write_msg(&app->console, \"OK\\n\");\n    return 0;\nlexer_err:\n    console_write_msg(&app->console, \"That didn't work\\n\");\n    return 0;\n}\n\n\nint test_app_mainloop(test_app_t *app){\n    SDL_StartTextInput();\n    while(app->loop){\n        int err = test_app_mainloop_step(app);\n        if(err)return err;\n    }\n    SDL_StopTextInput();\n    return 0;\n}\n\nint test_app_mainloop_step(test_app_t *app){\n        int err;\n        Uint32 tick0 = SDL_GetTicks();\n\n        hexgame_t *game = &app->hexgame;\n\n        rendergraph_t *rgraph =\n            app->prend.rendergraphs[app->cur_rgraph_i];\n        int animated_frame_i = get_animated_frame_i(\n            rgraph->animation_type, rgraph->n_frames, app->frame_i);\n\n        err = palette_update_sdl_palette(&app->palette, app->sdl_palette);\n        if(err)return err;\n        err = palette_step(&app->palette);\n        if(err)return err;\n\n        if(app->hexgame_running){\n            err = hexgame_step(game);\n            if(err)return err;\n\n            if(app->surface != NULL){\n                RET_IF_SDL_NZ(SDL_FillRect(app->surface, NULL, 255));\n            }else{\n                SDL_Color *bgcolor = &app->sdl_palette->colors[255];\n                RET_IF_SDL_NZ(SDL_SetRenderDrawColor(app->renderer,\n                    bgcolor->r, bgcolor->g, bgcolor->b, 255));\n                RET_IF_SDL_NZ(SDL_RenderClear(app->renderer));\n            }\n\n            err = camera_render(app->camera,\n                app->renderer, app->surface,\n                app->sdl_palette, app->scw/2 + app->x0, app->sch/2 + app->y0,\n                1 /* app->zoom */);\n            if(err)return err;\n\n            if(app->surface != NULL){\n                int line_y = 0;\n                for(int i = 0; i < game->players_len; i++){\n                    player_t *player = game->players[i];\n                    body_t *body = player->body;\n                    if(!body)continue;\n                    if(body->dead == BODY_MOSTLY_DEAD){\n                        font_blitmsg(&app->font, app->surface, 0, line_y,\n                            \"You ran into a wall! \"\n                            \"Press jump to retry from where you jumped.\\n\");\n                        line_y += app->font.char_h;\n                    }else if(body->dead == BODY_ALL_DEAD){\n                        static char msg[] =\n                            \"You were crushed! \"\n                            \"Press X to retry from last save point.\\n\";\n                        msg[24] = '0' + i + 1;\n                        font_blitmsg(&app->font, app->surface, 0, line_y, msg);\n                        line_y += app->font.char_h;\n                    }\n                }\n                if(app->show_controls){\n                    font_blitmsg(&app->font, app->surface, 0, line_y,\n                        \"*Controls:\\n\"\n                        \"  Left/right  -> Walk\\n\"\n                        \"  Up          -> Jump\\n\"\n                        \"  Down        -> Crawl\\n\"\n                        \"  Spacebar    -> Spit\\n\"\n                        \"  Shift       -> Look up\\n\"\n                        \"  1           -> Return to checkpoint\\n\"\n                        \"  Shift + 1   -> Return to start of game\\n\"\n                        \"  Enter       -> Show/hide this message\\n\"\n                        \"  Escape      -> Quit\\n\"\n                    );\n                }\n\n                SDL_Texture *render_texture = SDL_CreateTextureFromSurface(\n                    app->renderer, app->surface);\n                RET_IF_SDL_NULL(render_texture);\n                SDL_RenderCopy(app->renderer, render_texture, NULL, NULL);\n                SDL_DestroyTexture(render_texture);\n            }\n\n            SDL_RenderPresent(app->renderer);\n        }else{\n            /*****************\n             * DEBUG CONSOLE *\n             *****************/\n\n            /******************************************************************\n            * Clear screen\n            */\n\n            RET_IF_SDL_NZ(SDL_FillRect(app->render_surface, NULL, 0));\n\n            if(app->surface != NULL){\n                RET_IF_SDL_NZ(SDL_FillRect(app->surface, NULL, 0));\n            }else{\n                RET_IF_SDL_NZ(SDL_SetRenderDrawColor(app->renderer,\n                    0, 0, 0, 255));\n                RET_IF_SDL_NZ(SDL_RenderClear(app->renderer));\n            }\n\n            /******************************************************************\n            * Render rgraph\n            */\n\n            int x0 = app->scw / 2 + app->x0;\n            int y0 = app->sch / 2 + app->y0;\n            err = rendergraph_render(rgraph, app->renderer, app->surface,\n                app->sdl_palette, &app->prend, x0, y0, app->zoom,\n                (vec_t){0}, app->rot, app->flip, app->frame_i, NULL);\n            if(err)return err;\n\n            /******************************************************************\n            * Render text\n            */\n\n            font_blitmsg(&app->font, app->render_surface, 0, 0,\n                \"Game running? %c\\n\"\n                \"Frame rendered in: %i ms\\n\"\n                \"  (Aiming for sub-%i ms)\\n\"\n                \"# Textures in use: %i\\n\"\n                \"Controls:\\n\"\n                \"  up/down - zoom (hold shift for tap mode)\\n\"\n                \"  left/right - rotate (hold shift for tap mode)\\n\"\n                \"  control + up/down/left/right - pan (hold shift...)\\n\"\n                \"  page up/down - cycle through available rendergraphs\\n\"\n                \"  0 - reset rotation\\n\"\n                \"Currently displaying rendergraphs from file: %s\\n\"\n                \"Currently displaying rendergraph %i / %i: %s\\n\"\n                \"  pan=(%i,%i), rot = %i, flip = %c, zoom = %i,\"\n                    \" frame_i = %i (%i) / %i (%s)\",\n                app->hexgame_running? 'y': 'n', app->took, app->delay_goal,\n                app->prend.n_textures,\n                app->prend_filename, app->cur_rgraph_i,\n                app->prend.rendergraphs_len, rgraph->name,\n                app->x0, app->y0, app->rot, app->flip? 'y': 'n', app->zoom,\n                app->frame_i, animated_frame_i,\n                rgraph->n_frames, rgraph->animation_type);\n\n            console_blit(&app->console, &app->font, app->render_surface,\n                0, 20 * app->font.char_h);\n\n            /******************************************************************\n            * Draw to renderer and present it\n            */\n\n            if(app->surface != NULL){\n                SDL_Texture *render_texture = SDL_CreateTextureFromSurface(\n                    app->renderer, app->surface);\n                RET_IF_SDL_NULL(render_texture);\n                SDL_RenderCopy(app->renderer, render_texture, NULL, NULL);\n                SDL_DestroyTexture(render_texture);\n            }\n\n            {\n                SDL_Texture *render_texture = SDL_CreateTextureFromSurface(\n                    app->renderer, app->render_surface);\n                RET_IF_SDL_NULL(render_texture);\n                SDL_RenderCopy(app->renderer, render_texture, NULL, NULL);\n                SDL_DestroyTexture(render_texture);\n            }\n\n            SDL_RenderPresent(app->renderer);\n\n        }\n\n        SDL_Event event;\n        while(SDL_PollEvent(&event)){\n            if(event.type == SDL_QUIT){\n                app->loop = false; break;}\n\n            if(event.type == SDL_KEYDOWN){\n                if(event.key.keysym.sym == SDLK_ESCAPE){\n                    app->loop = false; break;\n                }else if(event.key.keysym.sym == SDLK_RETURN){\n                    app->show_controls = !app->show_controls;\n                }else if(event.key.keysym.sym == SDLK_F5){\n                    if(app->hexgame_running){\n                        app->hexgame_running = false;\n                        console_write_msg(&app->console, \"Game stopped\\n\");\n                        SDL_StartTextInput();\n                    }else{\n                        app->hexgame_running = true;\n                        test_app_init_input(app);\n                        console_write_msg(&app->console, \"Game started\\n\");\n                        SDL_StopTextInput();\n                    }\n                    continue;\n                }else if(event.key.keysym.sym == SDLK_F6){\n                    app->camera->zoomout = true;\n                }else if(event.key.keysym.sym == SDLK_F7){\n                    app->camera->follow = !app->camera->follow;\n                }else if(event.key.keysym.sym == SDLK_F8){\n                    app->camera->smooth_scroll = !app->camera->smooth_scroll;\n                }else if(event.key.keysym.sym == SDLK_F11){\n                    printf(\"Frame rendered in: %i ms\\n\", app->took);\n                    printf(\"  (Aiming for sub-%i ms)\\n\", app->delay_goal);\n\n                    prismelrenderer_dump_stats(&app->prend, stdout);\n                }\n            }else if(event.type == SDL_KEYUP){\n                if(event.key.keysym.sym == SDLK_F6){\n                    app->camera->zoomout = false;\n                }\n            }\n\n            if(app->hexgame_running){\n                err = hexgame_process_event(game, &event);\n                if(err)return err;\n                continue;}\n\n            switch(event.type){\n                case SDL_KEYDOWN: {\n                    if(event.key.keysym.sym == SDLK_RETURN){\n                        console_newline(&app->console);\n\n                        err = test_app_process_console_input(app);\n                        if(err)return err;\n\n                        console_input_clear(&app->console);\n                    }\n                    if(event.key.keysym.sym == SDLK_BACKSPACE){\n                        console_input_backspace(&app->console);}\n                    if(event.key.keysym.sym == SDLK_DELETE){\n                        console_input_delete(&app->console);}\n                    if(\n                        event.key.keysym.mod & (KMOD_LCTRL | KMOD_RCTRL)\n                        && event.key.keysym.mod & (KMOD_LSHIFT | KMOD_RSHIFT)\n                    ){\n                        if(event.key.keysym.sym == SDLK_c){\n                            SDL_SetClipboardText(app->console.input);}\n                        if(event.key.keysym.sym == SDLK_v\n                            && SDL_HasClipboardText()\n                        ){\n                            char *input = SDL_GetClipboardText();\n                            char *c = input;\n                            while(*c != '\\0'){\n                                console_input_char(&app->console, *c);\n                                c++;\n                            }\n                            SDL_free(input);\n                        }\n                    }\n\n                    if(event.key.keysym.sym == SDLK_0){\n                        app->x0 = 0; app->y0 = 0;\n                        app->rot = 0; app->flip = false; app->zoom = 1;}\n\n                    if(event.key.keysym.sym == SDLK_SPACE){\n                        app->flip = !app->flip;}\n\n                    #define IF_KEYDOWN(SYM, KEY) \\\n                        if(event.key.keysym.sym == SDLK_##SYM \\\n                            && app->keydown_##KEY == 0){ \\\n                                app->keydown_##KEY = 2;}\n                    IF_KEYDOWN(UP, u)\n                    IF_KEYDOWN(DOWN, d)\n                    IF_KEYDOWN(LEFT, l)\n                    IF_KEYDOWN(RIGHT, r)\n                    #undef IF_KEYDOWN\n\n                    if(event.key.keysym.sym == SDLK_LSHIFT\n                        || event.key.keysym.sym == SDLK_RSHIFT){\n                            app->keydown_shift = true;}\n                    if(event.key.keysym.sym == SDLK_LCTRL\n                        || event.key.keysym.sym == SDLK_RCTRL){\n                            app->keydown_ctrl = true;}\n\n                    if(event.key.keysym.sym == SDLK_PAGEUP){\n                        app->cur_rgraph_i++;\n                        if(app->cur_rgraph_i >=\n                            app->prend.rendergraphs_len){\n                                app->cur_rgraph_i = 0;}}\n                    if(event.key.keysym.sym == SDLK_PAGEDOWN){\n                        app->cur_rgraph_i--;\n                        if(app->cur_rgraph_i < 0){\n                            app->cur_rgraph_i =\n                                app->prend.rendergraphs_len - 1;}}\n                    if(event.key.keysym.sym == SDLK_HOME){\n                        app->frame_i++;}\n                    if(event.key.keysym.sym == SDLK_END){\n                        if(app->frame_i > 0)app->frame_i--;}\n                } break;\n                case SDL_KEYUP: {\n\n                    #define IF_KEYUP(SYM, KEY) \\\n                        if(event.key.keysym.sym == SDLK_##SYM){ \\\n                            app->keydown_##KEY = 0;}\n                    IF_KEYUP(UP, u)\n                    IF_KEYUP(DOWN, d)\n                    IF_KEYUP(LEFT, l)\n                    IF_KEYUP(RIGHT, r)\n                    #undef IF_KEYUP\n\n                    if(event.key.keysym.sym == SDLK_LSHIFT\n                        || event.key.keysym.sym == SDLK_RSHIFT){\n                            app->keydown_shift = false;}\n                    if(event.key.keysym.sym == SDLK_LCTRL\n                        || event.key.keysym.sym == SDLK_RCTRL){\n                            app->keydown_ctrl = false;}\n                } break;\n                case SDL_TEXTINPUT: {\n                    for(char *c = event.text.text; *c != '\\0'; c++){\n                        console_input_char(&app->console, *c);\n                    }\n                } break;\n                default: break;\n            }\n        }\n\n        #define IF_APP_KEY(KEY, BODY) \\\n            if(app->keydown_##KEY >= (app->keydown_shift? 2: 1)){ \\\n                app->keydown_##KEY = 1; \\\n                BODY}\n        IF_APP_KEY(l, if(app->keydown_ctrl){app->x0 += 6;}else{app->rot += 1;})\n        IF_APP_KEY(r, if(app->keydown_ctrl){app->x0 -= 6;}else{app->rot -= 1;})\n        IF_APP_KEY(u, if(app->keydown_ctrl){app->y0 += 6;}else if(app->zoom < MAX_ZOOM){app->zoom += 1;})\n        IF_APP_KEY(d, if(app->keydown_ctrl){app->y0 -= 6;}else if(app->zoom > 1){app->zoom -= 1;})\n        #undef IF_APP_KEY\n\n        Uint32 tick1 = SDL_GetTicks();\n        app->took = tick1 - tick0;\n        if(app->took < app->delay_goal)SDL_Delay(app->delay_goal - app->took);\n#ifdef GEOM_HEXGAME_DEBUG_FRAMERATE\n        if(app->took > app->delay_goal){\n            fprintf(stderr, \"WARNING: Frame rendered in %i ms \"\n                \"(aiming for sub-%i ms)\\n\",\n                app->took, app->delay_goal);\n        }\n#endif\n\n        return 0;\n}\n\n","\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#ifdef GEOM_HEXGAME_DEBUG_MALLOC\n    #include <malloc.h>\n#endif\n\n#include \"hexgame.h\"\n#include \"anim.h\"\n#include \"hexmap.h\"\n#include \"hexspace.h\"\n#include \"prismelrenderer.h\"\n#include \"array.h\"\n#include \"util.h\"\n#include \"write.h\"\n\n\n\n/**********\n * CAMERA *\n **********/\n\nvoid camera_cleanup(camera_t *camera){\n    /* Nuthin */\n}\n\nint camera_init(camera_t *camera, hexgame_t *game, hexmap_t *map,\n    body_t *body\n){\n    camera->game = game;\n    camera->map = map;\n    camera->cur_submap = NULL;\n    camera->body = body;\n\n    camera->zoomout = false;\n    camera->follow = false;\n    camera->smooth_scroll = true;\n\n    memset(camera->colors, 0, sizeof(camera->colors));\n    camera->colors_fade = 0;\n\n    camera_set(camera, (vec_t){0}, 0);\n    return 0;\n}\n\nvoid camera_set(camera_t *camera, vec_t pos,\n    rot_t rot\n){\n    vecspace_t *space = camera->map->space;\n    vec_cpy(space->dims, camera->pos, pos);\n    vec_cpy(space->dims, camera->scrollpos, pos);\n    camera->rot = rot;\n    camera->should_reset = true;\n}\n\nvoid camera_colors_flash(camera_t *camera, Uint8 r, Uint8 g, Uint8 b,\n    int percent\n){\n    for(int i = 0; i < 256; i++){\n        SDL_Color *c = &camera->colors[i];\n        interpolate_color(c, r, g, b, percent, 100);\n    }\n    camera->colors_fade = 0;\n}\n\nvoid camera_colors_flash_white(camera_t *camera, int percent){\n    camera_colors_flash(camera, 255, 255, 255, percent);\n}\n\nstatic int camera_colors_step(camera_t *camera, palette_t *palette){\n    int err;\n    if(camera->cur_submap != NULL){\n        err = palette_update_colors(palette, camera->colors,\n            camera->colors_fade, HEXGAME_MAX_COLORS_FADE);\n        if(err)return err;\n        if(camera->colors_fade < HEXGAME_MAX_COLORS_FADE)camera->colors_fade++;\n    }\n    return 0;\n}\n\nint camera_step(camera_t *camera){\n    int err;\n\n    hexgame_t *game = camera->game;\n    body_t *body = camera->body;\n\n    /* Figure out camera's current submap */\n    if(body != NULL){\n        camera->map = body->map;\n        if(camera->cur_submap != body->cur_submap){\n            camera->cur_submap = body->cur_submap;\n\n#ifndef DONT_ANIMATE_PALETTE\n            if(camera->smooth_scroll && !camera->should_reset){\n                /* Smoothly transition between old & new palettes */\n                camera->colors_fade = 0;\n            }\n#endif\n\n            err = palette_reset(&camera->cur_submap->palette);\n            if(err)return err;\n        }\n    }\n\n    hexmap_t *map = camera->map;\n    vecspace_t *space = map->space;\n\n#ifndef DONT_ANIMATE_PALETTE\n    /* Animate palette */\n    /* NOTE: compiling with -DDONT_ANIMATE_PALETTE is useful for producing\n    animated GIF gameplay clips, since our palette changes are too subtle\n    for my GIF capturing software (byzanz), leading to periodic flashes of\n    different colours. */\n\n    /* NOTE: The following call to palette_step shouldn't be in here.\n    This means palettes are updated once for every camera which is looking\n    at them, which makes no sense, but will work ok so long as we only\n    have 1 camera. */\n    if(camera->cur_submap != NULL){\n        err = palette_step(&camera->cur_submap->palette);\n        if(err)return err;\n    }\n#endif\n\n    err = camera_colors_step(camera, &camera->cur_submap->palette);\n    if(err)return err;\n\n    /* Set camera */\n    int camera_type = -1;\n    if(camera->follow)camera_type = 1;\n    else if(camera->cur_submap != NULL){\n        camera_type = camera->cur_submap->camera_type;}\n    if(camera_type == 0){\n        vec_cpy(space->dims, camera->pos,\n            camera->cur_submap->camera_pos);\n        camera->rot = 0;\n    }else if(camera_type == 1){\n        if(body != NULL){\n            vec_cpy(space->dims, camera->pos,\n                body->pos);\n            camera->rot = body->rot;\n        }\n    }\n\n    /* Scroll renderpos */\n    if(camera->smooth_scroll && !camera->should_reset){\n        vec_ptr_t scrollpos = camera->scrollpos;\n\n        vec_t target_scrollpos;\n        vec_cpy(space->dims, target_scrollpos, camera->pos);\n\n        vec_t diff;\n        vec_cpy(space->dims, diff, target_scrollpos);\n        vec_sub(space->dims, diff, scrollpos);\n\n        rot_t rot;\n        int dist, angle;\n        hexspace_angle(diff, &rot, &dist, &angle);\n\n        if(dist > 0){\n            vec_t add;\n            if(angle > 0){\n                /* X + R X */\n                hexspace_set(add, 2, 1);\n            }else{\n                /* X */\n                hexspace_set(add, 1, 0);\n            }\n            hexspace_rot(add, rot);\n            vec_add(space->dims, scrollpos, add);\n        }\n    }else{\n        if(camera->should_reset){\n            vec_cpy(space->dims, camera->scrollpos, camera->pos);\n            camera->should_reset = false;\n        }\n    }\n\n    return 0;\n}\n\nint camera_render(camera_t *camera,\n    SDL_Renderer *renderer, SDL_Surface *surface,\n    SDL_Palette *pal, int x0, int y0, int zoom\n){\n    int err;\n\n    err = update_sdl_palette(pal, camera->colors);\n    if(err)return err;\n\n    hexgame_t *game = camera->game;\n    hexmap_t *map = camera->map;\n    vecspace_t *space = map->space;\n\n    vec_t camera_renderpos;\n    vec4_vec_from_hexspace(camera_renderpos, camera->scrollpos);\n\n    prismelmapper_t *mapper = NULL;\n\n    hexmap_submap_t *submap = camera->cur_submap;\n    if(submap != NULL){\n        if(!camera->zoomout)mapper = submap->mapper;\n    }\n\n    /* Render map's submaps */\n    for(int i = 0; i < map->submaps_len; i++){\n        hexmap_submap_t *submap = map->submaps[i];\n        rendergraph_t *rgraph = submap->rgraph_map;\n\n#ifdef GEOM_ONLY_RENDER_CUR_SUBMAP\n        if(submap != camera->cur_submap)continue;\n#endif\n\n        vec_t pos;\n        vec4_vec_from_hexspace(pos, submap->pos);\n        vec_sub(rgraph->space->dims, pos, camera_renderpos);\n        vec_mul(rgraph->space, pos, camera->map->unit);\n\n        rot_t rot = vec4_rot_from_hexspace(0);\n        //rot_t rot = vec4_rot_from_hexspace(\n        //    rot_inv(space->rot_max, camera->rot));\n        flip_t flip = false;\n        int frame_i = game->frame_i;\n\n        err = rendergraph_render(rgraph, renderer, surface,\n            pal, camera->map->prend,\n            x0, y0, zoom,\n            pos, rot, flip, frame_i, mapper);\n        if(err)return err;\n    }\n\n    /* Render map's bodies */\n    for(int i = 0; i < map->bodies_len; i++){\n        body_t *body = map->bodies[i];\n\n#ifdef GEOM_ONLY_RENDER_CUR_SUBMAP\n        if(body->cur_submap != camera->cur_submap)continue;\n#endif\n\n        err = body_render(body,\n            renderer, surface,\n            pal, x0, y0, zoom,\n            map, camera_renderpos, mapper);\n        if(err)return err;\n    }\n\n    return 0;\n}\n\n\n/***********\n * HEXGAME *\n ***********/\n\nvoid hexgame_cleanup(hexgame_t *game){\n    ARRAY_FREE_PTR(hexmap_t*, game->maps, hexmap_cleanup)\n    ARRAY_FREE_PTR(camera_t*, game->cameras, camera_cleanup)\n    ARRAY_FREE_PTR(player_t*, game->players, player_cleanup)\n    ARRAY_FREE_PTR(actor_t*, game->actors, actor_cleanup)\n}\n\nint hexgame_init(hexgame_t *game, prismelrenderer_t *prend,\n    const char *map_filename\n){\n    int err;\n\n    game->frame_i = 0;\n    game->prend = prend;\n    game->space = &hexspace; /* NOT the same as prend->space! */\n\n    ARRAY_INIT(game->maps)\n    ARRAY_INIT(game->cameras)\n    ARRAY_INIT(game->players)\n    ARRAY_INIT(game->actors)\n\n    hexmap_t *map;\n    err = hexgame_load_map(game, map_filename, &map);\n    if(err)return err;\n\n    return 0;\n}\n\nint hexgame_load_map(hexgame_t *game, const char *map_filename,\n    hexmap_t **map_ptr\n){\n    int err;\n    ARRAY_PUSH_NEW(hexmap_t*, game->maps, map)\n    err = hexmap_load(map, game, map_filename);\n    if(err)return err;\n    *map_ptr = map;\n    return 0;\n}\n\nint hexgame_get_or_load_map(hexgame_t *game, const char *map_filename,\n    hexmap_t **map_ptr\n){\n    int err;\n\n    for(int i = 0; i < game->maps_len; i++){\n        hexmap_t *map = game->maps[i];\n        if(!strcmp(map->name, map_filename)){\n            *map_ptr = map;\n            return 0;\n        }\n    }\n\n    return hexgame_load_map(game, map_filename, map_ptr);\n}\n\nint hexgame_reset_player(hexgame_t *game, player_t *player, int reset_level){\n    /* reset_level:\n    RESET_TO_SAFETY is to player->safe_location, RESET_SOFT is to\n    player->respawn_location, RESET_HARD is to start of game. */\n\n    /* WARNING: this function calls body_respawn, which calls\n    body_move_to_map, which modifies map->bodies for two maps.\n    So if caller is trying to loop over map->bodies in the usual way,\n    the behaviour of that loop is probably gonna be super wrong. */\n\n    int err;\n    vecspace_t *space = game->space;\n    body_t *body = player->body;\n    hexmap_t *map = NULL;\n    vec_ptr_t pos = NULL;\n    rot_t rot = 0;\n    bool turn = false;\n\n    if(reset_level == RESET_HARD){\n        map = game->maps[0];\n        pos = map->spawn;\n    }else{\n        location_t *location = reset_level == RESET_SOFT?\n            &player->respawn_location:\n            &player->safe_location;\n        err = hexgame_get_or_load_map(game, location->map_filename,\n            &map);\n        if(err)return err;\n        pos = location->pos;\n        rot = location->rot;\n        turn = location->turn;\n    }\n\n    err = body_respawn(body, pos, rot, turn, map);\n    if(err)return err;\n\n    body_reset_cameras(body);\n    body_flash_cameras(body, 255, 255, 255, 30);\n    return 0;\n}\n\nstatic player_t *hexgame_get_player_by_keymap(hexgame_t *game, int keymap){\n    for(int i = 0; i < game->players_len; i++){\n        player_t *player = game->players[i];\n        if(player->keymap == keymap)return player;\n    }\n    return NULL;\n}\n\nint hexgame_reset_players_by_keymap(hexgame_t *game, int keymap, int reset_level){\n    int err;\n    player_t *player = hexgame_get_player_by_keymap(game, keymap);\n    if(!player)return 2;\n    err = hexgame_reset_player(game, player, reset_level);\n    if(err)return err;\n    return 0;\n}\n\nstatic int hexgame_add_coin(hexgame_t *game, hexmap_t *map,\n    hexmap_submap_t *submap, int x, int y, const char *state_name\n){\n    int err;\n    vecspace_t *space = map->space;\n\n    ARRAY_PUSH_NEW(body_t*, map->bodies, new_body)\n    err = body_init(new_body, game, map,\n        \"anim/coin.fus\", state_name, NULL);\n    if(err)return err;\n\n    new_body->pos[0] = x;\n    new_body->pos[1] = y;\n\n    return 0;\n}\n\nstatic int hexgame_add_random_coins_by_keymap(hexgame_t *game, int keymap){\n    int err;\n    player_t *player = hexgame_get_player_by_keymap(game, keymap);\n    if(!player)return 0;\n    body_t *body = player->body;\n    if(!body)return 0;\n\n    hexmap_t *map = body->map;\n    hexmap_submap_t *submap = body->cur_submap;\n    hexcollmap_t *collmap = &submap->collmap;\n\n    /* cx, cy: origin of submap */\n    int cx = submap->pos[0] - collmap->ox;\n    int cy = submap->pos[1] + collmap->oy;\n\n    int i = 0;\n    int step = 7;\n    int step_crouch = 11;\n    for(int y = 0; y < collmap->h; y++){\n        for(int x = 0; x < collmap->w; x++){\n            /* px, py: coin's position */\n            int px = cx + x;\n            int py = cy - y;\n            if(i % step == 0){\n                err = hexgame_add_coin(game, map, submap, px, py, \"stand\");\n                if(err)return err;\n            }\n            if(i % step_crouch == 0){\n                err = hexgame_add_coin(game, map, submap, px, py, \"crouch\");\n                if(err)return err;\n            }\n            i++;\n        }\n    }\n\n    return 0;\n}\n\nint hexgame_process_event(hexgame_t *game, SDL_Event *event){\n    int err;\n\n    if(event->type == SDL_KEYDOWN){\n        if(event->key.keysym.sym == SDLK_F9){\n            /* save recording */\n            for(int i = 0; i < game->players_len; i++){\n                player_t *player = game->players[i];\n                if(player->keymap != 0)continue;\n\n                body_t *body = player->body;\n                if(body->recording.action != 2){\n                    fprintf(stderr,\n                        \"Can't stop recording without starting first! \"\n                        \"(Try pressing 'R' before 'F9')\\n\");\n                }else{\n                    fprintf(stderr, \"Finished recording. \"\n                        \"Press F10 to play it back.\\n\");\n                    err = body_stop_recording(body);\n                    if(err)return err;\n                }\n            }\n        }else if(event->key.keysym.sym == SDLK_F10){\n            /* load recording */\n            bool shift = event->key.keysym.mod & KMOD_SHIFT;\n            const char *recording_filename = get_last_recording_filename();\n            if(recording_filename == NULL){\n                fprintf(stderr, \"Couldn't find file of last recording. \"\n                    \"Maybe you need to record your first one with 'R'?\\n\");\n            }else{\n                fprintf(stderr, \"Playing back from file: %s\\n\",\n                    recording_filename);\n                for(int i = 0; i < game->players_len; i++){\n                    player_t *player = game->players[i];\n                    if(player->keymap != 0)continue;\n\n                    if(shift){\n                        body_t *body = player->body;\n                        err = body_load_recording(body, recording_filename,\n                            true);\n                        if(err)return err;\n                        err = body_play_recording(body);\n                        if(err)return err;\n                    }else{\n                        /* TODO: Recordings need to state which map they\n                        expect! The following is a hack: you must play\n                        recordings belonging to your correct map... */\n                        body_t *body = player->body;\n                        err = hexmap_load_recording(body->map,\n                            recording_filename, NULL, true);\n                        if(err)return err;\n                    }\n                }\n            }\n#ifdef GEOM_HEXGAME_DEBUG_MALLOC\n        }else if(event->key.keysym.sym == SDLK_F11){\n            malloc_stats();\n#endif\n        }else if(event->key.keysym.sym == SDLK_F12){\n            for(int i = 0; i < game->players_len; i++){\n                player_t *player = game->players[i];\n                if(player->keymap < 0)continue;\n\n                body_t *body = player->body;\n                hexmap_submap_t *submap = body->cur_submap;\n                fprintf(stderr, \"Player %i:\\n\", player->keymap);\n                fprintf(stderr, \"  map: %s\\n\", body->map->name);\n                fprintf(stderr, \"  submap: %s\\n\",\n                    body->cur_submap->filename);\n                fprintf(stderr, \"  pos: %i %i\\n\",\n                    body->pos[0], body->pos[1]);\n                fprintf(stderr, \"  rot: %i\\n\", body->rot);\n                fprintf(stderr, \"  turn: %c\\n\", body->turn? 'y': 'n');\n            }\n        }else if(event->key.keysym.sym == SDLK_r){\n            /* start recording */\n            for(int i = 0; i < game->players_len; i++){\n                player_t *player = game->players[i];\n                if(player->keymap != 0)continue;\n\n                body_t *body = player->body;\n                const char *recording_filename = get_next_recording_filename();\n                fprintf(stderr, \"Recording to file: %s \"\n                    \" (When finished, press F9 to save!)\\n\",\n                    recording_filename);\n                err = body_start_recording(body, strdup(recording_filename));\n                if(err)return err;\n            }\n        }else if(!event->key.repeat){\n            bool shift = event->key.keysym.mod & KMOD_SHIFT;\n            bool ctrl = event->key.keysym.mod & KMOD_CTRL;\n            int reset_level = shift? RESET_HARD: RESET_SOFT;\n            int keymap = -1;\n            if(event->key.keysym.sym == SDLK_1)keymap = 0;\n            if(event->key.keysym.sym == SDLK_2)keymap = 1;\n            if(keymap > -1){\n                if(ctrl){\n                    err = hexgame_add_random_coins_by_keymap(game, keymap);\n                    if(err)return err;\n                }else{\n                    err = hexgame_reset_players_by_keymap(game, keymap, reset_level);\n                    if(err)return err;\n                }\n            }\n        }\n    }\n\n    for(int i = 0; i < game->players_len; i++){\n        player_t *player = game->players[i];\n        err = player_process_event(player, event);\n        if(err)return err;\n    }\n\n    return 0;\n}\n\nint hexgame_step(hexgame_t *game){\n    int err;\n\n    game->frame_i++;\n    if(game->frame_i == MAX_FRAME_I)game->frame_i = 0;\n\n    vecspace_t *space = game->space;\n\n    /* Do 1 gameplay step for each actor */\n    for(int i = 0; i < game->actors_len; i++){\n        actor_t *actor = game->actors[i];\n        err = actor_step(actor, game);\n        if(err)return err;\n    }\n\n    /* Do 1 gameplay step for each map */\n    for(int i = 0; i < game->maps_len; i++){\n        hexmap_t *map = game->maps[i];\n        err = hexmap_step(map);\n        if(err)return err;\n    }\n\n    /* Do 1 gameplay step for each player */\n    for(int i = 0; i < game->players_len; i++){\n        player_t *player = game->players[i];\n        err = player_step(player, game);\n        if(err)return err;\n    }\n\n    /* Do 1 step for each camera */\n    for(int i = 0; i < game->cameras_len; i++){\n        camera_t *camera = game->cameras[i];\n        err = camera_step(camera);\n        if(err)return err;\n    }\n\n    return 0;\n}\n","\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#include \"hexgame.h\"\n#include \"anim.h\"\n#include \"hexmap.h\"\n#include \"hexspace.h\"\n#include \"prismelrenderer.h\"\n#include \"array.h\"\n#include \"util.h\"\n#include \"write.h\"\n\n\n\n\n/************\n * KEY INFO *\n ************/\n\nvoid keyinfo_reset(keyinfo_t *info){\n    for(int i = 0; i < KEYINFO_KEYS; i++){\n        info->isdown[i] = false;\n        info->wasdown[i] = false;\n        info->wentdown[i] = false;\n    }\n}\n\nvoid keyinfo_copy(keyinfo_t *info1, keyinfo_t *info2){\n    for(int i = 0; i < KEYINFO_KEYS; i++){\n        info1->isdown[i] = info2->isdown[i];\n        info1->wasdown[i] = info2->wasdown[i];\n        info1->wentdown[i] = info2->wentdown[i];\n    }\n}\n\nint fus_lexer_get_keyinfo(fus_lexer_t *lexer,\n    keyinfo_t *info\n){\n    int err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n    while(1){\n        if(fus_lexer_got(lexer, \")\"))break;\n\n        char key_c;\n        char *name;\n        err = fus_lexer_get_name(lexer, &name);\n        if(err)return err;\n        if(strlen(name) != 1 || !strchr(ANIM_KEY_CS, name[0])){\n            return fus_lexer_unexpected(lexer,\n                \"one of the characters: \" ANIM_KEY_CS);}\n        key_c = name[0];\n        free(name);\n\n        int key_i = body_get_key_i(NULL, key_c, true);\n\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n        while(1){\n            if(fus_lexer_got(lexer, \")\"))break;\n\n            bool *keystate;\n            if(fus_lexer_got(lexer, \"is\")){\n                keystate = info->isdown;\n            }else if(fus_lexer_got(lexer, \"was\")){\n                keystate = info->wasdown;\n            }else if(fus_lexer_got(lexer, \"went\")){\n                keystate = info->wentdown;\n            }else{\n                return fus_lexer_unexpected(lexer,\n                    \"is or was or went\");\n            }\n            err = fus_lexer_next(lexer);\n            if(err)return err;\n\n            keystate[key_i] = true;\n        }\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n    }\n    err = fus_lexer_next(lexer);\n    if(err)return err;\n    return 0;\n}\n\n\n\n/*********************\n * BODY INIT/CLEANUP *\n *********************/\n\nvoid body_cleanup(body_t *body){\n    vars_cleanup(&body->vars);\n    stateset_cleanup(&body->stateset);\n    recording_cleanup(&body->recording);\n}\n\nint body_init(body_t *body, hexgame_t *game, hexmap_t *map,\n    const char *stateset_filename, const char *state_name,\n    palettemapper_t *palmapper\n){\n    int err;\n\n    body->game = game;\n    body->palmapper = palmapper;\n\n    body->out_of_bounds = false;\n    body->map = map;\n    body->cur_submap = NULL;\n\n    err = vars_init(&body->vars);\n    if(err)return err;\n\n    if(stateset_filename != NULL){\n        err = body_init_stateset(body, stateset_filename, state_name);\n        if(err)return err;\n    }else{\n        /* We really really expect you to call body_init_stateset\n        right away! */\n        body_set_state(body, NULL, true);\n    }\n\n    return 0;\n}\n\nint body_respawn(body_t *body, vec_t pos, rot_t rot, bool turn,\n    hexmap_t *map\n){\n    int err;\n    hexgame_t *game = body->game;\n    vecspace_t *space = game->space;\n\n    vec_cpy(space->dims, body->pos, pos);\n    body->rot = rot;\n    body->turn = turn;\n    err = body_set_state(body, body->stateset.states[0]->name, true);\n    if(err)return err;\n\n    err = body_move_to_map(body, map);\n    if(err)return err;\n\n    keyinfo_reset(&body->keyinfo);\n\n    return 0;\n}\n\nint body_add_body(body_t *body, body_t **new_body_ptr,\n    const char *stateset_filename, const char *state_name,\n    palettemapper_t *palmapper,\n    vec_t addpos, rot_t addrot, bool turn\n){\n    /* Adds a new body at same location as another body */\n    int err;\n    ARRAY_PUSH_NEW(body_t*, body->map->bodies, new_body)\n    err = body_init(new_body, body->game, body->map,\n        stateset_filename, state_name, palmapper);\n    if(err)return err;\n    vecspace_t *space = body->map->space;\n\n    vec_cpy(space->dims, new_body->pos, body->pos);\n    rot_t rot = body_get_rot(body);\n    space->vec_flip(addpos, body->turn);\n    space->vec_rot(addpos, rot);\n    vec_add(space->dims, new_body->pos, addpos);\n\n    new_body->rot =\n        rot_rot(space->rot_max, body->rot, addrot);\n\n    new_body->turn = turn? !body->turn: body->turn;\n\n    if(new_body_ptr)*new_body_ptr = new_body;\n    return 0;\n}\n\n\n\n/*************\n * BODY MISC *\n *************/\n\nrot_t body_get_rot(body_t *body){\n    vecspace_t *space = body->map->space;\n    rot_t rot = body->rot;\n    if(body->turn){\n        rot = rot_contain(space->rot_max,\n            space->rot_max/2 - rot);}\n    return rot;\n}\n\nvoid body_init_trf(body_t *body, trf_t *trf){\n    vecspace_t *space = body->map->space;\n    vec_cpy(space->dims, trf->add, body->pos);\n    trf->rot = body_get_rot(body);\n    trf->flip = body->turn;\n}\n\nvoid body_flash_cameras(body_t *body, Uint8 r, Uint8 g, Uint8 b,\n    int percent\n){\n    hexgame_t *game = body->game;\n    for(int i = 0; i < game->cameras_len; i++){\n        camera_t *camera = game->cameras[i];\n        if(camera->body != body)continue;\n        camera_colors_flash_white(camera, 30);\n    }\n}\n\nvoid body_reset_cameras(body_t *body){\n    hexgame_t *game = body->game;\n    for(int i = 0; i < game->cameras_len; i++){\n        camera_t *camera = game->cameras[i];\n        if(camera->body != body)continue;\n        camera->should_reset = true;\n    }\n}\n\nint body_move_to_map(body_t *body, hexmap_t *map){\n    /* WARNING: this function modifies map->bodies for two maps.\n    So if caller is trying to loop over map->bodies in the usual way,\n    the behaviour of that loop is probably gonna be super wrong. */\n    int err;\n    hexgame_t *game = body->game;\n    hexmap_t *old_map = body->map;\n\n    /* Don't do nuthin rash if you don't gotta */\n    if(body->map == map)return 0;\n\n    /* Do the thing we all came here for */\n    body->map = map;\n\n    /* Move body from old to new map's array of bodies */\n    ARRAY_UNHOOK(old_map->bodies, body)\n    ARRAY_PUSH(body_t*, map->bodies, body)\n\n    /* Update body->cur_submap */\n    body_update_cur_submap(body);\n\n    /* Update any cameras following this body */\n    for(int i = 0; i < game->cameras_len; i++){\n        camera_t *camera = game->cameras[i];\n        if(camera->body == body){\n            camera->map = map;\n            camera->cur_submap = body->cur_submap;\n        }\n    }\n    return 0;\n}\n\n\n/**************\n * BODY STATE *\n **************/\n\nint body_init_stateset(body_t *body, const char *stateset_filename,\n    const char *state_name\n){\n    int err;\n    hexmap_t *map = body->map;\n\n    err = stateset_load(&body->stateset, strdup(stateset_filename),\n        map->prend, map->space);\n    if(err)return err;\n\n    if(state_name == NULL){\n        state_name = body->stateset.states[0]->name;\n    }\n\n    err = body_set_state(body, state_name, true);\n    if(err)return err;\n\n    return 0;\n}\n\nint body_set_stateset(body_t *body, const char *stateset_filename,\n    const char *state_name\n){\n    stateset_cleanup(&body->stateset);\n    return body_init_stateset(body, stateset_filename, state_name);\n}\n\nint body_set_state(body_t *body, const char *state_name,\n    bool reset_cooldown\n){\n    if(state_name == NULL){\n        body->state = NULL;\n    }else{\n        body->state = stateset_get_state(&body->stateset, state_name);\n        if(body->state == NULL){\n            fprintf(stderr, \"Couldn't init body stateset: \"\n                \"couldn't find state %s in stateset %s\\n\",\n                state_name, body->stateset.filename);\n            return 2;}\n    }\n    body->frame_i = 0;\n    if(reset_cooldown)body->cooldown = 0;\n    body->dead = BODY_NOT_DEAD;\n    return 0;\n}\n\n\n/**************\n * BODY INPUT *\n **************/\n\nvoid body_keydown(body_t *body, int key_i){\n    if(key_i < 0 || key_i >= KEYINFO_KEYS)return;\n    body->keyinfo.isdown[key_i] = true;\n    body->keyinfo.wasdown[key_i] = true;\n    body->keyinfo.wentdown[key_i] = true;\n\n    if(body->recording.action == 2){\n        /* record */\n        body_maybe_record_wait(body);\n\n        char c = body_get_key_c(body, key_i, true);\n        fprintf(body->recording.file, \"+%c\", c);\n        if(DEBUG_RECORDINGS)printf(\"+%c\\n\", c);\n\n        /*\n        char buffer[3];\n        buffer[0] = '+';\n        buffer[1] = c;\n        buffer[2] = '\\0';\n        int err = body_record(body, buffer);\n        if(err){perror(\"body_record failed\");}\n        */\n    }\n}\n\nvoid body_keyup(body_t *body, int key_i){\n    if(key_i < 0 || key_i >= KEYINFO_KEYS)return;\n    body->keyinfo.isdown[key_i] = false;\n\n    if(body->recording.action == 2){\n        /* record */\n        body_maybe_record_wait(body);\n\n        char c = body_get_key_c(body, key_i, true);\n        fprintf(body->recording.file, \"-%c\", c);\n        if(DEBUG_RECORDINGS)printf(\"-%c\\n\", c);\n\n        /*\n        char buffer[3];\n        buffer[0] = '-';\n        buffer[1] = c;\n        buffer[2] = '\\0';\n        int err = body_record(body, buffer);\n        if(err){perror(\"body_record failed\");}\n        */\n    }\n}\n\nint body_get_key_i(body_t *body, char c, bool absolute){\n    int key_i =\n        c == 'x'? KEYINFO_KEY_ACTION1:\n        c == 'y'? KEYINFO_KEY_ACTION2:\n        c == 'u'? KEYINFO_KEY_U:\n        c == 'd'? KEYINFO_KEY_D:\n        c == 'l'? KEYINFO_KEY_L:\n        c == 'r'? KEYINFO_KEY_R:\n        c == 'f'? (!absolute && body->turn? KEYINFO_KEY_L: KEYINFO_KEY_R):\n        c == 'b'? (!absolute && body->turn? KEYINFO_KEY_R: KEYINFO_KEY_L):\n        -1;\n    return key_i;\n}\n\nchar body_get_key_c(body_t *body, int key_i, bool absolute){\n    return\n        key_i == KEYINFO_KEY_ACTION1? 'x':\n        key_i == KEYINFO_KEY_ACTION2? 'y':\n        key_i == KEYINFO_KEY_U? 'u':\n        key_i == KEYINFO_KEY_D? 'd':\n        key_i == KEYINFO_KEY_L? (absolute? 'l': body->turn? 'f': 'b'):\n        key_i == KEYINFO_KEY_R? (absolute? 'r': body->turn? 'b': 'f'):\n        ' ';\n}\n\n\n/**************\n * BODY RULES *\n **************/\n\nstatic int body_match_rule(body_t *body,\n    actor_t *actor, hexgame_t *game,\n    state_rule_t *rule, bool *rule_matched_ptr\n){\n\n    /* NOTE: body and/or actor may be NULL.\n    We are basically reusing the rule/cond/effect structure for bodys\n    and actors; most conds/effects naturally apply to one or the other.\n    E.g. keypress stuff is for the body; \"play\" is for actor.\n    However, actor may want to check some stuff about the body, so\n    it may make use of \"body-oriented\" rules. */\n\n    bool rule_matched = true;\n    for(int i = 0; i < rule->conds_len; i++){\n        state_cond_t *cond = rule->conds[i];\n        if(DEBUG_RULES)printf(\"  if: %s\\n\", cond->type);\n\n        #define RULE_PERROR() \\\n            fprintf(stderr, \" (cond=%s, state=%s, stateset=%s)\\n\", \\\n                cond->type, rule->state->name, \\\n                rule->state->stateset->filename);\n\n        if(cond->type == state_cond_type_false){\n            rule_matched = false;\n        }else if(cond->type == state_cond_type_key){\n            if(body == NULL){\n                fprintf(stderr, \"No body\");\n                RULE_PERROR()\n                break;}\n\n            int kstate_i = cond->u.key.kstate;\n            bool *kstate =\n                kstate_i == 0? body->keyinfo.isdown:\n                kstate_i == 1? body->keyinfo.wasdown:\n                kstate_i == 2? body->keyinfo.wentdown:\n                NULL;\n            if(kstate == NULL){\n                fprintf(stderr, \"kstate out of range: %i\", kstate_i);\n                RULE_PERROR()\n                return 2;}\n\n            char c = cond->u.key.c;\n            int key_i = body_get_key_i(body, c, false);\n            if(key_i == -1){\n                fprintf(stderr, \"Unrecognized key char: %c\", c);\n                RULE_PERROR()\n                return 2;}\n\n            rule_matched = kstate[key_i];\n            if(!cond->u.key.yes)rule_matched = !rule_matched;\n        }else if(cond->type == state_cond_type_coll){\n            if(body == NULL){\n                fprintf(stderr, \"No body\");\n                RULE_PERROR()\n                break;}\n\n            if(body->state == NULL){\n                rule_matched = false;\n                break;}\n\n            hexmap_t *map = body->map;\n            vecspace_t *space = map->space;\n\n            trf_t hitbox_trf;\n            body_init_trf(body, &hitbox_trf);\n            hexcollmap_t *hitbox = cond->u.coll.collmap;\n\n            int flags = cond->u.coll.flags;\n            bool all = flags & 1;\n            bool yes = flags & 2;\n            bool water = flags & 4;\n            bool against_bodies = flags & 8;\n\n            if(against_bodies){\n                int n_matches = 0;\n                for(int j = 0; j < map->bodies_len; j++){\n                    body_t *body_other = map->bodies[j];\n                    if(body == body_other)continue;\n                    if(body_other->state == NULL)continue;\n                    hexcollmap_t *hitbox_other = body_other->state->hitbox;\n                    if(hitbox_other == NULL)continue;\n\n                    trf_t hitbox_other_trf;\n                    body_init_trf(body_other, &hitbox_other_trf);\n\n                    /* The other body has a hitbox! Do the collision... */\n                    bool collide = hexcollmap_collide(hitbox, &hitbox_trf,\n                        hitbox_other, &hitbox_other_trf, space,\n                        yes? all: !all);\n                    if(yes? collide: !collide)n_matches++;\n                }\n                rule_matched = n_matches > 0;\n            }else if(water){\n                hexmap_submap_t *collide_savepoint = NULL;\n                hexmap_submap_t *collide_door = NULL;\n                hexmap_submap_t *collide_water = NULL;\n                hexmap_collide_special(map, hitbox, &hitbox_trf,\n                    &collide_savepoint, &collide_door, &collide_water);\n                bool collide = collide_water != NULL;\n                rule_matched = yes? collide: !collide;\n            }else{\n                bool collide = hexmap_collide(map,\n                    hitbox, &hitbox_trf, yes? all: !all);\n                rule_matched = yes? collide: !collide;\n            }\n        }else{\n            fprintf(stderr, \"Unrecognized state rule condition: %s\",\n                cond->type);\n            RULE_PERROR()\n            return 2;\n        }\n        if(!rule_matched)break;\n        #undef RULE_PERROR\n    }\n\n    if(DEBUG_RULES && !rule_matched)printf(\"    NO MATCH\\n\");\n\n    *rule_matched_ptr = rule_matched;\n    return 0;\n}\n\nstatic int body_apply_rule(body_t *body,\n    actor_t *actor, hexgame_t *game,\n    state_rule_t *rule, state_effect_goto_t **gotto_ptr\n){\n    int err;\n\n    /* NOTE: body and/or actor may be NULL.\n    See comment on body_match_rule. */\n\n    for(int i = 0; i < rule->effects_len; i++){\n        state_effect_t *effect = rule->effects[i];\n        if(DEBUG_RULES)printf(\"  then: %s\\n\", effect->type);\n\n        #define RULE_PERROR() \\\n            fprintf(stderr, \" (effect=%s, state=%s, stateset=%s)\\n\", \\\n                effect->type, rule->state->name, \\\n                rule->state->stateset->filename);\n\n        if(effect->type == state_effect_type_print){\n            if(body != NULL)printf(\"body %p\", body);\n            else printf(\"unknown body\");\n            if(actor != NULL)printf(\" (actor %p)\", actor);\n            printf(\" says: %s\\n\", effect->u.msg);\n        }else if(effect->type == state_effect_type_move){\n            if(body == NULL){\n                fprintf(stderr, \"No body\");\n                RULE_PERROR()\n                break;}\n\n            vecspace_t *space = body->map->space;\n            vec_t vec;\n            vec_cpy(space->dims, vec, effect->u.vec);\n            rot_t rot = body_get_rot(body);\n            space->vec_flip(vec, body->turn);\n            space->vec_rot(vec, rot);\n            vec_add(space->dims, body->pos, vec);\n        }else if(effect->type == state_effect_type_rot){\n            if(body == NULL){\n                fprintf(stderr, \"No body\");\n                RULE_PERROR()\n                break;}\n\n            vecspace_t *space = body->map->space;\n            rot_t effect_rot = effect->u.rot;\n            body->rot = rot_rot(space->rot_max,\n                body->rot, effect_rot);\n        }else if(effect->type == state_effect_type_turn){\n            if(body == NULL){\n                fprintf(stderr, \"No body\");\n                RULE_PERROR()\n                break;}\n\n            vecspace_t *space = body->map->space;\n            body->turn = !body->turn;\n            body->rot = rot_flip(space->rot_max, body->rot, true);\n        }else if(effect->type == state_effect_type_goto){\n            *gotto_ptr = &effect->u.gotto;\n        }else if(effect->type == state_effect_type_delay){\n            if(body == NULL){\n                fprintf(stderr, \"No body\");\n                RULE_PERROR()\n                break;}\n            body->cooldown = effect->u.delay;\n        }else if(effect->type == state_effect_type_action){\n            const char *action_name = effect->u.action_name;\n            if(!strcmp(action_name, \"ping\")){\n                fprintf(stderr, \"pong\\n\");\n            }else if(\n                !strcmp(action_name, \"spit\") ||\n                !strcmp(action_name, \"spit_crouch\") ||\n                !strcmp(action_name, \"spit_up\")\n            ){\n                if(body == NULL){\n                    fprintf(stderr, \"No body\");\n                    RULE_PERROR()\n                    break;}\n                bool crouch = action_name[4] == '_' && action_name[5] == 'c';\n                bool up = action_name[4] == '_' && action_name[5] == 'u';\n\n                vec_t addpos = {0, 0};\n                if(up)addpos[0] = 1;\n                rot_t addrot = up? 1: 0;\n                bool turn = false;\n\n                body_t *new_body;\n                err = body_add_body(body, &new_body, \"anim/spit.fus\",\n                    crouch? \"crouch_fly\": \"fly\", NULL,\n                    addpos, addrot, turn);\n                if(err)return err;\n            }else{\n                fprintf(stderr, \"Unrecognized action: %s\\n\",\n                    action_name);\n                return 2;\n            }\n        }else if(effect->type == state_effect_type_play){\n            if(actor == NULL){\n                fprintf(stderr, \"No actor\");\n                RULE_PERROR()\n                break;}\n            const char *play_filename = effect->u.play_filename;\n            err = body_load_recording(body, play_filename, false);\n            if(err)return err;\n            err = body_play_recording(body);\n            if(err)return err;\n        }else if(effect->type == state_effect_type_die){\n            if(body == NULL){\n                fprintf(stderr, \"No body\");\n                RULE_PERROR()\n                break;}\n            body->dead = effect->u.dead;\n        }else{\n            fprintf(stderr, \"Unrecognized state rule effect: %s\\n\",\n                effect->type);\n            return 2;\n        }\n        #undef RULE_PERROR\n    }\n    return 0;\n}\n\nint state_handle_rules(state_t *state, body_t *body,\n    actor_t *actor, hexgame_t *game, state_effect_goto_t **gotto_ptr\n){\n    int err;\n\n    for(int i = 0; i < state->rules_len; i++){\n        state_rule_t *rule = state->rules[i];\n\n        if(DEBUG_RULES){printf(\"body %p, actor %p, rule %i:\\n\",\n            body, actor, i);}\n\n        bool rule_matched;\n        err = body_match_rule(body, actor, game, rule,\n            &rule_matched);\n        if(err)return err;\n\n        if(rule_matched){\n            err = body_apply_rule(body, actor, game, rule,\n                gotto_ptr);\n            if(err)return err;\n            break;\n        }\n    }\n\n    return 0;\n}\n\n\n\n/*************\n * BODY STEP *\n *************/\n\nvoid body_update_cur_submap(body_t *body){\n    /* Sets body->cur_submap, body->out_of_bounds by colliding body\n    against body->map */\n\n    hexmap_t *map = body->map;\n    vecspace_t *space = map->space;\n\n    hexmap_submap_t *new_submap = NULL;\n\n    /* Check if body's pos is touching a vert of any submap */\n    bool out_of_bounds = true;\n    for(int i = 0; i < map->submaps_len; i++){\n        hexmap_submap_t *submap = map->submaps[i];\n        if(!submap->solid)continue;\n\n        hexcollmap_t *collmap = &submap->collmap;\n\n        /* A HACK! */\n        trf_t index = {0};\n        hexspace_set(index.add,\n             body->pos[0] - submap->pos[0],\n            -body->pos[1] + submap->pos[1]);\n\n        hexcollmap_elem_t *vert =\n            hexcollmap_get_vert(collmap, &index);\n        if(vert != NULL)out_of_bounds = false;\n        if(hexcollmap_elem_is_solid(vert)){\n            new_submap = submap;\n            break;\n        }\n    }\n    body->out_of_bounds = out_of_bounds;\n\n    if(new_submap == NULL){\n        /* Check if body's hitbox is touching the water face of\n        any submap */\n\n        hexcollmap_t *hitbox = body->state? body->state->hitbox: NULL;\n        if(hitbox != NULL){\n            trf_t hitbox_trf;\n            body_init_trf(body, &hitbox_trf);\n\n            hexmap_submap_t *collide_savepoint = NULL;\n            hexmap_submap_t *collide_door = NULL;\n            hexmap_submap_t *collide_water = NULL;\n            hexmap_collide_special(map, hitbox, &hitbox_trf,\n                &collide_savepoint, &collide_door, &collide_water);\n\n            if(collide_water)new_submap = collide_water;\n        }\n    }\n\n    if(new_submap != NULL)body->cur_submap = new_submap;\n}\n\nint body_step(body_t *body, hexgame_t *game){\n    int err;\n\n    if(body->state == NULL){\n        return 0;}\n\n    hexmap_t *map = body->map;\n    vecspace_t *space = map->space;\n\n    /* Handle recording & playback */\n    int rec_action = body->recording.action;\n    if(rec_action == 1){\n        /* play */\n        if(body->recording.data != NULL){\n            err = recording_step(&body->recording);\n            if(err)return err;\n        }\n    }else if(rec_action == 2){\n        /* record */\n        body->recording.wait++;\n    }\n    if(rec_action != 0 && DEBUG_RECORDINGS){\n        printf(\"KEYS: \");\n        #define DEBUG_PRINT_KEYS(keys) { \\\n            printf(\"[\"); \\\n            for(int i = 0; i < KEYINFO_KEYS; i++)printf(\"%i\", keys[i]); \\\n            printf(\"]\"); \\\n        }\n        DEBUG_PRINT_KEYS(body->keyinfo.isdown)\n        DEBUG_PRINT_KEYS(body->keyinfo.wasdown)\n        DEBUG_PRINT_KEYS(body->keyinfo.wentdown)\n        #undef DEBUG_PRINT_KEYS\n        printf(\"\\n\");\n    }\n\n    /* Increment frame */\n    body->frame_i++;\n    if(body->frame_i == MAX_FRAME_I)body->frame_i = 0;\n\n    /* Handle animation & input */\n    if(body->cooldown > 0){\n        body->cooldown--;\n    }else{\n        /* Handle current state's rules */\n        handle: {\n            state_effect_goto_t *gotto = NULL;\n            err = state_handle_rules(body->state, body, NULL, game,\n                &gotto);\n            if(err)return err;\n            if(gotto != NULL){\n                err = body_set_state(body, gotto->name, false);\n                if(err)return err;\n\n                if(gotto->immediate)goto handle;\n                    /* If there was an \"immediate goto\" effect,\n                    then we immediately handle the new state's rules */\n            }\n        }\n\n        /* Start of new frame, no keys have gone down yet.\n        Note this only happens after cooldown is finished, which allows\n        for simple \"buffering\" of keypresses. */\n        for(int i = 0; i < KEYINFO_KEYS; i++){\n            body->keyinfo.wasdown[i] = body->keyinfo.isdown[i];\n            body->keyinfo.wentdown[i] = false;}\n    }\n\n    /* Figure out current submap */\n    body_update_cur_submap(body);\n\n    return 0;\n}\n\nint body_collide_against_body(body_t *body, body_t *body_other){\n    int err;\n    bool crushed = body_other->state->crushes;\n    bool collected =\n        body->stateset.is_collectible &&\n        !body_other->stateset.is_collectible;\n    if(crushed || collected){\n        /* Bodies whose recording is playing cannot die */\n        /* MAYBE TODO: These bodies should die too, but then their\n        recording should restart after a brief pause?\n        Maybe we can reuse body->cooldown for the pause. */\n        if(body->recording.action != 1){\n            /* Hardcoded \"dead\" state name... I suppose we could\n            have a char* body->dead_anim_name or something, but whatever.\n            We more or less expect this \"dead\" state to, for instance,\n            cause the body to die. Maybe after exploding or whatever. */\n            err = body_set_state(body, \"dead\", true);\n            if(err)return err;\n        }\n    }\n    return 0;\n}\n\n\n/***************\n * BODY RENDER *\n ***************/\n\nint body_render(body_t *body,\n    SDL_Renderer *renderer, SDL_Surface *surface,\n    SDL_Palette *pal, int x0, int y0, int zoom,\n    hexmap_t *map, vec_t camera_renderpos, prismelmapper_t *mapper\n){\n    int err;\n\n    if(body->state == NULL)return 0;\n\n    rendergraph_t *rgraph = body->state->rgraph;\n    if(rgraph == NULL)return 0;\n\n    prismelrenderer_t *prend = map->prend;\n    vecspace_t *space = map->space;\n\n    if(body->palmapper){\n        err = palettemapper_apply_to_rendergraph(body->palmapper,\n            prend, rgraph, NULL, space, &rgraph);\n        if(err)return err;\n    }\n\n    vec_t pos;\n    vec4_vec_from_hexspace(pos, body->pos);\n    vec_sub(rgraph->space->dims, pos, camera_renderpos);\n    vec_mul(rgraph->space, pos, map->unit);\n\n    rot_t body_rot = body_get_rot(body);\n    rot_t rot = vec4_rot_from_hexspace(body_rot);\n    flip_t flip = body->turn;\n    int frame_i = body->frame_i;\n\n    err = rendergraph_render(rgraph, renderer, surface,\n        pal, prend,\n        x0, y0, zoom,\n        pos, rot, flip, frame_i, mapper);\n    if(err)return err;\n\n    return 0;\n}\n\n","\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#include \"hexgame.h\"\n#include \"anim.h\"\n#include \"hexmap.h\"\n#include \"hexspace.h\"\n#include \"prismelrenderer.h\"\n#include \"array.h\"\n#include \"util.h\"\n#include \"write.h\"\n\n\n\n\nvoid player_cleanup(player_t *player){\n    location_cleanup(&player->respawn_location);\n    location_cleanup(&player->safe_location);\n}\n\nint player_init(player_t *player, body_t *body, int keymap,\n    vec_t respawn_pos, rot_t respawn_rot, bool respawn_turn,\n    char *respawn_map_filename, char *respawn_filename\n){\n    int err;\n    hexgame_t *game = body->game;\n\n    player->body = body;\n    player->keymap = keymap;\n\n    for(int i = 0; i < KEYINFO_KEYS; i++)player->key_code[i] = 0;\n    if(keymap == 0){\n        player->key_code[KEYINFO_KEY_ACTION1] = SDLK_LSHIFT;\n        player->key_code[KEYINFO_KEY_ACTION2] = SDLK_SPACE;\n        player->key_code[KEYINFO_KEY_U] = SDLK_UP;\n        player->key_code[KEYINFO_KEY_D] = SDLK_DOWN;\n        player->key_code[KEYINFO_KEY_L] = SDLK_LEFT;\n        player->key_code[KEYINFO_KEY_R] = SDLK_RIGHT;\n    }else if(keymap == 1){\n        player->key_code[KEYINFO_KEY_ACTION1] = SDLK_f;\n        player->key_code[KEYINFO_KEY_ACTION2] = SDLK_g;\n        player->key_code[KEYINFO_KEY_U] = SDLK_w;\n        player->key_code[KEYINFO_KEY_D] = SDLK_s;\n        player->key_code[KEYINFO_KEY_L] = SDLK_a;\n        player->key_code[KEYINFO_KEY_R] = SDLK_d;\n    }\n\n    hexmap_t *map;\n    err = hexgame_get_or_load_map(game, respawn_map_filename, &map);\n    if(err)return err;\n    vecspace_t *space = map->space;\n    if(respawn_pos == NULL)respawn_pos = map->spawn;\n\n    location_init(&player->respawn_location);\n    location_set(&player->respawn_location, space,\n        respawn_pos, respawn_rot, respawn_turn, respawn_map_filename);\n\n    /* Locations own their map filenames, so need to strdup */\n    char *jump_map_filename = strdup(respawn_map_filename);\n\n    location_init(&player->safe_location);\n    location_set(&player->safe_location, space,\n        respawn_pos, respawn_rot, respawn_turn, jump_map_filename);\n\n    player->respawn_filename = respawn_filename;\n\n    /* Move player's body to the respawn location */\n    err = body_respawn(body, respawn_pos, respawn_rot, respawn_turn, map);\n    if(err)return err;\n\n    return 0;\n}\n\nstatic int _player_set_location(player_t *player, location_t *location,\n    vec_ptr_t pos, rot_t rot, bool turn, const char *map_filename\n){\n    hexgame_t *game = player->body->game;\n    vecspace_t *space = game->space;\n\n    /* Only assign new map_filename if it compares as different to\n    the old one */\n    char *new_map_filename = location->map_filename;\n    if(strcmp(location->map_filename, map_filename)){\n        new_map_filename = strdup(map_filename);\n        if(!new_map_filename){\n            perror(\"strdup\");\n            return 1;\n        }\n    }\n\n    location_set(location, space, pos, rot, turn, new_map_filename);\n    return 0;\n}\n\nint player_set_respawn(player_t *player,\n    vec_ptr_t pos, rot_t rot, bool turn, const char *map_filename\n){\n    return _player_set_location(player, &player->respawn_location,\n        pos, rot, turn, map_filename);\n}\n\nint player_set_safe_location(player_t *player,\n    vec_ptr_t pos, rot_t rot, bool turn, const char *map_filename\n){\n    return _player_set_location(player, &player->safe_location,\n        pos, rot, turn, map_filename);\n}\n\nint player_respawn_save(const char *filename, vec_t pos,\n    rot_t rot, bool turn, const char *map_filename\n){\n    FILE *f = fopen(filename, \"w\");\n    if(f == NULL){\n        fprintf(stderr, \"Couldn't save player to %s: \", filename);\n        perror(NULL);\n        return 2;\n    }\n    fprintf(f, \"%i %i %i %c \", pos[0], pos[1], rot, turn? 'y': 'n');\n    fus_write_str(f, map_filename);\n    fclose(f);\n    return 0;\n}\n\nint player_respawn_load(const char *filename, vec_t pos,\n    rot_t *rot_ptr, bool *turn_ptr, char **map_filename_ptr\n){\n    int err = 0;\n\n    char *text = load_file(filename);\n    if(text == NULL){\n        fprintf(stderr, \"Couldn't load player from %s: \", filename);\n        return 2;\n    }\n\n    fus_lexer_t lexer;\n    err = fus_lexer_init(&lexer, text, filename);\n    if(err)return err;\n\n    int x, y;\n    rot_t rot;\n    bool turn;\n    char *map_filename;\n\n    err = fus_lexer_get_int(&lexer, &x);\n    if(err)goto err;\n    err = fus_lexer_get_int(&lexer, &y);\n    if(err)goto err;\n    err = fus_lexer_get_int(&lexer, &rot);\n    if(err)goto err;\n    err = fus_lexer_get_yesno(&lexer, &turn);\n    if(err)goto err;\n    err = fus_lexer_get_str(&lexer, &map_filename);\n    if(err)goto err;\n\n    pos[0] = x;\n    pos[1] = y;\n    *rot_ptr = rot;\n    *turn_ptr = turn;\n    *map_filename_ptr = map_filename;\n\nerr:\n    fus_lexer_cleanup(&lexer);\n    free(text);\n    return err;\n}\n\n\nint player_process_event(player_t *player, SDL_Event *event){\n    body_t *body = player->body;\n    if(event->type == SDL_KEYDOWN || event->type == SDL_KEYUP){\n        if(!event->key.repeat){\n            for(int i = 0; i < KEYINFO_KEYS; i++){\n                if(event->key.keysym.sym == player->key_code[i]){\n                    if(event->type == SDL_KEYDOWN){\n                        body_keydown(body, i);\n                    }else{\n                        body_keyup(body, i);\n                    }\n                }\n            }\n        }\n    }\n    return 0;\n}\n\n\n\nint player_step(player_t *player, hexgame_t *game){\n    int err;\n\n    body_t *body = player->body;\n\n    /* Respawn body if player hit the right key while dead */\n    if(body && body->dead && body->keyinfo.wasdown[KEYINFO_KEY_U]){\n        /* Soft reset */\n        int reset_level =\n            body->dead == BODY_ALL_DEAD? RESET_SOFT: RESET_TO_SAFETY;\n        hexgame_reset_player(game, player, reset_level);\n\n        /* Player may have gotten a new body object */\n        body = player->body;\n    }\n\n    if(body->state == NULL){\n        return 0;}\n\n    hexmap_t *map = body->map;\n    vecspace_t *space = map->space;\n\n    if(body->state->safe){\n        /* We're safe (e.g. not jumping), so update our jump location\n        (where we'll be respawned if we do jump and hit something) */\n        err = player_set_safe_location(player, body->pos, body->rot,\n            body->turn, map->name);\n        if(err)return err;\n    }\n\n    /* Collide body against map, looking for special tiles like\n    savepoints & doors */\n    hexcollmap_t *hitbox = body->state->hitbox;\n    if(hitbox != NULL){\n        trf_t hitbox_trf;\n        body_init_trf(body, &hitbox_trf);\n\n        hexmap_submap_t *collide_savepoint = NULL;\n        hexmap_submap_t *collide_door = NULL;\n        hexmap_submap_t *collide_water = NULL;\n        hexmap_collide_special(map, hitbox, &hitbox_trf,\n            &collide_savepoint, &collide_door, &collide_water);\n\n        /* A SERIES OF WILD HACKS FOLLOW\n        TODO: Replace them with The Real Thing, whatever that should be */\n        if(collide_savepoint || collide_door){\n            bool standing_flat = body->rot == 0;\n\n            /* HACK so you can use doors as a roller...\n            Often it looks like you have rot == 0 when it's really 2.\n            NOTE: If you save with rot == 2 as a roller, and then respawn\n            as a spider, you'll probably be in some weird position.\n            TODO: Fix whatever needs to be fixed so we don't need this hack */\n            if(!strcmp(body->stateset.filename, \"anim/roller.fus\")){\n                standing_flat = body->rot == 0 || body->rot == 2;\n            }\n\n            if(!standing_flat){\n                collide_savepoint = false;\n                collide_door = false;\n            }else{\n                /* HACK: Only spiders can use savepoints */\n                if(strcmp(body->stateset.filename, \"anim/player.fus\")){\n                    collide_savepoint = false;}\n            }\n        }\n\n        if(collide_savepoint){\n            /* Don't use the savepoint if it's already our respawn point!\n            In particular, I want to avoid screen flashing white if e.g.\n            player turns around in-place.\n            The reason we can't just check equality of body->pos and\n            player->respawn_location.pos is that turning around actually affects\n            body's pos (moves it by 1). */\n            int dist = hexspace_dist(body->pos, player->respawn_location.pos);\n            bool at_respawn = dist <= 1;\n\n            if(!at_respawn){\n                /* We're not at previous respawn location, so update it */\n                err = player_set_respawn(player, body->pos, body->rot,\n                    body->turn, map->name);\n                if(err)return err;\n\n                /* Save player's new respawn location */\n                if(player->respawn_filename != NULL){\n                    err = player_respawn_save(player->respawn_filename,\n                        player->respawn_location.pos, player->respawn_location.rot,\n                        player->respawn_location.turn,\n                        player->respawn_location.map_filename);\n                    if(err)return err;\n                }\n\n                /* Flash screen white so player knows something happened */\n                body_flash_cameras(body, 255, 255, 255, 30);\n            }\n        }\n\n        if(collide_door){\n            hexmap_submap_t *cur_submap = collide_door;\n            const char *door_map_filename = cur_submap->door_map_filename;\n            const char *door_anim_filename = cur_submap->door_anim_filename;\n\n            if(door_map_filename || door_anim_filename){\n                hexmap_t *new_map = body->map;\n                if(door_map_filename != NULL){\n                    /* Switch map */\n                    err = hexgame_get_or_load_map(game,\n                        cur_submap->door_map_filename, &new_map);\n                    if(err)return err;\n                }\n\n                err = body_respawn(body, cur_submap->door_pos,\n                    cur_submap->door_rot, cur_submap->door_turn,\n                    new_map);\n                if(err)return err;\n\n                if(door_anim_filename != NULL){\n                    /* Switch anim (stateset) */\n\n                    /* HACK: If you've become something other than a spider,\n                    anim-changing doors change you back into a spider. */\n                    if(strcmp(body->stateset.filename, \"anim/player.fus\")){\n                        door_anim_filename = \"anim/player.fus\";\n                    }\n\n                    err = body_set_stateset(body, door_anim_filename, NULL);\n                    if(err)return err;\n                }\n\n                /* Flash screen cyan so player knows something happened */\n                body_flash_cameras(body, 0, 255, 255, 60);\n                body_reset_cameras(body);\n            }\n        }\n    }\n\n    return 0;\n}\n\n","\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#include \"hexgame.h\"\n#include \"anim.h\"\n#include \"hexmap.h\"\n#include \"hexspace.h\"\n#include \"prismelrenderer.h\"\n#include \"array.h\"\n#include \"util.h\"\n#include \"write.h\"\n\n\n\n/*************\n * RECORDING *\n *************/\n\nvoid recording_cleanup(recording_t *rec){\n    free(rec->data);\n    free(rec->name);\n    free(rec->stateset_name);\n    free(rec->state_name);\n    if(rec->file != NULL)fclose(rec->file);\n}\n\nvoid recording_reset(recording_t *rec){\n    recording_cleanup(rec);\n\n    rec->action = 0; /* none */\n    rec->data = NULL;\n    rec->stateset_name = NULL;\n    rec->state_name = NULL;\n\n    vec_zero(rec->pos0);\n    rec->rot0 = 0;\n    rec->turn0 = false;\n\n    keyinfo_reset(&rec->keyinfo);\n\n    rec->i = 0;\n    rec->size = 0;\n    rec->wait = 0;\n    rec->name = NULL;\n    rec->file = NULL;\n    rec->offset = 0;\n}\n\nvoid recording_init(recording_t *rec, body_t *body,\n    bool loop\n){\n    rec->body = body;\n    rec->loop = loop;\n}\n\nstatic int recording_parse(recording_t *rec,\n    fus_lexer_t *lexer, const char *filename\n){\n    int err;\n\n    hexmap_t *map = rec->body->map;\n    vecspace_t *space = map->space;\n\n    err = fus_lexer_get(lexer, \"anim\");\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n    err = fus_lexer_get_str(lexer, &rec->stateset_name);\n    if(err)return err;\n    err = fus_lexer_get(lexer, \")\");\n    if(err)return err;\n\n    err = fus_lexer_get(lexer, \"state\");\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n    err = fus_lexer_get_str(lexer, &rec->state_name);\n    if(err)return err;\n    err = fus_lexer_get(lexer, \")\");\n    if(err)return err;\n\n    err = fus_lexer_get(lexer, \"pos\");\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n    err = fus_lexer_get_vec(lexer, space, rec->pos0);\n    if(err)return err;\n    err = fus_lexer_get(lexer, \")\");\n    if(err)return err;\n\n    err = fus_lexer_get(lexer, \"rot\");\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n    err = fus_lexer_get_int(lexer, &rec->rot0);\n    if(err)return err;\n    err = fus_lexer_get(lexer, \")\");\n    if(err)return err;\n\n    err = fus_lexer_get(lexer, \"turn\");\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n    if(fus_lexer_got(lexer, \"yes\")){\n        rec->turn0 = true;\n    }else if(fus_lexer_got(lexer, \"no\")){\n        rec->turn0 = false;\n    }else{\n        return fus_lexer_unexpected(lexer, \"yes or no\");\n    }\n    err = fus_lexer_next(lexer);\n    if(err)return err;\n    err = fus_lexer_get(lexer, \")\");\n    if(err)return err;\n\n    if(fus_lexer_got(lexer, \"offset\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n        err = fus_lexer_get_int(lexer, &rec->offset);\n        if(err)return err;\n        err = fus_lexer_get(lexer, \")\");\n        if(err)return err;\n    }\n\n    if(fus_lexer_got(lexer, \"keys\")){\n        err = fus_lexer_next(lexer);\n        if(err)return err;\n        err = fus_lexer_get_keyinfo(lexer, &rec->keyinfo);\n        if(err)return err;\n    }\n\n    err = fus_lexer_get(lexer, \"data\");\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n    err = fus_lexer_get_str(lexer, &rec->data);\n    if(err)return err;\n    err = fus_lexer_get(lexer, \")\");\n    if(err)return err;\n\n    return 0;\n}\n\nint recording_load(recording_t *rec, const char *filename,\n    body_t *body, bool loop\n){\n    int err;\n    fus_lexer_t lexer;\n\n    char *text = load_file(filename);\n    if(text == NULL)return 1;\n\n    err = fus_lexer_init(&lexer, text, filename);\n    if(err)return err;\n\n    recording_init(rec, body, loop);\n    err = recording_parse(rec, &lexer, filename);\n    if(err)return err;\n\n    free(text);\n    return 0;\n}\n\nstatic const char *get_recording_filename(int n){\n    /* NOT REENTRANT, FORGIVE MEEE :( */\n    static char recording_filename[200] = \"data/rec000.fus\";\n    static const int zeros_pos = 8;\n    static const int n_zeros = 3;\n    for(int i = 0; i < n_zeros; i++){\n        int rem = n % 10;\n        n = n / 10;\n        recording_filename[zeros_pos + n_zeros - 1 - i] = '0' + rem;\n    }\n    return recording_filename;\n}\n\nstatic const char *get_last_or_next_recording_filename(bool next){\n    const char *recording_filename;\n    int n = 0;\n    while(1){\n        recording_filename = get_recording_filename(n);\n        FILE *f = fopen(recording_filename, \"r\");\n        if(f == NULL)break;\n        n++;\n    }\n    if(!next){\n        if(n == 0)return NULL;\n        recording_filename = get_recording_filename(n-1);\n    }\n    return recording_filename;\n}\n\nconst char *get_last_recording_filename(){\n    return get_last_or_next_recording_filename(false);\n}\n\nconst char *get_next_recording_filename(){\n    return get_last_or_next_recording_filename(true);\n}\n\n\n\n/******************\n * BODY RECORDING *\n ******************/\n\nint body_load_recording(body_t *body, const char *filename, bool loop){\n    int err;\n    recording_t *rec = &body->recording;\n\n    recording_reset(rec);\n    err = recording_load(rec, filename, body, loop);\n    if(err)return err;\n    return 0;\n}\n\nint body_play_recording(body_t *body){\n    int err;\n    recording_t *rec = &body->recording;\n\n    err = body_init_stateset(body, rec->stateset_name, rec->state_name);\n    if(err)return err;\n\n    body->recording.action = 1; /* play */\n    return body_restart_recording(body, false);\n}\n\nint body_restart_recording(body_t *body, bool hard){\n    int err;\n    recording_t *rec = &body->recording;\n\n    rec->i = 0;\n    rec->wait = 0;\n\n    keyinfo_copy(&body->keyinfo, &rec->keyinfo);\n    body_set_state(body, rec->state_name, true);\n\n    vec_cpy(MAX_VEC_DIMS, body->pos, rec->pos0);\n    body->rot = rec->rot0;\n    body->turn = rec->turn0;\n\n    if(!hard){\n        for(int i = 0; i < rec->offset; i++){\n            body_step(body, body->game);\n        }\n    }\n\n    return 0;\n}\n\nint body_start_recording(body_t *body, char *name){\n\n    FILE *f = fopen(name, \"w\");\n    if(f == NULL){\n        perror(\"Couldn't start recording\");\n        return 2;}\n\n    recording_reset(&body->recording);\n    body->recording.action = 2; /* record */\n    body->recording.name = name;\n    body->recording.file = f;\n\n    fprintf(f, \"anim: \");\n    fus_write_str(f, body->stateset.filename);\n    fprintf(f, \"\\n\");\n\n    fprintf(f, \"state: \");\n    fus_write_str(f, body->state->name);\n    fprintf(f, \"\\n\");\n\n    fprintf(f, \"pos: (\");\n    for(int i = 0; i < hexspace.dims; i++){\n        fprintf(f, \" %i\", body->pos[i]);\n    }\n    fprintf(f, \")\\n\");\n\n    fprintf(f, \"rot: %i\\n\", body->rot);\n    fprintf(f, \"turn: %s\\n\", body->turn? \"yes\": \"no\");\n\n    fprintf(f, \"keys:\\n\");\n    for(int i = 0; i < KEYINFO_KEYS; i++){\n        char key_c = body_get_key_c(body, i, true);\n        fprintf(f, \"    %c:\", key_c);\n        if(body->keyinfo.isdown[i])fprintf(f, \" is\");\n        if(body->keyinfo.wasdown[i])fprintf(f, \" was\");\n        if(body->keyinfo.wentdown[i])fprintf(f, \" went\");\n        fprintf(f, \"\\n\");\n    }\n\n    fprintf(f, \"data: \\\"\");\n\n    return 0;\n}\n\nint body_stop_recording(body_t *body){\n    int err;\n\n    FILE *f = body->recording.file;\n    if(f == NULL)return 2;\n\n    err = body_maybe_record_wait(body);\n    if(err)return err;\n\n    fprintf(f, \"\\\"\\n\");\n\n    recording_reset(&body->recording);\n    return 0;\n}\n\nint body_record(body_t *body, const char *data){\n    /* CURRENTLY UNUSED!.. we write directly to file instead. */\n\n    int data_len = strlen(data);\n    int required_size = body->recording.i + data_len + 1;\n\n    if(DEBUG_RECORDINGS){\n        printf(\"RECORD: data=%s, len=%i, req=%i\\n\",\n            data, data_len, required_size);}\n\n    if(required_size >= body->recording.size){\n        int new_size = required_size + 200;\n        char *new_recording = realloc(body->recording.data,\n            sizeof(char) * new_size);\n        if(new_recording == NULL)return 1;\n        new_recording[new_size - 1] = '\\0';\n        body->recording.data = new_recording;\n        body->recording.size = new_size;\n        if(DEBUG_RECORDINGS)printf(\"  REALLOC: new_size=%i\\n\", new_size);\n    }\n    strcpy(body->recording.data + body->recording.i, data);\n    body->recording.i += data_len;\n\n    if(DEBUG_RECORDINGS){\n        printf(\"  OK! i=%i, data=%s\\n\",\n            body->recording.i, body->recording.data);}\n\n    return 0;\n}\n\nint body_maybe_record_wait(body_t *body){\n    int wait = body->recording.wait;\n    if(wait == 0)goto ok;\n\n    fprintf(body->recording.file, \" w%i\", wait);\n    if(DEBUG_RECORDINGS)printf(\"w%i\\n\", wait);\n\n    /*\n    char buffer[4];\n    buffer[0] = ' ';\n    buffer[1] = 'w';\n    buffer[2] = '1'; // <---- ummmmm\n    buffer[3] = '\\0';\n\n    int err = body_record(body, buffer);\n    if(err){perror(\"body_record failed\");}\n    */\n\n    body->recording.wait = 0;\nok:\n    return 0;\n}\n\nint recording_step(recording_t *rec){\n    int err;\n\n    body_t *body = rec->body;\n\n    if(rec->wait > 0){\n        rec->wait--;\n        if(rec->wait > 0)return 0;}\n\n    char *data = rec->data;\n    int i = rec->i;\n    char c;\n\n    bool loop = rec->loop;\n\n    while(1){\n        while(data[i] == ' ')i++;\n\n        c = data[i];\n        if(c == '+' || c == '-'){\n            bool keydown = c == '+';\n            char key_c = data[i+1]; i += 2;\n            if(DEBUG_RECORDINGS)printf(\"%c%c\\n\", c, key_c);\n            int key_i = body_get_key_i(body, key_c, false);\n            if(keydown)body_keydown(body, key_i);\n            else body_keyup(body, key_i);\n        }else if(c == 'w'){\n            i++; int wait = atoi(data + i);\n            if(DEBUG_RECORDINGS)printf(\"w%i\\n\", wait);\n            while(isdigit(data[i]))i++;\n            rec->wait = wait;\n            break;\n        }else if(c == '\\0'){\n            if(loop){\n                /* loop! */\n                err = body_restart_recording(body, true);\n                if(err)return err;\n                i = 0;\n            }else{\n                break;\n            }\n        }else{\n            fprintf(stderr, \"Unrecognized action: %c\\n\", c);\n            fprintf(stderr, \"  ...in position %i of recording: %s\\n\",\n                i, rec->data);\n            return 2;\n        }\n    }\n\n    rec->i = i;\n\n    if(!loop && data[i] == '\\0'){\n        recording_reset(rec);\n    }\n\n    return 0;\n}\n\n","\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#include \"hexgame.h\"\n#include \"anim.h\"\n#include \"hexmap.h\"\n#include \"hexspace.h\"\n#include \"prismelrenderer.h\"\n#include \"array.h\"\n#include \"util.h\"\n\n\n\nvoid actor_cleanup(actor_t *actor){\n    stateset_cleanup(&actor->stateset);\n}\n\nint actor_init(actor_t *actor, hexmap_t *map, body_t *body,\n    const char *stateset_filename, const char *state_name\n){\n    int err;\n\n    actor->body = body;\n\n    err = actor_init_stateset(actor, stateset_filename, state_name, map);\n    if(err)return err;\n\n    return 0;\n}\n\n\nint actor_init_stateset(actor_t *actor, const char *stateset_filename,\n    const char *state_name, hexmap_t *map\n){\n    int err;\n\n    err = stateset_load(&actor->stateset, strdup(stateset_filename),\n        map->prend, map->space);\n    if(err)return err;\n\n    if(state_name == NULL){\n        state_name = actor->stateset.states[0]->name;\n    }\n\n    err = actor_set_state(actor, state_name);\n    if(err)return err;\n\n    return 0;\n}\n\nint actor_set_state(actor_t *actor, const char *state_name){\n    if(state_name == NULL){\n        actor->state = NULL;\n    }else{\n        actor->state = stateset_get_state(&actor->stateset, state_name);\n        if(actor->state == NULL){\n            fprintf(stderr, \"Couldn't init actor stateset: \"\n                \"couldn't find state %s in stateset %s\\n\",\n                state_name, actor->stateset.filename);\n            return 2;}\n    }\n    return 0;\n}\n\nint actor_step(actor_t *actor, struct hexgame *game){\n    int err;\n    body_t *body = actor->body;\n    if(body == NULL || body->recording.action == 0){\n        /* No body, or recording not playing */\n\n        /* Handle current state's rules */\n        handle: {\n            state_effect_goto_t *gotto = NULL;\n            err = state_handle_rules(actor->state, body, actor, game,\n                &gotto);\n            if(err)return err;\n            if(gotto != NULL){\n                err = actor_set_state(actor, gotto->name);\n                if(err)return err;\n\n                if(gotto->immediate)goto handle;\n                    /* If there was an \"immediate goto\" effect,\n                    then we immediately handle the new state's rules */\n            }\n        }\n    }\n    return 0;\n}\n","\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <SDL2/SDL.h>\n\n#include \"prismelrenderer.h\"\n#include \"rendergraph.h\"\n#include \"lexer.h\"\n#include \"bounds.h\"\n#include \"util.h\"\n#include \"array.h\"\n#include \"write.h\"\n\n\n/***********\n * GENERAL *\n ***********/\n\nstatic char *_generate_mapped_name(char *mapper_name, char *mappee_name,\n    const char *prefix, const char *separator, const char *suffix\n){\n    int prefix_len = strlen(prefix);\n    int separator_len = strlen(separator);\n    int suffix_len = strlen(suffix);\n    int mapper_name_len = strlen(mapper_name);\n    int mappee_name_len = strlen(mappee_name);\n    int name_len = mapper_name_len + mappee_name_len\n        + prefix_len + separator_len + suffix_len;\n    char *name = malloc(sizeof(*name) * (name_len + 1));\n    if(name == NULL)return NULL;\n\n    char *s = name;\n    strcpy(s, prefix);\n    s += prefix_len;\n    strcpy(s, mapper_name);\n    s += mapper_name_len;\n    strcpy(s, separator);\n    s += separator_len;\n    strcpy(s, mappee_name);\n    s += mappee_name_len;\n    strcpy(s, suffix);\n\n    name[name_len] = '\\0';\n    return name;\n}\n\nchar *generate_mapped_name(char *mapper_name, char *mappee_name){\n    /* Generate a name, e.g. \"<curvy dodeca_sixth>\" */\n    return _generate_mapped_name(mapper_name, mappee_name, \"<\", \" \", \">\");\n}\n\nchar *generate_palmapped_name(char *mapper_name, char *mappee_name){\n    /* Generate a name, e.g. \"<pm:red dodeca_sixth>\" */\n    return _generate_mapped_name(mapper_name, mappee_name, \"<pm:\", \" \", \">\");\n}\n\nchar *generate_indexed_name(char *base_name, int i){\n    /* Generate a name, e.g. \"<shape 6>\" */\n    int base_name_len = strlen(base_name);\n    int i_len = strlen_of_int(i);\n    int name_len = base_name_len + i_len + 3;\n    char *name = malloc(sizeof(*name) * (name_len + 1));\n    if(name == NULL)return NULL;\n    name[0] = '<';\n    strcpy(name + 1, base_name);\n    name[1 + base_name_len] = ' ';\n    strncpy_of_int(name + 1 + base_name_len + 1, i, i_len);\n    name[name_len - 1] = '>';\n    name[name_len] = '\\0';\n    return name;\n}\n\nbool get_animated_frame_visible(int n_frames,\n    int frame_start, int frame_len, int frame_i\n){\n    /* This function answers that age-old question:\n    Is frame_i in the interval [frame_start, frame_start + frame_len)\n    in the space of integers modulo n_frames? */\n\n    if(frame_i >= frame_start && frame_i < frame_start + frame_len){\n        return true;}\n\n    /* Same check, modulo n_frames */\n    frame_i += n_frames;\n    if(frame_i >= frame_start && frame_i < frame_start + frame_len){\n        return true;}\n\n    return false;\n}\n\nint get_animated_frame_i(const char *animation_type,\n    int n_frames, int frame_i\n){\n    if(animation_type == rendergraph_animation_type_once){\n        /* Is this correct??? */\n        if(frame_i >= n_frames)frame_i = n_frames - 1;\n    }else if(animation_type == rendergraph_animation_type_cycle){\n        frame_i = frame_i % n_frames;\n    }else if(animation_type == rendergraph_animation_type_oscillate){\n        frame_i = frame_i % (n_frames * 2);\n        if(frame_i >= n_frames)frame_i = n_frames - (frame_i - n_frames) - 1;\n    }else{\n        fprintf(stderr, \"Unsupported animation_type: %s\\n\",\n            animation_type);\n        return 0;\n    }\n    return frame_i;\n}\n\nint get_n_bitmaps(vecspace_t *space, int n_frames){\n    /* The \"* 2\" is for flip (true or false) */\n    return n_frames * 2 * space->rot_max;\n}\n\nint get_bitmap_i(vecspace_t *space, rot_t rot, flip_t flip,\n    int n_frames, int frame_i\n){\n    int n_bitmaps = get_n_bitmaps(space, n_frames);\n    rot = rot_contain(space->rot_max, rot);\n    rot = rot_flip(space->rot_max, rot, flip);\n    int bitmap_i = (frame_i * 2 + (flip? 1: 0)) * space->rot_max + rot;\n    return bitmap_i;\n}\n\n\n/***********\n * PALETTE *\n ***********/\n\nint palette_init(palette_t *pal, char *name){\n    pal->name = name;\n    for(int i = 0; i < 256; i++){\n        palette_entry_t *entry = &pal->entries[i];\n        entry->frame_i = 0;\n        entry->n_frames = 1;\n        entry->frame_offset = 0;\n        ARRAY_INIT(entry->keyframes)\n    }\n    return 0;\n}\n\nvoid palette_cleanup(palette_t *pal){\n    free(pal->name);\n    for(int i = 0; i < 256; i++){\n        palette_entry_t *entry = &pal->entries[i];\n        ARRAY_FREE_PTR(palette_entry_keyframe_t*, entry->keyframes, (void))\n    }\n}\n\nint palette_reset(palette_t *pal){\n    for(int i = 0; i < 256; i++){\n        int entry_i = i;\n        palette_entry_t *entry = &pal->entries[i];\n        entry->frame_i = entry->frame_offset;\n    }\n    return 0;\n}\n\nint palette_step(palette_t *pal){\n    for(int i = 0; i < 256; i++){\n        int entry_i = i;\n        palette_entry_t *entry = &pal->entries[i];\n        entry->frame_i++;\n        if(entry->frame_i >= entry->n_frames)entry->frame_i = 0;\n    }\n    return 0;\n}\n\nint palette_update_colors(palette_t *pal, SDL_Color *colors,\n    int t, int t_max\n){\n    /* SDL_Color colors[256] */\n    for(int i = 0; i < 256; i++){\n        int entry_i = i;\n        palette_entry_t *entry = &pal->entries[i];\n        SDL_Color *c = &colors[i];\n\n        if(entry->keyframes_len == 0){\n            interpolate_color(c, 0, 0, 0, t, t_max);\n            continue;}\n\n        int frame_i = entry->frame_i;\n        palette_entry_keyframe_t *keyframe = NULL;\n        palette_entry_keyframe_t *next_keyframe = NULL;\n\n        for(int i = 0; i < entry->keyframes_len; i++){\n            keyframe = entry->keyframes[i];\n            if(frame_i < keyframe->n_frames){\n                int j = (i + 1) % entry->keyframes_len;\n                next_keyframe = entry->keyframes[j];\n                break;\n            }else{\n                frame_i -= keyframe->n_frames;}\n        }\n\n        if(next_keyframe == NULL){\n            fprintf(stderr, \"Palette %s: entry %i: \"\n                \"frame %i out of bounds\\n\",\n                pal->name, entry_i, entry->frame_i);\n            return 2;}\n\n        Uint8 r = linear_interpolation(keyframe->color.r,\n            next_keyframe->color.r, frame_i, keyframe->n_frames);\n        Uint8 g = linear_interpolation(keyframe->color.g,\n            next_keyframe->color.g, frame_i, keyframe->n_frames);\n        Uint8 b = linear_interpolation(keyframe->color.b,\n            next_keyframe->color.b, frame_i, keyframe->n_frames);\n        interpolate_color(c, r, g, b, t, t_max);\n    }\n    return 0;\n}\n\nint update_sdl_palette(SDL_Palette *sdl_pal, SDL_Color *colors){\n    RET_IF_SDL_NZ(SDL_SetPaletteColors(sdl_pal, colors, 0, 256));\n    return 0;\n}\n\nint palette_update_sdl_palette(palette_t *pal, SDL_Palette *sdl_pal){\n    int err;\n    SDL_Color colors[256] = {0};\n    err = palette_update_colors(pal, colors, 1, 1);\n    if(err)return err;\n    return update_sdl_palette(sdl_pal, colors);\n}\n\nstatic int palette_parse_color(fus_lexer_t *lexer, SDL_Color *color){\n    int err;\n\n    int r, g, b;\n    err = fus_lexer_get_int(lexer, &r);\n    if(err)return err;\n    err = fus_lexer_get_int(lexer, &g);\n    if(err)return err;\n    err = fus_lexer_get_int(lexer, &b);\n    if(err)return err;\n\n    color->r = r;\n    color->g = g;\n    color->b = b;\n    color->a = 255;\n\n    return 0;\n}\n\nstatic int palette_parse(palette_t *pal, fus_lexer_t *lexer){\n    int err;\n\n    int entry_i = 1; /* First one was the transparent color */\n\n    err = fus_lexer_get(lexer, \"colors\");\n    if(err)return err;\n    err = fus_lexer_get(lexer, \"(\");\n    if(err)return err;\n\n    while(1){\n        if(fus_lexer_got(lexer, \")\"))break;\n\n        if(fus_lexer_got_int(lexer)){\n            err = fus_lexer_get_int(lexer, &entry_i);\n            if(err)return err;\n        }\n\n        err = fus_lexer_get(lexer, \"(\");\n        if(err)return err;\n\n        palette_entry_t *entry = &pal->entries[entry_i];\n\n        if(fus_lexer_got(lexer, \"animate\")){\n            err = fus_lexer_next(lexer);\n            if(err)return err;\n            err = fus_lexer_get(lexer, \"(\");\n            if(err)return err;\n\n            if(fus_lexer_got(lexer, \"+\")){\n                err = fus_lexer_next(lexer);\n                if(err)return err;\n                err = fus_lexer_get_int_fancy(lexer,\n                    &entry->frame_offset);\n                if(err)return err;\n            }\n\n            while(1){\n                if(fus_lexer_got(lexer, \")\"))break;\n\n                err = fus_lexer_get(lexer, \"(\");\n                if(err)return err;\n\n                ARRAY_PUSH_NEW(palette_entry_keyframe_t*, entry->keyframes,\n                    keyframe)\n                err = fus_lexer_get(lexer, \"(\");\n                if(err)return err;\n                err = palette_parse_color(lexer, &keyframe->color);\n                if(err)return err;\n                err = fus_lexer_get(lexer, \")\");\n                if(err)return err;\n\n                err = fus_lexer_get_int(lexer, &keyframe->n_frames);\n                if(err)return err;\n                if(keyframe->n_frames <= 0){\n                    fus_lexer_err_info(lexer);\n                    fprintf(stderr, \"Palette entry %i: keyframe %i: \"\n                        \"n_frames <= 0: %i\\n\",\n                        entry_i, entry->keyframes_len-1,\n                        keyframe->n_frames);\n                    return 2;}\n\n                err = fus_lexer_get(lexer, \")\");\n                if(err)return err;\n            }\n            err = fus_lexer_next(lexer);\n            if(err)return err;\n\n            if(entry->keyframes_len == 0){\n                fus_lexer_err_info(lexer);\n                fprintf(stderr, \"Palette entry %i has no keyframes.\\n\",\n                    entry_i);\n                return 2;}\n        }else{\n            ARRAY_PUSH_NEW(palette_entry_keyframe_t*, entry->keyframes,\n                keyframe)\n            keyframe->n_frames = 1;\n            err = palette_parse_color(lexer, &keyframe->color);\n            if(err)return err;\n        }\n\n        err = fus_lexer_get(lexer, \")\");\n        if(err)return err;\n\n        int n_frames = 0;\n        for(int i = 0; i < entry->keyframes_len; i++){\n            n_frames += entry->keyframes[i]->n_frames;}\n        entry->n_frames = n_frames;\n\n        if(entry->frame_offset >= entry->n_frames){\n            fus_lexer_err_info(lexer);\n            fprintf(stderr, \"Palette entry %i: \"\n                \"frame_offset >= n_frames: %i >= %i\\n\",\n                entry_i, entry->frame_offset, entry->n_frames);\n            return 2;}\n\n        entry_i++;\n    }\n    err = fus_lexer_next(lexer);\n    if(err)return err;\n\n    return 0;\n}\n\nint palette_load(palette_t *pal, const char *filename){\n    int err;\n    fus_lexer_t lexer;\n\n    char *text = load_file(filename);\n    if(text == NULL)return 1;\n\n    err = fus_lexer_init(&lexer, text, filename);\n    if(err)return err;\n\n    err = palette_init(pal, strdup(filename));\n    if(err)return err;\n\n    err = palette_parse(pal, &lexer);\n    if(err)return err;\n\n    err = palette_reset(pal);\n    if(err)return err;\n\n    free(text);\n    return 0;\n}\n\n\n/***********\n * PRISMEL *\n ***********/\n\n\nint prismel_init(prismel_t *prismel, char *name, vecspace_t *space){\n    prismel->name = name;\n    return prismel_create_images(prismel, space);\n}\n\nvoid prismel_cleanup(prismel_t *prismel){\n    free(prismel->name);\n\n    for(int i = 0; i < prismel->n_images; i++){\n        prismel_image_t *image = &prismel->images[i];\n        ARRAY_FREE_PTR(prismel_image_line_t*, image->lines, (void))\n    }\n    free(prismel->images);\n}\n\nint prismel_create_images(prismel_t *prismel, vecspace_t *space){\n    int n_images = get_n_bitmaps(space, 1);\n    prismel_image_t *images = calloc(n_images, sizeof(prismel_image_t));\n    if(images == NULL)return 1;\n    prismel->n_images = n_images;\n    prismel->images = images;\n\n    for(int i = 0; i < n_images; i++){\n        prismel_image_t *image = &images[i];\n        ARRAY_INIT(image->lines)\n    }\n    return 0;\n}\n\nint prismel_image_push_line(prismel_image_t *image, int x, int y, int w){\n    ARRAY_PUSH_NEW(prismel_image_line_t*, image->lines, line)\n    line->x = x;\n    line->y = y;\n    line->w = w;\n    return 0;\n}\n\nvoid prismel_get_boundary_box(prismel_t *prismel, boundary_box_t *box,\n    int bitmap_i\n){\n    static const int line_h = 1;\n    prismel_image_t *image = &prismel->images[bitmap_i];\n\n    boundary_box_clear(box);\n\n    for(int i = 0; i < image->lines_len; i++){\n        prismel_image_line_t *line = image->lines[i];\n\n        boundary_box_t line_box;\n        line_box.l = line->x;\n        line_box.r = line->x + line->w;\n        line_box.t = line->y;\n        line_box.b = line->y + line_h;\n        boundary_box_union(box, &line_box);\n    }\n}\n\n\n\n/*******************\n * PRISMELRENDERER *\n *******************/\n\nint prismelrenderer_init(prismelrenderer_t *renderer, vecspace_t *space){\n    renderer->n_textures = 0;\n    renderer->cache_bitmaps = true;\n    renderer->space = space;\n    ARRAY_INIT(renderer->palmappers)\n    ARRAY_INIT(renderer->prismels)\n    ARRAY_INIT(renderer->rendergraphs)\n    ARRAY_INIT(renderer->mappers)\n    return 0;\n}\n\nvoid prismelrenderer_cleanup(prismelrenderer_t *renderer){\n    ARRAY_FREE_PTR(palettemapper_t*, renderer->palmappers,\n        palettemapper_cleanup)\n    ARRAY_FREE_PTR(prismel_t*, renderer->prismels, prismel_cleanup)\n    ARRAY_FREE_PTR(rendergraph_t*, renderer->rendergraphs,\n        rendergraph_cleanup)\n    ARRAY_FREE_PTR(prismelmapper_t*, renderer->mappers,\n        prismelmapper_cleanup)\n}\n\nvoid prismelrenderer_dump(prismelrenderer_t *renderer, FILE *f,\n    int dump_bitmaps\n){\n    fprintf(f, \"prismelrenderer: %p\\n\", renderer);\n    if(renderer == NULL)return;\n    fprintf(f, \"  space: %p\\n\", renderer->space);\n\n    fprintf(f, \"  palmappers:\\n\");\n    for(int i = 0; i < renderer->palmappers_len; i++){\n        palettemapper_t *palmapper = renderer->palmappers[i];\n        fprintf(f, \"    palmapper: %p\\n\", palmapper);\n        fprintf(f, \"      name: %s\\n\", palmapper->name);\n        fprintf(f, \"      table:\\n\");\n        for(int i = 0; i < 16; i++){\n            fprintf(f, \"        \");\n            for(int j = 0; j < 16; j++){\n                fprintf(f, \"%2X \", palmapper->table[i * 16 + j]);\n            }\n            fprintf(f, \"\\n\");\n        }\n    }\n\n    fprintf(f, \"  prismels:\\n\");\n    for(int i = 0; i < renderer->prismels_len; i++){\n        prismel_t *prismel = renderer->prismels[i];\n        fprintf(f, \"    prismel: %p\\n\", prismel);\n        fprintf(f, \"      name: %s\\n\", prismel->name);\n        fprintf(f, \"      n_images: %i\\n\", prismel->n_images);\n        fprintf(f, \"      images:\\n\");\n        for(int i = 0; i < prismel->n_images; i++){\n            prismel_image_t *image = &prismel->images[i];\n            fprintf(f, \"        image: %p\", image);\n            for(int i = 0; i < image->lines_len; i++){\n                prismel_image_line_t *line = image->lines[i];\n                fprintf(f, \" (% i % i % i)\", line->x, line->y, line->w);\n            }\n            fprintf(f, \"\\n\");\n        }\n    }\n\n    fprintf(f, \"  rendergraphs:\\n\");\n    for(int i = 0; i < renderer->rendergraphs_len; i++){\n        rendergraph_t *rgraph = renderer->rendergraphs[i];\n        rendergraph_dump(rgraph, f, 4, dump_bitmaps);\n    }\n\n    fprintf(f, \"  prismelmappers:\\n\");\n    for(int i = 0; i < renderer->mappers_len; i++){\n        prismelmapper_t *mapper = renderer->mappers[i];\n        prismelmapper_dump(mapper, f, 4);\n    }\n}\n\nstatic void _dump_size(int size, int count, FILE *f){\n    int size_avg = size / count;\n    fprintf(f, \"      B   %12i %8i\\n\",\n        size,\n        size_avg);\n    fprintf(f, \"      KiB %12i %8i\\n\",\n        size / 1024,\n        size_avg / 1024);\n    fprintf(f, \"      MiB %12i %8i\\n\",\n        size / 1024 / 1024,\n        size_avg / 1024 / 1024);\n    fprintf(f, \"      GiB %12i %8i\\n\",\n        size / 1024 / 1024 / 1024,\n        size_avg / 1024 / 1024 / 1024);\n}\n\nvoid prismelrenderer_dump_stats(prismelrenderer_t *prend, FILE *f){\n    int n_bitmaps = 0;\n    int n_surfaces = 0;\n    int n_textures = 0;\n    int surfaces_size = 0;\n\n    for(int i = 0; i < prend->rendergraphs_len; i++){\n        rendergraph_t *rgraph = prend->rendergraphs[i];\n        for(int i = 0; i < rgraph->n_bitmaps; i++){\n            rendergraph_bitmap_t *bitmap = &rgraph->bitmaps[i];\n            SDL_Surface *surface = bitmap->surface;\n            SDL_Texture *texture = bitmap->texture;\n            n_bitmaps++;\n            if(surface != NULL){\n                n_surfaces++;\n                surfaces_size += surface->h * surface->pitch;\n            }\n            if(texture != NULL){\n                n_textures++;\n            }\n        }\n    }\n\n    fprintf(f, \"Prismelrenderer stats:\\n\");\n    fprintf(f, \"  bitmaps: %i\\n\", n_bitmaps);\n    fprintf(f, \"  surfaces: %i\\n\", n_surfaces);\n    fprintf(f, \"    size (total | avg):\\n\");\n    _dump_size(surfaces_size, n_bitmaps, f);\n    fprintf(f, \"  textures: %i\\n\", n_textures);\n}\n\nint prismelrenderer_push_prismel(prismelrenderer_t *renderer, char *name,\n    prismel_t **prismel_ptr\n){\n    int err;\n    ARRAY_PUSH_NEW(prismel_t*, renderer->prismels, prismel)\n    if(!name){name = generate_indexed_name(\"prismel\",\n        renderer->prismels_len - 1);}\n    err = prismel_init(prismel, name, renderer->space);\n    if(err)return err;\n    *prismel_ptr = prismel;\n    return 0;\n}\n\npalettemapper_t *prismelrenderer_get_palmapper(prismelrenderer_t *prend,\n    const char *name\n){\n    for(int i = 0; i < prend->palmappers_len; i++){\n        palettemapper_t *palmapper = prend->palmappers[i];\n        if(strcmp(palmapper->name, name) == 0)return palmapper;\n    }\n    return NULL;\n}\n\nint prismelrenderer_get_solid_palettemapper(prismelrenderer_t *prend,\n    int color, palettemapper_t **palmapper_ptr\n){\n    int err;\n    char *name = generate_indexed_name(\"solid\", color);\n    palettemapper_t *palmapper = prismelrenderer_get_palmapper(\n        prend, name);\n    if(palmapper == NULL){\n        ARRAY_PUSH_NEW(palettemapper_t*, prend->palmappers, _palmapper)\n        palmapper = _palmapper;\n        err = palettemapper_init(palmapper, name, color);\n        if(err)return err;\n    }else{\n        free(name);\n    }\n    *palmapper_ptr = palmapper;\n    return 0;\n}\n\nprismel_t *prismelrenderer_get_prismel(prismelrenderer_t *prend,\n    const char *name\n){\n    for(int i = 0; i < prend->prismels_len; i++){\n        prismel_t *prismel = prend->prismels[i];\n        if(strcmp(prismel->name, name) == 0)return prismel;\n    }\n    return NULL;\n}\n\nrendergraph_t *prismelrenderer_get_rendergraph(prismelrenderer_t *prend,\n    const char *name\n){\n    for(int i = 0; i < prend->rendergraphs_len; i++){\n        rendergraph_t *rgraph = prend->rendergraphs[i];\n        if(!strcmp(rgraph->name, name))return rgraph;\n    }\n    return NULL;\n}\n\nprismelmapper_t *prismelrenderer_get_mapper(prismelrenderer_t *prend,\n    const char *name\n){\n    for(int i = 0; i < prend->mappers_len; i++){\n        prismelmapper_t *mapper = prend->mappers[i];\n        if(!strcmp(mapper->name, name))return mapper;\n    }\n    return NULL;\n}\n\nint prismelrenderer_load(prismelrenderer_t *prend, const char *filename){\n    int err;\n    fus_lexer_t lexer;\n\n    char *text = load_file(filename);\n    if(text == NULL)return 1;\n\n    err = fus_lexer_init(&lexer, text, filename);\n    if(err)return err;\n\n    err = prismelrenderer_parse(prend, &lexer);\n    if(err)return err;\n\n    free(text);\n    return 0;\n}\n\nint prismelrenderer_save(prismelrenderer_t *prend, const char *filename){\n    int err;\n    FILE *f = fopen(filename, \"w\");\n    if(f == NULL)return 2;\n    err = prismelrenderer_write(prend, f);\n    if(err)return err;\n    if(fclose(f))return 2;\n    return 0;\n}\n\nint prismelrenderer_write(prismelrenderer_t *prend, FILE *f){\n    int err;\n\n    fprintf(f, \"palmappers:\\n\");\n    for(int i = 0; i < prend->palmappers_len; i++){\n        palettemapper_t *palmapper = prend->palmappers[i];\n        fprintf(f, \"    \");\n        fus_write_str(f, palmapper->name);\n        fprintf(f, \":\\n\");\n        for(int i = 0; i < 256; i++){\n            fprintf(f, \"        : %i\\n\", palmapper->table[i]);\n        }\n    }\n\n    fprintf(f, \"prismels:\\n\");\n    for(int i = 0; i < prend->prismels_len; i++){\n        prismel_t *prismel = prend->prismels[i];\n        fprintf(f, \"    \");\n        fus_write_str(f, prismel->name);\n        fprintf(f, \":\\n\");\n        fprintf(f, \"        images:\\n\");\n        for(int i = 0; i < prismel->n_images; i++){\n            prismel_image_t *image = &prismel->images[i];\n            fprintf(f, \"            :\");\n            for(int i = 0; i < image->lines_len; i++){\n                prismel_image_line_t *line = image->lines[i];\n                fprintf(f, \" (% 3i % 3i % 3i)\",\n                    line->x, line->y, line->w);\n            }\n            fprintf(f, \"\\n\");\n        }\n    }\n\n    fprintf(f, \"shapes:\\n\");\n    for(int i = 0; i < prend->rendergraphs_len; i++){\n        rendergraph_t *rgraph = prend->rendergraphs[i];\n        fprintf(f, \"    \");\n        fus_write_str(f, rgraph->name);\n        fprintf(f, \":\\n\");\n\n        fprintf(f, \"        animation: %s %i\\n\",\n            rgraph->animation_type, rgraph->n_frames);\n\n        if(rgraph->prismel_trfs != NULL){\n            fprintf(f, \"        prismels:\\n\");}\n        for(int i = 0; i < rgraph->prismel_trfs_len; i++){\n            prismel_trf_t *prismel_trf =\n                rgraph->prismel_trfs[i];\n            prismel_t *prismel = prismel_trf->prismel;\n            trf_t *trf = &prismel_trf->trf;\n\n            fprintf(f, \"            : \");\n            fus_write_str_padded(f, prismel->name, 7);\n            fprintf(f, \" (\");\n            fprintf(f, \"% 3i\", trf->add[0]);\n            for(int i = 1; i < prend->space->dims; i++){\n                fprintf(f, \" % 3i\", trf->add[i]);\n            }\n            fprintf(f, \") %2i %c %2i (%2i %2i)\\n\",\n                trf->rot, trf->flip? 't': 'f',\n                prismel_trf->color,\n                prismel_trf->frame_start,\n                prismel_trf->frame_len);\n        }\n\n        if(rgraph->rendergraph_trfs != NULL){\n            fprintf(f, \"        shapes:\\n\");}\n        for(int i = 0; i < rgraph->rendergraph_trfs_len; i++){\n            rendergraph_trf_t *rendergraph_trf =\n                rgraph->rendergraph_trfs[i];\n            rendergraph_t *rendergraph = rendergraph_trf->rendergraph;\n            trf_t *trf = &rendergraph_trf->trf;\n\n            fprintf(f, \"            : \");\n            fus_write_str_padded(f, rendergraph->name, 40);\n            fprintf(f, \" (\");\n            fprintf(f, \"% 3i\", trf->add[0]);\n            for(int i = 1; i < prend->space->dims; i++){\n                fprintf(f, \" % 3i\", trf->add[i]);\n            }\n            fprintf(f, \") %2i %c %2i%c (%2i %2i)\\n\",\n                trf->rot, trf->flip? 't': 'f',\n                rendergraph_trf->frame_i,\n                rendergraph_trf->frame_i_additive? '+': ' ',\n                rendergraph_trf->frame_start,\n                rendergraph_trf->frame_len);\n        }\n        fprintf(f, \"\\n\");\n    }\n\n    fprintf(f, \"mappers:\\n\");\n    for(int i = 0; i < prend->mappers_len; i++){\n        prismelmapper_t *mapper = prend->mappers[i];\n\n        fprintf(f, \"    \");\n        fus_write_str(f, mapper->name);\n        fprintf(f, \":\\n\");\n\n        if(mapper->solid){\n            fprintf(f, \"        solid\\n\");\n        }\n\n        fprintf(f, \"        unit:\");\n        for(int i = 0; i < prend->space->dims; i++){\n            fprintf(f, \" % 3i\", mapper->unit[i]);\n        }\n        fprintf(f, \"\\n\");\n\n        if(mapper->entries != NULL){\n            fprintf(f, \"        entries:\\n\");}\n        for(int i = 0; i < mapper->entries_len; i++){\n            prismelmapper_entry_t *entry = mapper->entries[i];\n            fprintf(f, \"            : \");\n            fus_write_str(f, entry->prismel->name);\n            fprintf(f, \" -> \");\n            fus_write_str(f, entry->rendergraph->name);\n            fprintf(f, \"\\n\");\n        }\n    }\n\n    return 0;\n}\n\nint prismelrenderer_render_all_bitmaps(prismelrenderer_t *prend,\n    SDL_Palette *pal\n){\n    int err;\n    for(int i = 0; i < prend->rendergraphs_len; i++){\n        rendergraph_t *rgraph = prend->rendergraphs[i];\n        err = rendergraph_render_all_bitmaps(rgraph, pal);\n        if(err)return err;\n    }\n    return 0;\n}\n\n\n\n\n/*****************\n * PRISMELMAPPER *\n *****************/\n\nvoid prismelmapper_cleanup(prismelmapper_t *mapper){\n    free(mapper->name);\n\n    ARRAY_FREE_PTR(prismelmapper_entry_t*, mapper->entries,\n        (void))\n    ARRAY_FREE_PTR(prismelmapper_application_t*, mapper->applications,\n        (void))\n    ARRAY_FREE_PTR(prismelmapper_mapplication_t*, mapper->mapplications,\n        (void))\n}\n\nint prismelmapper_init(prismelmapper_t *mapper, char *name,\n    vecspace_t *space, bool solid\n){\n    mapper->name = name;\n    mapper->solid = solid;\n    mapper->space = space;\n    vec_zero(mapper->unit);\n    ARRAY_INIT(mapper->entries)\n    ARRAY_INIT(mapper->applications)\n    ARRAY_INIT(mapper->mapplications)\n    return 0;\n}\n\nvoid prismelmapper_dump(prismelmapper_t *mapper, FILE *f, int n_spaces){\n    char spaces[MAX_SPACES];\n    get_spaces(spaces, MAX_SPACES, n_spaces);\n\n    fprintf(f, \"%sprismelmapper: %p\\n\", spaces, mapper);\n    if(mapper == NULL)return;\n    fprintf(f, \"%s  name: %s\\n\", spaces, mapper->name);\n    fprintf(f, \"%s  space: %p\\n\", spaces, mapper->space);\n    fprintf(f, \"%s  solid: %c\\n\", spaces, mapper->solid? 'y': 'n');\n    fprintf(f, \"%s  unit: \", spaces);\n    vec_fprintf(f, mapper->space->dims, mapper->unit);\n    fprintf(f, \"\\n\");\n\n    fprintf(f, \"%s  entries:\\n\", spaces);\n    for(int i = 0; i < mapper->entries_len; i++){\n        prismelmapper_entry_t *entry = mapper->entries[i];\n        fprintf(f, \"%s    %s -> %s\\n\", spaces,\n            entry->prismel == NULL? \"<NULL>\": entry->prismel->name,\n            entry->rendergraph == NULL? \"<NULL>\": entry->rendergraph->name);\n    }\n\n    fprintf(f, \"%s  applications:\\n\", spaces);\n    for(int i = 0; i < mapper->applications_len; i++){\n        prismelmapper_application_t *application = mapper->applications[i];\n        fprintf(f, \"%s    %s -> %s\\n\", spaces,\n            application->mapped_rgraph == NULL? \"<NULL>\":\n                application->mapped_rgraph->name,\n            application->resulting_rgraph == NULL? \"<NULL>\":\n                application->resulting_rgraph->name);\n    }\n\n    fprintf(f, \"%s  mapplications:\\n\", spaces);\n    for(int i = 0; i < mapper->mapplications_len; i++){\n        prismelmapper_mapplication_t *mapplication = mapper->mapplications[i];\n        fprintf(f, \"%s    %s -> %s\\n\", spaces,\n            mapplication->mapped_mapper == NULL? \"<NULL>\":\n                mapplication->mapped_mapper->name,\n            mapplication->resulting_mapper == NULL? \"<NULL>\":\n                mapplication->resulting_mapper->name);\n    }\n}\n\nint prismelmapper_push_entry(prismelmapper_t *mapper,\n    prismel_t *prismel, rendergraph_t *rendergraph\n){\n    ARRAY_PUSH_NEW(prismelmapper_entry_t*, mapper->entries, entry)\n    entry->prismel = prismel;\n    entry->rendergraph = rendergraph;\n    return 0;\n}\n\nint prismelmapper_apply_to_rendergraph(prismelmapper_t *mapper,\n    prismelrenderer_t *prend,\n    rendergraph_t *mapped_rgraph,\n    char *name, vecspace_t *space, Uint8 *table,\n    rendergraph_t **rgraph_ptr\n){\n    int err;\n\n    rendergraph_t *resulting_rgraph;\n\n    /* Check whether this mapper has already been applied to this\n    mapped_rgraph. If so, return the cached resulting_rgraph. */\n    resulting_rgraph = prismelmapper_get_application(\n        mapper, mapped_rgraph);\n    if(resulting_rgraph != NULL){\n        free(name);\n        *rgraph_ptr = resulting_rgraph;\n        return 0;\n    }\n\n    /* If no name specified, generate one like \"<curvy dodeca_sixth>\" */\n    if(name == NULL){\n        name = generate_mapped_name(mapper->name,\n            mapped_rgraph->name);}\n\n    /* Create a new rendergraph */\n    resulting_rgraph = calloc(1, sizeof(rendergraph_t));\n    if(resulting_rgraph == NULL)return 1;\n    err = rendergraph_init(resulting_rgraph, name, prend,\n        mapped_rgraph->palmapper,\n        mapped_rgraph->animation_type, mapped_rgraph->n_frames);\n    if(err)return err;\n\n    /* Apply mapper to mapped_rgraph's prismels */\n    for(int i = 0; i < mapped_rgraph->prismel_trfs_len; i++){\n        prismel_trf_t *prismel_trf = mapped_rgraph->prismel_trfs[i];\n        prismel_t *prismel = prismel_trf->prismel;\n\n        bool entry_found = false;\n        for(int i = 0; i < mapper->entries_len; i++){\n            prismelmapper_entry_t *entry = mapper->entries[i];\n            if(prismel == entry->prismel){\n                rendergraph_trf_t *new_rendergraph_trf;\n                err = rendergraph_push_rendergraph_trf(resulting_rgraph,\n                    &new_rendergraph_trf);\n                if(err)return err;\n                new_rendergraph_trf->rendergraph = entry->rendergraph;\n                new_rendergraph_trf->trf = prismel_trf->trf;\n                vec_mul(mapper->space, new_rendergraph_trf->trf.add,\n                    mapper->unit);\n                new_rendergraph_trf->frame_start =\n                    prismel_trf->frame_start;\n                new_rendergraph_trf->frame_len =\n                    prismel_trf->frame_len;\n\n                if(mapper->solid){\n                    Uint8 color = prismel_trf->color;\n                    if(table != NULL)color = table[color];\n                    err = prismelrenderer_get_solid_palettemapper(\n                        prend, color,\n                        &new_rendergraph_trf->palmapper);\n                    if(err)return err;\n                }\n\n                entry_found = true;\n                break;\n            }\n        }\n\n        if(!entry_found){\n            fprintf(stderr,\n                \"Prismel %s does not match any entry of mapper %s\\n\",\n                prismel->name, mapper->name);\n            err = 2; return err;\n        }\n    }\n\n    /* Apply mapper to mapped_rgraph's sub-rendergraphs */\n    for(int i = 0; i < mapped_rgraph->rendergraph_trfs_len; i++){\n        rendergraph_trf_t *rendergraph_trf =\n            mapped_rgraph->rendergraph_trfs[i];\n        rendergraph_t *rgraph = rendergraph_trf->rendergraph;\n\n        /* Recurse! */\n        rendergraph_t *new_rgraph;\n        err = prismelmapper_apply_to_rendergraph(mapper, prend,\n            rgraph, NULL, space, table, &new_rgraph);\n        if(err)return err;\n\n        /* Add a rendergraph_trf to resulting_rgraph */\n        rendergraph_trf_t *new_rendergraph_trf;\n        err = rendergraph_push_rendergraph_trf(resulting_rgraph,\n            &new_rendergraph_trf);\n        if(err)return err;\n        new_rendergraph_trf->rendergraph = new_rgraph;\n        new_rendergraph_trf->trf = rendergraph_trf->trf;\n        vec_mul(mapper->space, new_rendergraph_trf->trf.add,\n            mapper->unit);\n        if(mapper->solid){\n            /* TODO: think about this and make sure it's correct */\n            new_rendergraph_trf->palmapper =\n                rendergraph_trf->palmapper;}\n        new_rendergraph_trf->frame_i =\n            rendergraph_trf->frame_i;\n        new_rendergraph_trf->frame_i_additive =\n            rendergraph_trf->frame_i_additive;\n        new_rendergraph_trf->frame_start =\n            rendergraph_trf->frame_start;\n        new_rendergraph_trf->frame_len =\n            rendergraph_trf->frame_len;\n    }\n\n    /* Cache this resulting_rgraph on the mapper in case it\n    ever gets applied to the same mapped_rgraph again */\n    err = prismelmapper_push_application(mapper,\n        mapped_rgraph, resulting_rgraph);\n    if(err)return err;\n\n    /* Add the resulting_rgraph to the prismelrenderer, makes for\n    easier debugging */\n    ARRAY_PUSH(rendergraph_t*, prend->rendergraphs,\n        resulting_rgraph)\n\n    /* Success! */\n    *rgraph_ptr = resulting_rgraph;\n    return 0;\n}\n\nint prismelmapper_apply_to_mapper(prismelmapper_t *mapper,\n    prismelrenderer_t *prend,\n    prismelmapper_t *mapped_mapper,\n    char *name, vecspace_t *space,\n    prismelmapper_t **mapper_ptr\n){\n    /* Hey dawg, we applied mapper to mapped_mapper, resulting in\n    resulting_mapper\n    Question: do mapper, mapped_mapper, and resulting_mapper all\n    need to share the same vecspace?.. */\n    int err;\n\n    prismelmapper_t *resulting_mapper;\n\n    /* Check whether this mapper has already been applied to this\n    mapped_mapper. If so, return the cached resulting_mapper. */\n    resulting_mapper = prismelmapper_get_mapplication(\n        mapper, mapped_mapper);\n    if(resulting_mapper != NULL){\n        free(name);\n        *mapper_ptr = resulting_mapper;\n        return 0;\n    }\n\n    /* If no name specified, generate one like \"<curvy double>\" */\n    if(name == NULL){\n        name = generate_mapped_name(mapper->name,\n            mapped_mapper->name);}\n\n    /* Create a new prismelmapper */\n    resulting_mapper = calloc(1, sizeof(prismelmapper_t));\n    if(resulting_mapper == NULL)return 1;\n    err = prismelmapper_init(resulting_mapper, name, space, false);\n    if(err)return err;\n\n    /* Calculate the new mapper's unit */\n    vec_cpy(space->dims, resulting_mapper->unit, mapped_mapper->unit);\n    vec_mul(space, resulting_mapper->unit, mapper->unit);\n\n    /* Copy entries from mapped_mapper to resulting_mapper, applying\n    mapper to each entry */\n    for(int i = 0; i < mapped_mapper->entries_len; i++){\n        prismelmapper_entry_t *entry = mapped_mapper->entries[i];\n\n        char *name = generate_mapped_name(mapper->name,\n            entry->rendergraph->name);\n        if(name == NULL)return 1;\n\n        rendergraph_t *new_rgraph;\n        err = prismelmapper_apply_to_rendergraph(mapper, prend,\n            entry->rendergraph, name, space, NULL, &new_rgraph);\n        if(err)return err;\n\n        err = prismelmapper_push_entry(resulting_mapper,\n            entry->prismel, new_rgraph);\n        if(err)return err;\n    }\n\n    /* Cache this resulting_mapper on the mapper in case it\n    ever gets applied to the same mapped_mapper again */\n    err = prismelmapper_push_mapplication(mapper,\n        mapped_mapper, resulting_mapper);\n    if(err)return err;\n\n    /* Add the resulting_mapper to the prismelrenderer, makes for\n    easier debugging */\n    ARRAY_PUSH(prismelmapper_t*, prend->mappers,\n        resulting_mapper)\n\n    /* Success! */\n    *mapper_ptr = resulting_mapper;\n    return 0;\n}\n\nint prismelmapper_push_application(prismelmapper_t *mapper,\n    rendergraph_t *mapped_rgraph, rendergraph_t *resulting_rgraph\n){\n    ARRAY_PUSH_NEW(prismelmapper_application_t*, mapper->applications,\n        application)\n    application->mapped_rgraph = mapped_rgraph;\n    application->resulting_rgraph = resulting_rgraph;\n    return 0;\n}\n\nint prismelmapper_push_mapplication(prismelmapper_t *mapper,\n    prismelmapper_t *mapped_mapper, prismelmapper_t *resulting_mapper\n){\n    ARRAY_PUSH_NEW(prismelmapper_mapplication_t*, mapper->mapplications,\n        mapplication)\n    mapplication->mapped_mapper = mapped_mapper;\n    mapplication->resulting_mapper = resulting_mapper;\n    return 0;\n}\n\nrendergraph_t *prismelmapper_get_application(prismelmapper_t *mapper,\n    rendergraph_t *mapped_rgraph\n){\n    for(int i = 0; i < mapper->applications_len; i++){\n        prismelmapper_application_t *application = mapper->applications[i];\n        if(application->mapped_rgraph == mapped_rgraph){\n            return application->resulting_rgraph;}\n    }\n    return NULL;\n}\n\nprismelmapper_t *prismelmapper_get_mapplication(prismelmapper_t *mapper,\n    prismelmapper_t *mapped_mapper\n){\n    for(int i = 0; i < mapper->mapplications_len; i++){\n        prismelmapper_mapplication_t *mapplication = mapper->mapplications[i];\n        if(mapplication->mapped_mapper == mapped_mapper){\n            return mapplication->resulting_mapper;}\n    }\n    return NULL;\n}\n\n\n\n/******************\n * PALETTE MAPPER *\n ******************/\n\nint palettemapper_init(palettemapper_t *palmapper, char *name, int color){\n    if(name == NULL)name = strdup(\"<palette mapper>\");\n    palmapper->name = name;\n    palmapper->table[0] = 0; /* 0 is the transparent color */\n    if(color < 0){\n        for(int i = 1; i < 256; i++)palmapper->table[i] = i;\n    }else{\n        for(int i = 1; i < 256; i++)palmapper->table[i] = color;\n    }\n    ARRAY_INIT(palmapper->pmapplications)\n    return 0;\n}\n\nvoid palettemapper_cleanup(palettemapper_t *palmapper){\n    free(palmapper->name);\n    ARRAY_FREE_PTR(palettemapper_pmapplication_t*, palmapper->pmapplications,\n        (void))\n}\n\nUint8 palettemapper_apply_to_color(palettemapper_t *palmapper, Uint8 c){\n    return palmapper->table[c];\n}\n\nvoid palettemapper_apply_to_table(palettemapper_t *palmapper, Uint8 *table){\n    for(int i = 0; i < 256; i++){\n        table[i] = palettemapper_apply_to_color(palmapper, table[i]);\n    }\n}\n\nint palettemapper_apply_to_rendergraph(palettemapper_t *mapper,\n    prismelrenderer_t *prend,\n    rendergraph_t *mapped_rgraph,\n    char *name, vecspace_t *space,\n    rendergraph_t **rgraph_ptr\n){\n    int err;\n\n    rendergraph_t *resulting_rgraph;\n\n    /* Check whether this mapper has already been applied to this\n    mapped_rgraph. If so, return the cached resulting_rgraph. */\n    resulting_rgraph = palettemapper_get_application(\n        mapper, mapped_rgraph);\n    if(resulting_rgraph != NULL){\n        free(name);\n        *rgraph_ptr = resulting_rgraph;\n        return 0;\n    }\n\n    /* If no name specified, generate one like \"<pm:red dodeca_sixth>\" */\n    if(name == NULL){\n        name = generate_palmapped_name(mapper->name,\n            mapped_rgraph->name);}\n\n    /* resulting_rgraph starts off as a copy of mapped_rgraph */\n    resulting_rgraph = calloc(1, sizeof(rendergraph_t));\n    if(resulting_rgraph == NULL)return 1;\n    err = rendergraph_copy(resulting_rgraph, name, mapped_rgraph);\n    if(err)return err;\n\n    /* Set resulting_rgraph's palmapper to mapper\n    (this was the whole point) */\n    resulting_rgraph->palmapper = mapper;\n\n    /* Cache this resulting_rgraph on the mapper in case it\n    ever gets applied to the same mapped_rgraph again */\n    err = palettemapper_push_application(mapper,\n        mapped_rgraph, resulting_rgraph);\n    if(err)return err;\n\n    /* Add the resulting_rgraph to the prismelrenderer, makes for\n    easier debugging */\n    ARRAY_PUSH(rendergraph_t*, prend->rendergraphs,\n        resulting_rgraph)\n\n    /* Success! */\n    *rgraph_ptr = resulting_rgraph;\n    return 0;\n}\n\nint palettemapper_apply_to_palettemapper(palettemapper_t *palmapper,\n    prismelrenderer_t *prend, palettemapper_t *mapped_palmapper,\n    char *name, palettemapper_t **palmapper_ptr\n){\n    int err;\n\n    palettemapper_t *resulting_palmapper;\n\n    /* Check whether this palmapper has already been applied to this\n    mapped_palmapper. If so, return the cached resulting_palmapper. */\n    resulting_palmapper = palettemapper_get_pmapplication(\n        palmapper, mapped_palmapper);\n    if(resulting_palmapper != NULL){\n        free(name);\n        *palmapper_ptr = resulting_palmapper;\n        return 0;\n    }\n\n    /* If no name specified, generate one like \"<cycle reverse>\" */\n    if(name == NULL){\n        name = generate_mapped_name(palmapper->name,\n            mapped_palmapper->name);}\n\n    /* Create a new palettemapper */\n    resulting_palmapper = calloc(1, sizeof(palettemapper_t));\n    if(resulting_palmapper == NULL)return 1;\n    err = palettemapper_init(resulting_palmapper, name, -1);\n    if(err)return err;\n\n    /* Apply tables to each other... that's why we're here, really */\n    for(int i = 0; i < 256; i++){\n        resulting_palmapper->table[i] = palmapper->table\n            [mapped_palmapper->table[i]];\n    }\n\n    /* Cache this resulting_palmapper on the palmapper in case it\n    ever gets applied to the same mapped_palmapper again */\n    err = palettemapper_push_pmapplication(palmapper,\n        mapped_palmapper, resulting_palmapper);\n    if(err)return err;\n\n    /* Add the resulting_palmapper to the prismelrenderer, makes for\n    easier debugging */\n    ARRAY_PUSH(palettemapper_t*, prend->palmappers, resulting_palmapper)\n\n    /* Success! */\n    *palmapper_ptr = resulting_palmapper;\n    return 0;\n}\n\nint palettemapper_push_application(palettemapper_t *mapper,\n    rendergraph_t *mapped_rgraph, rendergraph_t *resulting_rgraph\n){\n    ARRAY_PUSH_NEW(palettemapper_application_t*, mapper->applications,\n        application)\n    application->mapped_rgraph = mapped_rgraph;\n    application->resulting_rgraph = resulting_rgraph;\n    return 0;\n}\n\nrendergraph_t *palettemapper_get_application(palettemapper_t *mapper,\n    rendergraph_t *mapped_rgraph\n){\n    for(int i = 0; i < mapper->applications_len; i++){\n        palettemapper_application_t *application =\n            mapper->applications[i];\n        if(application->mapped_rgraph == mapped_rgraph){\n            return application->resulting_rgraph;}\n    }\n    return NULL;\n}\n\nint palettemapper_push_pmapplication(palettemapper_t *mapper,\n    palettemapper_t *mapped_mapper, palettemapper_t *resulting_mapper\n){\n    ARRAY_PUSH_NEW(palettemapper_pmapplication_t*, mapper->pmapplications,\n        pmapplication)\n    pmapplication->mapped_mapper = mapped_mapper;\n    pmapplication->resulting_mapper = resulting_mapper;\n    return 0;\n}\n\npalettemapper_t *palettemapper_get_pmapplication(palettemapper_t *mapper,\n    palettemapper_t *mapped_mapper\n){\n    for(int i = 0; i < mapper->pmapplications_len; i++){\n        palettemapper_pmapplication_t *pmapplication =\n            mapper->pmapplications[i];\n        if(pmapplication->mapped_mapper == mapped_mapper){\n            return pmapplication->resulting_mapper;}\n    }\n    return NULL;\n}\n\n","\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n\n#include \"lexer.h\"\n#include \"lexer_macros.h\"\n#include \"util.h\"\n#include \"array.h\"\n#include \"prismelrenderer.h\"\n\n\n\n/******************\n * PALETTE MAPPER *\n ******************/\n\nstatic int parse_palmappers(prismelrenderer_t *prend, fus_lexer_t *lexer){\n    INIT\n    while(1){\n        char *name;\n        if(GOT(\")\"))break;\n        GET_STR(name)\n        palettemapper_t *palmapper;\n        err = fus_lexer_get_palettemapper(lexer, prend, name, &palmapper);\n        if(err)return err;\n    }\n    NEXT\n    return 0;\n}\n\nint fus_lexer_get_palettemapper(fus_lexer_t *lexer,\n    prismelrenderer_t *prend, char *name, palettemapper_t **palmapper_ptr\n){\n    INIT\n    palettemapper_t *palmapper = NULL;\n    GET(\"(\")\n\n    if(GOT_STR){\n        char *name;\n        GET_STR(name)\n        palmapper = prismelrenderer_get_palmapper(prend, name);\n        if(palmapper == NULL){\n            fprintf(stderr, \"Couldn't find palette mapper: %s\\n\", name);\n            free(name); return 2;}\n        free(name);\n        GET(\")\")\n        goto ok;\n    }\n\n    if(GOT(\"map\")){\n        NEXT\n\n        palettemapper_t *palmapper1;\n        err = fus_lexer_get_palettemapper(lexer, prend, NULL,\n            &palmapper1);\n        if(err)return err;\n\n        palettemapper_t *palmapper2;\n        err = fus_lexer_get_palettemapper(lexer, prend, NULL,\n            &palmapper2);\n        if(err)return err;\n\n        err = palettemapper_apply_to_palettemapper(palmapper1, prend,\n            palmapper2, name, &palmapper);\n        if(err)return err;\n\n        GET(\")\")\n        goto ok;\n    }\n\n    ARRAY_PUSH_NEW(palettemapper_t*, prend->palmappers, _palmapper)\n    palmapper = _palmapper;\n    err = palettemapper_init(palmapper, strdup(name), -1);\n    if(err)return err;\n\n    Uint8 *table = palmapper->table;\n    int color_i = 0;\n\n    while(1){\n        if(GOT(\")\"))break;\n\n        int n_colors = 1;\n\n        if(!GOT(\"(\")){\n            err = fus_lexer_get_int_range(lexer, 256, &color_i, &n_colors);\n            if(err)return err;\n        }\n\n        if(color_i >= 256){\n            fus_lexer_err_info(lexer);\n            fprintf(stderr, \"Color index went out of bounds\\n\");\n            return 2;\n        }\n\n        GET(\"(\")\n        {\n            if(!GOT(\")\")){\n                int color;\n                GET_INT_FANCY(color)\n                if(color < 0 || color >= 256){\n                    return UNEXPECTED(\n                        \"int within 0..255\");}\n                for(int i = 0; i < n_colors; i++){\n                    table[color_i] = color;\n                    color_i++;\n                }\n            }else{\n                for(int i = 0; i < n_colors; i++){\n                    table[color_i] = color_i;\n                    color_i++;\n                }\n            }\n        }\n        GET(\")\")\n    }\n    NEXT\n\nok:\n    *palmapper_ptr = palmapper;\n    return 0;\n}\n\n\n/***********\n * PRISMEL *\n ***********/\n\nstatic int parse_prismel_image(prismel_t *prismel, fus_lexer_t *lexer,\n    int image_i\n){\n    INIT\n    prismel_image_t *image = &prismel->images[image_i];\n    GET(\"(\")\n\n    if(GOT_INT){\n        /* For example:\n            6 +( 4  0) */\n\n        int i;\n        GET_INT(i)\n        if(i < 0 || i >= image_i){\n            fus_lexer_err_info(lexer);\n            fprintf(stderr, \"Prismel image reference out \"\n                \"of bounds: %i not in 0..%i\\n\",\n                i, image_i - 1);\n            return 2;\n        }\n        prismel_image_t *other_image = &prismel->images[i];\n\n        int add_x = 0, add_y = 0;\n        if(GOT(\"+\")){\n            NEXT\n            GET(\"(\")\n            GET_INT(add_x)\n            GET_INT(add_y)\n            GET(\")\")\n        }\n\n        GET(\")\")\n\n        for(int i = 0; i < other_image->lines_len; i++){\n            prismel_image_line_t *other_line =\n                other_image->lines[i];\n            err = prismel_image_push_line(image,\n                other_line->x + add_x, other_line->y + add_y,\n                other_line->w);\n            if(err)return err;\n        }\n    }else{\n        /* For example:\n            ( 1 -2  1) ( 0 -1  3) ( 1  0  1) */\n        while(1){\n            if(GOT(\"(\")){\n                int x, y, w;\n                NEXT\n                GET_INT(x)\n                GET_INT(y)\n                GET_INT(w)\n                GET(\")\")\n                err = prismel_image_push_line(image, x, y, w);\n                if(err)return err;\n            }else if(GOT(\")\")){\n                break;\n            }else{\n                return UNEXPECTED(\"(...)\");\n            }\n        }\n        NEXT\n    }\n\n    return 0;\n}\n\nint fus_lexer_get_prismel(fus_lexer_t *lexer,\n    prismelrenderer_t *prend, char *name, prismel_t **prismel_ptr\n){\n    /*\n        Example data:\n\n            images:\n                : ( 0 -2  2) ( 0 -1  2)\n                : ( 0 -3  1) (-1 -2  3) ( 0 -1  1)\n                : (-1 -3  1) (-2 -2  3) (-1 -1  1)\n                : (-2 -2  2) (-2 -1  2)\n                : (-2 -2  1) (-3 -1  3) (-2  0  1)\n                : (-2 -1  1) (-3  0  3) (-2  1  1)\n                : (-2  0  2) (-2  1  2)\n                : (-1  0  1) (-2  1  3) (-1  2  1)\n                : ( 0  0  1) (-1  1  3) ( 0  2  1)\n                : ( 0  0  2) ( 0  1  2)\n                : ( 1 -1  1) ( 0  0  3) ( 1  1  1)\n                : ( 1 -2  1) ( 0 -1  3) ( 1  0  1)\n                :  6 +( 4  0)\n                :  7 +( 4 -2)\n                :  8 +( 2 -4)\n                :  9 +( 0 -4)\n                : 10 +(-2 -4)\n                : 11 +(-4 -2)\n                :  0 +(-4  0)\n                :  1 +(-4  2)\n                :  2 +(-2  4)\n                :  3 +( 0  4)\n                :  4 +( 2  4)\n                :  5 +( 4  2)\n    */\n    INIT\n\n    prismel_t *prismel;\n    err = prismelrenderer_push_prismel(prend, name, &prismel);\n    if(err)return err;\n\n    GET(\"(\")\n    while(1){\n        if(GOT(\")\")){\n            break;\n        }else if(GOT(\"images\")){\n            NEXT\n            GET(\"(\")\n            for(int i = 0; i < prismel->n_images; i++){\n                err = parse_prismel_image(prismel, lexer, i);\n                if(err)return err;\n            }\n            GET(\")\")\n        }else{\n            return UNEXPECTED(\"images\");\n        }\n    }\n    NEXT\n\n    *prismel_ptr = prismel;\n    return 0;\n}\n\nstatic int parse_prismels(prismelrenderer_t *prend, fus_lexer_t *lexer){\n    INIT\n    int n_images = prend->space->rot_max;\n    while(1){\n        char *name;\n        if(GOT(\")\"))break;\n        GET_STR(name)\n        prismel_t *prismel;\n        err = fus_lexer_get_prismel(lexer, prend, name, &prismel);\n        if(err)return err;\n    }\n    NEXT\n    return 0;\n}\n\n\n\n\n/*********\n * SHAPE *\n *********/\n\nstatic int parse_shape_shapes(prismelrenderer_t *prend, fus_lexer_t *lexer,\n    rendergraph_t *rgraph\n){\n    /*\n        Example data:\n\n        :\n            : sixth (0 0 0 0)  0 f\n            : sixth (0 0 0 0)  2 f\n            : sixth (0 0 0 0)  4 f  0 (0 1)\n            : sixth (0 0 0 0)  4 f  0+ (0 1)\n            : sixth (0 0 0 0)  6 f \"red\"  0 (0 1)\n            : sixth (0 0 0 0)  6 f \"red\"  0+ (0 1)\n    */\n    INIT\n    GET(\"(\")\n    while(1){\n        if(GOT(\")\"))break;\n\n        char *name;\n        char *palmapper_name = NULL;\n        palettemapper_t *palmapper = NULL;\n        vec_t v;\n        int rot;\n        bool flip;\n        int frame_start = 0;\n        int frame_len = -1;\n        int frame_i = 0;\n        bool frame_i_additive = true;\n\n        GET(\"(\")\n        {\n            /* name */\n            GET_STR(name)\n\n            /* trf.add */\n            GET_VEC(prend->space, v)\n\n            /* trf.rot */\n            GET_INT(rot)\n\n            /* trf.flip */\n            GET_BOOL(flip)\n\n            /* palmapper */\n            if(GOT_STR){\n                GET_STR(palmapper_name)\n            }\n\n            /* animation */\n            if(GOT_INT){\n                frame_i_additive = false;\n                GET_INT(frame_i)\n                if(GOT(\"+\")){\n                    NEXT\n                    frame_i_additive = true;\n                }\n                if(GOT(\"(\")){\n                    NEXT\n                    GET_INT(frame_start)\n                    GET_INT(frame_len)\n                    GET(\")\")\n                }\n            }\n        }\n        GET(\")\")\n\n        if(palmapper_name != NULL){\n            palmapper = prismelrenderer_get_palmapper(\n                prend, palmapper_name);\n            if(palmapper == NULL){\n                fprintf(stderr, \"Couldn't find palette mapper: %s\\n\",\n                    palmapper_name);\n                free(palmapper_name); return 2;}\n        }\n\n        rendergraph_t *found = prismelrenderer_get_rendergraph(\n            prend, name);\n        if(found == NULL){\n            fprintf(stderr, \"Couldn't find shape: %s\\n\", name);\n            free(name); return 2;}\n        free(name);\n\n        rendergraph_trf_t *rendergraph_trf;\n        err = rendergraph_push_rendergraph_trf(rgraph, &rendergraph_trf);\n        if(err)return err;\n        rendergraph_trf->rendergraph = found;\n        rendergraph_trf->palmapper = palmapper;\n        rendergraph_trf->trf.rot = rot;\n        rendergraph_trf->trf.flip = flip;\n        rendergraph_trf->frame_start = frame_start;\n        rendergraph_trf->frame_len = frame_len;\n        rendergraph_trf->frame_i = frame_i;\n        rendergraph_trf->frame_i_additive = frame_i_additive;\n        vec_cpy(prend->space->dims, rendergraph_trf->trf.add, v);\n    }\n    NEXT\n    return 0;\n}\n\nstatic int parse_shape_prismels(prismelrenderer_t *prend, fus_lexer_t *lexer,\n    rendergraph_t *rgraph\n){\n    /*\n        Example data:\n\n        :\n            : tri (0 0 0 0)  0 f 0\n            : tri (1 0 0 0) 11 f 1\n            : sq  (1 0 0 0)  1 f 2 (3 1)\n    */\n    INIT\n    GET(\"(\")\n    while(1){\n        if(GOT(\")\"))break;\n\n        char *name;\n        int dims = 0;\n        vec_t v;\n        int rot;\n        bool flip;\n        int color;\n        int frame_start = 0;\n        int frame_len = -1;\n\n        GET(\"(\")\n        {\n            GET_STR(name)\n            GET_VEC(prend->space, v)\n            GET_INT(rot)\n            GET_BOOL(flip)\n            GET_INT_FANCY(color)\n            if(GOT(\"(\")){\n                NEXT\n                GET_INT(frame_start)\n                GET_INT(frame_len)\n                GET(\")\")\n            }\n        }\n        GET(\")\")\n\n        prismel_t *found = prismelrenderer_get_prismel(prend, name);\n        if(found == NULL){\n            fprintf(stderr, \"Couldn't find prismel: %s\\n\", name);\n            return 2;\n        }\n        free(name);\n\n        prismel_trf_t *prismel_trf;\n        err = rendergraph_push_prismel_trf(rgraph, &prismel_trf);\n        if(err)return err;\n        prismel_trf->prismel = found;\n        prismel_trf->trf.rot = rot;\n        prismel_trf->trf.flip = flip;\n        prismel_trf->color = color;\n        prismel_trf->frame_start = frame_start;\n        prismel_trf->frame_len = frame_len;\n        vec_cpy(prend->space->dims, prismel_trf->trf.add, v);\n    }\n    NEXT\n    return 0;\n}\n\n\nint fus_lexer_get_rendergraph(fus_lexer_t *lexer,\n    prismelrenderer_t *prend, char *name, rendergraph_t **rgraph_ptr\n){\n    INIT\n    rendergraph_t *rgraph = NULL;\n\n    GET(\"(\")\n\n    if(GOT_STR){\n        char *name;\n        GET_STR(name)\n        rgraph = prismelrenderer_get_rendergraph(prend, name);\n        if(rgraph == NULL){\n            fprintf(stderr, \"Couldn't find shape: %s\\n\", name);\n            free(name); return 2;}\n        free(name);\n        goto ok;\n    }\n\n    if(GOT(\"map\")){\n        NEXT\n\n        prismelmapper_t *mapper;\n        err = fus_lexer_get_mapper(lexer, prend, NULL,\n            &mapper);\n        if(err)return err;\n\n        rendergraph_t *mapped_rgraph;\n        err = fus_lexer_get_rendergraph(lexer, prend, NULL,\n            &mapped_rgraph);\n        if(err)return err;\n\n        err = prismelmapper_apply_to_rendergraph(mapper, prend, mapped_rgraph,\n            name, prend->space, NULL, &rgraph);\n        if(err)return err;\n\n        goto ok;\n    }\n\n    const char *animation_type = rendergraph_animation_type_cycle;\n    int n_frames = 1;\n\n    if(GOT(\"animation\")){\n        NEXT\n        GET(\"(\")\n\n        const char **animation_type_ptr = rendergraph_animation_types;\n        while(*animation_type_ptr != NULL){\n            if(GOT(*animation_type_ptr))break;\n            animation_type_ptr++;\n        }\n        NEXT\n        if(*animation_type_ptr == NULL){\n            return UNEXPECTED(\"<animation_type>\");}\n        animation_type = *animation_type_ptr;\n        GET_INT(n_frames)\n        GET(\")\")\n    }\n\n    rgraph = calloc(1, sizeof(rendergraph_t));\n    if(rgraph == NULL)return 1;\n    if(!name){name = generate_indexed_name(\"shape\",\n        prend->rendergraphs_len);}\n    err = rendergraph_init(rgraph, name, prend, NULL,\n        animation_type, n_frames);\n    if(err)return err;\n\n    ARRAY_PUSH(rendergraph_t*, prend->rendergraphs, rgraph)\n\n    while(1){\n        if(GOT(\")\")){\n            break;\n        }else if(GOT(\"shapes\")){\n            NEXT\n            err = parse_shape_shapes(prend, lexer, rgraph);\n            if(err)return err;\n        }else if(GOT(\"prismels\")){\n            NEXT\n            err = parse_shape_prismels(prend, lexer, rgraph);\n            if(err)return err;\n        }else{\n            err = UNEXPECTED(\"shapes or prismels\");\n            return err;\n        }\n    }\n\nok:\n    GET(\")\")\n\n    *rgraph_ptr = rgraph;\n    return 0;\n}\n\nstatic int parse_shapes(prismelrenderer_t *prend, fus_lexer_t *lexer){\n    INIT\n    while(1){\n        char *name;\n        if(GOT(\")\"))break;\n        GET_STR(name)\n        if(prismelrenderer_get_rendergraph(prend, name) != NULL){\n            fprintf(stderr, \"Shape %s already defined\\n\", name);\n            return 2;\n        }\n\n        rendergraph_t *rgraph;\n        err = fus_lexer_get_rendergraph(lexer, prend, name, &rgraph);\n        if(err)return err;\n    }\n    NEXT\n    return 0;\n}\n\n\n\n/**********\n * MAPPER *\n **********/\n\nint fus_lexer_get_mapper(fus_lexer_t *lexer,\n    prismelrenderer_t *prend, char *name, prismelmapper_t **mapper_ptr\n){\n    INIT\n    prismelmapper_t *mapper = NULL;\n\n    GET(\"(\")\n\n    if(GOT_STR){\n        char *name;\n        GET_STR(name)\n        mapper = prismelrenderer_get_mapper(prend, name);\n        if(mapper == NULL){\n            fprintf(stderr, \"Couldn't find mapper: %s\\n\", name);\n            free(name); return 2;}\n        free(name);\n        goto ok;\n    }\n\n    bool solid = false;\n    if(GOT(\"solid\")){\n        NEXT\n        solid = true;\n    }\n\n    if(GOT(\"map\")){\n        NEXT\n        prismelmapper_t *mapper1;\n        err = fus_lexer_get_mapper(lexer, prend, NULL, &mapper1);\n        if(err)return err;\n\n        prismelmapper_t *mapper2;\n        err = fus_lexer_get_mapper(lexer, prend, NULL, &mapper2);\n        if(err)return err;\n\n        err = prismelmapper_apply_to_mapper(mapper1, prend, mapper2,\n            name, prend->space, &mapper);\n        if(err)return err;\n\n        /* umm kind of hack. But so is our whole mapper->name thing,\n        really we want an array of mapper_entries on prend, where the\n        entries have names instead of the mappers they point to. */\n        if(solid)mapper->solid = true;\n\n        goto ok;\n    }\n\n    GET(\"unit\")\n\n    mapper = calloc(1, sizeof(*mapper));\n    if(mapper == NULL)return 1;\n    if(!name){name = generate_indexed_name(\"mapper\",\n        prend->mappers_len);}\n    err = prismelmapper_init(mapper, name, prend->space, solid);\n    if(err)return err;\n\n    ARRAY_PUSH(prismelmapper_t*, prend->mappers, mapper)\n    GET_VEC(prend->space, mapper->unit)\n\n    if(GOT(\"entries\")){\n        NEXT\n        GET(\"(\")\n        while(1){\n            if(GOT(\")\"))break;\n            GET(\"(\")\n            char *prismel_name;\n            GET_STR(prismel_name)\n            prismel_t *prismel = prismelrenderer_get_prismel(\n                prend, prismel_name);\n            if(prismel == NULL){\n                fus_lexer_err_info(lexer);\n                fprintf(stderr, \"Couldn't find prismel: %s\\n\", prismel_name);\n                err = 2; return err;}\n\n            GET(\"->\")\n\n            char *rgraph_name;\n            GET_STR(rgraph_name)\n            rendergraph_t *rgraph = prismelrenderer_get_rendergraph(\n                prend, rgraph_name);\n            if(rgraph == NULL){\n                fus_lexer_err_info(lexer);\n                fprintf(stderr, \"Couldn't find shape: %s\\n\", rgraph_name);\n                err = 2; return err;}\n\n            err = prismelmapper_push_entry(mapper, prismel, rgraph);\n            if(err)return err;\n\n            GET(\")\")\n        }\n        NEXT\n    }\n\nok:\n    GET(\")\")\n\n    *mapper_ptr = mapper;\n    return 0;\n}\n\nstatic int parse_mappers(prismelrenderer_t *prend, fus_lexer_t *lexer){\n    INIT\n    while(1){\n        char *name;\n        if(GOT(\")\"))break;\n        GET_STR(name)\n        if(prismelrenderer_get_mapper(prend, name) != NULL){\n            fprintf(stderr, \"Mapper %s already defined\\n\", name);\n            return 2;\n        }\n\n        prismelmapper_t *mapper;\n        err = fus_lexer_get_mapper(lexer, prend, name, &mapper);\n        if(err)return err;\n    }\n    NEXT\n    return 0;\n}\n\n\n\n\n/*******************\n * PRISMELRENDERER *\n *******************/\n\nint prismelrenderer_parse(prismelrenderer_t *prend, fus_lexer_t *lexer){\n    INIT\n    while(1){\n        if(DONE){\n            break;\n        }else if(GOT(\"palmappers\")){\n            NEXT\n            GET(\"(\")\n            err = parse_palmappers(prend, lexer);\n            if(err)return err;\n        }else if(GOT(\"prismels\")){\n            NEXT\n            GET(\"(\")\n            err = parse_prismels(prend, lexer);\n            if(err)return err;\n        }else if(GOT(\"shapes\")){\n            NEXT\n            GET(\"(\")\n            err = parse_shapes(prend, lexer);\n            if(err)return err;\n        }else if(GOT(\"mappers\")){\n            NEXT\n            GET(\"(\")\n            err = parse_mappers(prend, lexer);\n            if(err)return err;\n        }else if(GOT(\"import\")){\n            NEXT\n            char *filename;\n            GET_STR(filename)\n            err = prismelrenderer_load(prend, filename);\n            if(err)return err;\n            free(filename);\n        }else{\n            return UNEXPECTED(\n                \"palmappers or prismels or shapes or mappers or import\");\n        }\n    }\n    return 0;\n}\n\n","\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n#include <SDL2/SDL.h>\n\n#include \"prismelrenderer.h\"\n#include \"rendergraph.h\"\n#include \"lexer.h\"\n#include \"bounds.h\"\n#include \"util.h\"\n#include \"sdl_util.h\"\n#include \"array.h\"\n#include \"write.h\"\n\n\n\n\n\n\n/***************\n * RENDERGRAPH *\n ***************/\n\nconst char rendergraph_animation_type_once[] = \"once\";\nconst char rendergraph_animation_type_cycle[] = \"cycle\";\nconst char rendergraph_animation_type_oscillate[] = \"oscillate\";\nconst char *rendergraph_animation_types[] = {\n    rendergraph_animation_type_once,\n    rendergraph_animation_type_cycle,\n    rendergraph_animation_type_oscillate,\n    NULL\n};\nconst char *rendergraph_animation_type_default =\n    rendergraph_animation_type_cycle;\nconst int rendergraph_n_frames_default = 1;\n\nvoid rendergraph_cleanup(rendergraph_t *rendergraph){\n    free(rendergraph->name);\n\n    if(!rendergraph->copy_of){\n        ARRAY_FREE_PTR(prismel_trf_t*, rendergraph->prismel_trfs,\n            (void))\n        ARRAY_FREE_PTR(rendergraph_trf_t*, rendergraph->rendergraph_trfs,\n            (void))\n    }\n\n    for(int i = 0; i < rendergraph->n_bitmaps; i++){\n        rendergraph_bitmap_t *bitmap = &rendergraph->bitmaps[i];\n        SDL_FreeSurface(bitmap->surface);\n        if(bitmap->texture){\n            SDL_DestroyTexture(bitmap->texture);\n            rendergraph->prend->n_textures--;\n        }\n    }\n    free(rendergraph->bitmaps);\n}\n\nstatic int _rendergraph_init(rendergraph_t *rendergraph, char *name,\n    prismelrenderer_t *prend, palettemapper_t *palmapper,\n    const char *animation_type, int n_frames\n){\n    /* initialize everything except prismel_trfs and rendergraph_trfs */\n\n    int err;\n\n    vecspace_t *space = prend->space;\n\n    rendergraph->name = name;\n    rendergraph->prend = prend;\n    rendergraph->space = space;\n\n    rendergraph->animation_type = animation_type;\n    rendergraph->n_frames = n_frames;\n\n    rendergraph->palmapper = palmapper;\n    rendergraph->copy_of = NULL;\n\n    err = rendergraph_create_bitmaps(rendergraph);\n    if(err)return err;\n    boundbox_init(rendergraph->boundbox, space->dims);\n    return 0;\n}\n\nint rendergraph_init(rendergraph_t *rendergraph, char *name,\n    prismelrenderer_t *prend, palettemapper_t *palmapper,\n    const char *animation_type, int n_frames\n){\n    int err;\n\n    err = _rendergraph_init(rendergraph, name, prend, palmapper,\n        animation_type, n_frames);\n    if(err)return err;\n\n    ARRAY_INIT(rendergraph->prismel_trfs)\n    ARRAY_INIT(rendergraph->rendergraph_trfs)\n    return 0;\n}\n\nint rendergraph_copy(rendergraph_t *rendergraph, char *name,\n    rendergraph_t *copy_of\n){\n    int err;\n\n    err = _rendergraph_init(rendergraph, name,\n        copy_of->prend, copy_of->palmapper,\n        copy_of->animation_type, copy_of->n_frames);\n    if(err)return err;\n\n    rendergraph->palmapper = copy_of->palmapper;\n    rendergraph->copy_of = copy_of;\n\n    rendergraph->prismel_trfs = copy_of->prismel_trfs;\n    rendergraph->prismel_trfs_len = copy_of->prismel_trfs_len;\n    rendergraph->rendergraph_trfs = copy_of->rendergraph_trfs;\n    rendergraph->rendergraph_trfs_len = copy_of->rendergraph_trfs_len;\n\n    return 0;\n}\n\nvoid rendergraph_bitmap_dump(rendergraph_bitmap_t *bitmap, FILE *f,\n    int i, int n_spaces, bool dump_surface\n){\n    char spaces[MAX_SPACES];\n    get_spaces(spaces, MAX_SPACES, n_spaces);\n\n    SDL_Surface *surface = bitmap->surface;\n    fprintf(f, \"%sbitmap %i: x=%i y=%i w=%i h=%i surface=%p texture=%p\\n\",\n        spaces, i,\n        bitmap->pbox.x, bitmap->pbox.y, bitmap->pbox.w, bitmap->pbox.h,\n        surface, bitmap->texture);\n    if(dump_surface && surface != NULL){\n        SDL_LockSurface(surface);\n        for(int y = 0; y < surface->h; y++){\n            fprintf(f, \"%s  \", spaces);\n            for(int x = 0; x < surface->w; x++){\n                Uint8 c = *surface8_get_pixel_ptr(surface, x, y);\n                fprintf(f, \" %02x\", c);\n            }\n            fprintf(f, \"\\n\");\n        }\n        SDL_UnlockSurface(surface);\n    }\n}\n\nvoid rendergraph_dump(rendergraph_t *rendergraph, FILE *f, int n_spaces,\n    int dump_bitmaps\n){\n    char spaces[MAX_SPACES];\n    get_spaces(spaces, MAX_SPACES, n_spaces);\n\n    fprintf(f, \"%srendergraph: %p\\n\", spaces, rendergraph);\n    if(rendergraph == NULL)return;\n    if(rendergraph->name != NULL){\n        fprintf(f, \"%s  name: %s\\n\", spaces, rendergraph->name);\n    }\n    fprintf(f, \"%s  space: %p\\n\", spaces, rendergraph->space);\n\n    fprintf(f, \"%s  prismel_trfs:\\n\", spaces);\n    for(int i = 0; i < rendergraph->prismel_trfs_len; i++){\n        prismel_trf_t *prismel_trf = rendergraph->prismel_trfs[i];\n        prismel_t *prismel = prismel_trf->prismel;\n        fprintf(f, \"%s    prismel_trf: %7s \", spaces,\n            prismel == NULL? \"<NULL>\": prismel->name);\n        trf_fprintf(f, rendergraph->space->dims, &prismel_trf->trf);\n            fprintf(f, \" % 2i [% 3i % 3i]\\n\", prismel_trf->color,\n            prismel_trf->frame_start, prismel_trf->frame_len);\n    }\n\n    fprintf(f, \"%s  rendergraph_trfs:\\n\", spaces);\n    for(int i = 0; i < rendergraph->rendergraph_trfs_len; i++){\n        rendergraph_trf_t *rendergraph_trf =\n            rendergraph->rendergraph_trfs[i];\n        rendergraph_t *rendergraph = rendergraph_trf->rendergraph;\n        fprintf(f, \"%s    rendergraph_trf: %7s \", spaces,\n            rendergraph == NULL? \"<NULL>\": rendergraph->name);\n        trf_fprintf(f, rendergraph->space->dims, &rendergraph_trf->trf);\n        if(rendergraph_trf->palmapper != NULL){\n            fprintf(f, \" %s\", rendergraph_trf->palmapper->name);}\n        fprintf(f, \" % 3i%c [% 3i % 3i]\\n\", rendergraph_trf->frame_i,\n            rendergraph_trf->frame_i_additive? '+': ' ',\n            rendergraph_trf->frame_start, rendergraph_trf->frame_len);\n    }\n\n    fprintf(f, \"%s  animation_type: %s\\n\", spaces,\n        rendergraph->animation_type);\n    fprintf(f, \"%s  n_frames: %i\\n\", spaces, rendergraph->n_frames);\n    fprintf(f, \"%s  n_bitmaps: %i\\n\", spaces, rendergraph->n_bitmaps);\n    if(dump_bitmaps > 0){\n        fprintf(f, \"%s  bitmaps:\\n\", spaces);\n        for(int i = 0; i < rendergraph->n_bitmaps; i++){\n            rendergraph_bitmap_t *bitmap = &rendergraph->bitmaps[i];\n            rendergraph_bitmap_dump(bitmap, f, i, n_spaces+4,\n                dump_bitmaps > 1);}}\n\n    fprintf(f, \"%s  boundbox: \", spaces); boundbox_fprintf(f,\n        rendergraph->space->dims, rendergraph->boundbox); fprintf(f, \"\\n\");\n}\n\nint rendergraph_create_bitmaps(rendergraph_t *rendergraph){\n    int n_bitmaps = get_n_bitmaps(rendergraph->space, rendergraph->n_frames);\n    rendergraph_bitmap_t *bitmaps = calloc(n_bitmaps,\n        sizeof(rendergraph_bitmap_t));\n    if(bitmaps == NULL)return 1;\n    rendergraph->n_bitmaps = n_bitmaps;\n    rendergraph->bitmaps = bitmaps;\n    return 0;\n}\n\nint rendergraph_push_rendergraph_trf(rendergraph_t *rendergraph,\n    rendergraph_trf_t **rendergraph_trf_ptr\n){\n    ARRAY_PUSH_NEW(rendergraph_trf_t*, rendergraph->rendergraph_trfs,\n        rendergraph_trf)\n    rendergraph_trf->frame_start = 0;\n    rendergraph_trf->frame_len = -1;\n    rendergraph_trf->frame_i = 0;\n    rendergraph_trf->frame_i_additive = true;\n    rendergraph_trf->palmapper_n_applications = 1;\n    *rendergraph_trf_ptr = rendergraph_trf;\n    return 0;\n}\n\nint rendergraph_push_prismel_trf(rendergraph_t *rendergraph,\n    prismel_trf_t **prismel_trf_ptr\n){\n    ARRAY_PUSH_NEW(prismel_trf_t*, rendergraph->prismel_trfs,\n        prismel_trf)\n    prismel_trf->frame_start = 0;\n    prismel_trf->frame_len = -1;\n    *prismel_trf_ptr = prismel_trf;\n    return 0;\n}\n\nint rendergraph_get_bitmap_i(rendergraph_t *rendergraph,\n    rot_t rot, flip_t flip, int frame_i\n){\n    return get_bitmap_i(rendergraph->space, rot, flip,\n        rendergraph->n_frames, frame_i);\n}\n\nrendergraph_bitmap_t *rendergraph_get_bitmap(rendergraph_t *rendergraph,\n    rot_t rot, flip_t flip, int frame_i\n){\n    int bitmap_i = rendergraph_get_bitmap_i(rendergraph,\n        rot, flip, frame_i);\n    return &rendergraph->bitmaps[bitmap_i];\n}\n\nbool prismel_trf_get_frame_visible(prismel_trf_t *prismel_trf,\n    int n_frames, int frame_i\n){\n    int frame_start = prismel_trf->frame_start;\n    int frame_len = prismel_trf->frame_len;\n    if(frame_len == -1)return true;\n    return get_animated_frame_visible(\n        n_frames, frame_start, frame_len, frame_i);\n}\n\nbool rendergraph_trf_get_frame_visible(rendergraph_trf_t *rendergraph_trf,\n    int n_frames, int frame_i\n){\n    int frame_start = rendergraph_trf->frame_start;\n    int frame_len = rendergraph_trf->frame_len;\n    if(frame_len == -1)return true;\n    return get_animated_frame_visible(\n        n_frames, frame_start, frame_len, frame_i);\n}\n\nint rendergraph_trf_get_frame_i(rendergraph_trf_t *rendergraph_trf,\n    int parent_frame_i\n){\n    int frame_i = rendergraph_trf->frame_i;\n    rendergraph_t *rgraph = rendergraph_trf->rendergraph;\n    if(rendergraph_trf->frame_i_additive)frame_i += parent_frame_i;\n    return get_animated_frame_i(rgraph->animation_type,\n        rgraph->n_frames, frame_i);\n}\n\ntypedef struct {\n    bool done, skip;\n    prismel_trf_t *prismel_trf;\n    prismel_t *prismel;\n    trf_t trf2;\n    int bitmap_i2;\n    int shift_x, shift_y;\n} rendergraph_prismel_trf_iter_t;\n\nstatic int rendergraph_prismel_trf_iter(\n    rendergraph_prismel_trf_iter_t *iter,\n    rendergraph_t *rendergraph, int i,\n    rot_t rot, flip_t flip, int frame_i\n){\n    int err;\n\n    iter->prismel_trf = rendergraph->prismel_trfs[i];\n    iter->prismel = iter->prismel_trf->prismel;\n    bool visible = prismel_trf_get_frame_visible(\n        iter->prismel_trf, rendergraph->n_frames, frame_i);\n    if(!visible){iter->skip = true; return 0;}\n\n    /* Combine the transformations: trf and prismel_trf->trf */\n    iter->trf2 = iter->prismel_trf->trf;\n    trf_apply(rendergraph->space, &iter->trf2,\n        &(trf_t){flip, rot, {0, 0, 0, 0}});\n    iter->bitmap_i2 = get_bitmap_i(rendergraph->space,\n        iter->trf2.rot, iter->trf2.flip, 1, 0);\n    rendergraph->space->vec_render(iter->trf2.add,\n        &iter->shift_x, &iter->shift_y);\n\n    return 0;\n}\n\ntypedef struct {\n    bool done, skip;\n    rendergraph_trf_t *rendergraph_trf;\n    rendergraph_t *rendergraph2;\n    int frame_i2;\n    trf_t trf2;\n    int bitmap_i2;\n    int shift_x, shift_y;\n} rendergraph_rendergraph_trf_iter_t;\n\nstatic int rendergraph_rendergraph_trf_iter(\n    rendergraph_rendergraph_trf_iter_t *iter,\n    rendergraph_t *rendergraph, int i,\n    rot_t rot, flip_t flip, int frame_i\n){\n    int err;\n\n    iter->rendergraph_trf = rendergraph->rendergraph_trfs[i];\n    iter->rendergraph2 = iter->rendergraph_trf->rendergraph;\n    iter->frame_i2 = rendergraph_trf_get_frame_i(\n        iter->rendergraph_trf, frame_i);\n    bool visible = rendergraph_trf_get_frame_visible(\n        iter->rendergraph_trf, rendergraph->n_frames, frame_i);\n    if(!visible){iter->skip = true; return 0;}\n\n    /* Combine the transformations: trf and prismel_trf->trf */\n    iter->trf2 = iter->rendergraph_trf->trf;\n    trf_apply(rendergraph->space, &iter->trf2,\n        &(trf_t){flip, rot, {0, 0, 0, 0}});\n    iter->bitmap_i2 = rendergraph_get_bitmap_i(iter->rendergraph2,\n        iter->trf2.rot, iter->trf2.flip, iter->frame_i2);\n    rendergraph->space->vec_render(iter->trf2.add,\n        &iter->shift_x, &iter->shift_y);\n\n    return 0;\n}\n\nint rendergraph_calculate_bitmap_bounds(rendergraph_t *rendergraph,\n    rot_t rot, flip_t flip, int frame_i\n){\n    /* Looks up bitmap for given rot, flip, frame_i.\n    Immediately exits if bitmap->pbox_calculated.\n    Otherwise, calculates bitmap->pbox, recursively doing the\n    same for all rendergraph's rendergraph_trfs. */\n\n    int err;\n    rendergraph_bitmap_t *bitmap = rendergraph_get_bitmap(rendergraph,\n        rot, flip, frame_i);\n\n    /* Already calculated bitmap->pbox, early exit */\n    if(bitmap->pbox_calculated)return 0;\n\n    /* bitmap->pbox should be the union of its sub-bitmap's pboxes.\n    (I mean the set-theoretic union, like the \"OR\" of Venn diagrams.\n    And by sub-bitmaps I mean the bitmaps of\n    rendergraph->rendergraph_trfs.)\n    It's easy to do unions with boundary_box_t, so we use one of those\n    as an \"accumulator\" while iterating through sub-bitmaps.\n    We will convert it back to a position_box_t when we store it in\n    bitmap->pbox later. */\n    boundary_box_t bbox;\n\n    /* NOTE: Clearing sets all values to zero, which basically describes\n    a single point at the origin. But it would actually make\n    sense to have a separate \"empty\" state.\n    Because e.g. if a rendergraph consists of a single prismel whose\n    boundary does not contain the origin, we will end up unioning\n    that with a boundary consisting of just the origin.\n    Whereas it would have been \"less wasteful\" to just use the\n    prismel's boundary. */\n    boundary_box_clear(&bbox);\n\n    for(int i = 0; i < rendergraph->prismel_trfs_len; i++){\n        rendergraph_prismel_trf_iter_t iter = {0};\n        err = rendergraph_prismel_trf_iter(&iter,\n            rendergraph, i, rot, flip, frame_i);\n        if(err)return err;\n        if(iter.done)break;\n        if(iter.skip)continue;\n\n        /* Calculate & union prismel's bbox into our \"accumulating\" bbox */\n        boundary_box_t bbox2;\n        prismel_get_boundary_box(iter.prismel, &bbox2, iter.bitmap_i2);\n        boundary_box_shift(&bbox2, iter.shift_x, iter.shift_y);\n        boundary_box_union(&bbox, &bbox2);\n    }\n\n    for(int i = 0; i < rendergraph->rendergraph_trfs_len; i++){\n        rendergraph_rendergraph_trf_iter_t iter = {0};\n        err = rendergraph_rendergraph_trf_iter(&iter,\n            rendergraph, i, rot, flip, frame_i);\n        if(err)return err;\n        if(iter.done)break;\n        if(iter.skip)continue;\n\n        /* Calculate bounds for sub-bitmap for this rendergraph_trf */\n        err = rendergraph_calculate_bitmap_bounds(iter.rendergraph2,\n            iter.trf2.rot, iter.trf2.flip, iter.frame_i2);\n        if(err)return err;\n\n        /* Union sub-bitmap's bbox into our \"accumulating\" bbox */\n        rendergraph_bitmap_t *bitmap2 =\n            &iter.rendergraph2->bitmaps[iter.bitmap_i2];\n        boundary_box_t bbox2;\n        boundary_box_from_position_box(&bbox2, &bitmap2->pbox);\n        boundary_box_shift(&bbox2, iter.shift_x, iter.shift_y);\n        boundary_box_union(&bbox, &bbox2);\n    }\n\n    /* Store \"accumulated\" bbox on bitmap */\n    position_box_from_boundary_box(&bitmap->pbox, &bbox);\n    bitmap->pbox_calculated = true;\n\n    return 0;\n}\n\nint rendergraph_render_bitmap(rendergraph_t *rendergraph,\n    rot_t rot, flip_t flip, int frame_i,\n    SDL_Palette *pal\n){\n    int err;\n    rendergraph_bitmap_t *bitmap = rendergraph_get_bitmap(rendergraph,\n        rot, flip, frame_i);\n\n    /* Calculate our bounds */\n    err = rendergraph_calculate_bitmap_bounds(rendergraph,\n        rot, flip, frame_i);\n    if(err)return err;\n\n#ifdef GEOM_DEBUG_RENDERING_RGRAPH\n    printf(\"Rendering rgraph: \\\"%s\\\" rot=%i flip=%c frame_i=%i\\n\",\n        rendergraph->name, rot, flip? 'y': 'n', frame_i);\n#endif\n\n    /* Get rid of old bitmap, create new one */\n    if(bitmap->surface != NULL){\n        SDL_FreeSurface(bitmap->surface);\n        bitmap->surface = NULL;\n    }\n    if(bitmap->texture != NULL){\n        SDL_DestroyTexture(bitmap->texture);\n        rendergraph->prend->n_textures--;\n        bitmap->texture = NULL;\n    }\n    SDL_Surface *surface = surface8_create(bitmap->pbox.w, bitmap->pbox.h,\n        false, true, pal);\n    if(surface == NULL)return 2;\n\n    /* Fill new bitmap with transparent colour */\n    SDL_LockSurface(surface);\n    SDL_memset(surface->pixels, 0, surface->h * surface->pitch);\n\n    SDL_Rect dst_rect = {0, 0, bitmap->pbox.w, bitmap->pbox.h};\n    err = rendergraph_render_to_surface(rendergraph, surface, &dst_rect,\n        rot, flip, frame_i, pal);\n    if(err)return err;\n\n    bitmap->surface = surface;\n    return 0;\n}\n\n\nint rendergraph_render_to_surface(rendergraph_t *rendergraph,\n    SDL_Surface *surface, SDL_Rect *dst_rect,\n    rot_t rot, flip_t flip, int frame_i,\n    SDL_Palette *pal\n){\n    int err;\n    rendergraph_bitmap_t *bitmap = rendergraph_get_bitmap(rendergraph,\n        rot, flip, frame_i);\n\n    /* NOTE: We seem to assume that bitmap's pbox has already been\n    calculated, probably because this function was originally refactored\n    out of rendergraph_render_bitmap which calls\n    rendergraph_calculate_bitmap_bounds up front.\n    But these days we can call rendergraph_calculate_bitmap_bounds\n    and have it exit early if bounds were already calculated, so\n    shouldn't we just rely on that instead?.. */\n\n    /* Render prismels */\n    for(int i = 0; i < rendergraph->prismel_trfs_len; i++){\n        rendergraph_prismel_trf_iter_t iter = {0};\n        err = rendergraph_prismel_trf_iter(&iter,\n            rendergraph, i, rot, flip, frame_i);\n        if(err)return err;\n        if(iter.done)break;\n        if(iter.skip)continue;\n\n        /* Draw prismel's image onto SDL surface */\n        Uint8 c = iter.prismel_trf->color;\n        if(rendergraph->palmapper){\n            c = palettemapper_apply_to_color(rendergraph->palmapper, c);\n        }\n        prismel_image_t *image = &iter.prismel->images[iter.bitmap_i2];\n        for(int i = 0; i < image->lines_len; i++){\n            prismel_image_line_t *line = image->lines[i];\n            int x = dst_rect->x + line->x + bitmap->pbox.x + iter.shift_x;\n            int y = dst_rect->y + line->y + bitmap->pbox.y + iter.shift_y;\n            Uint8 *p = surface8_get_pixel_ptr(surface, x, y);\n            for(int xx = 0; xx < line->w; xx++){\n                p[xx] = c;\n            }\n        }\n    }\n\n    /* Unlock surface so we can blit to it */\n    SDL_UnlockSurface(surface);\n\n    /* Render sub-rendergraphs */\n    for(int i = 0; i < rendergraph->rendergraph_trfs_len; i++){\n        rendergraph_rendergraph_trf_iter_t iter = {0};\n        err = rendergraph_rendergraph_trf_iter(&iter,\n            rendergraph, i, rot, flip, frame_i);\n        if(err)return err;\n        if(iter.done)break;\n        if(iter.skip)continue;\n\n        rendergraph_bitmap_t *bitmap2 = rendergraph_get_bitmap(\n            iter.rendergraph2,\n            iter.trf2.rot, iter.trf2.flip, iter.frame_i2);\n        SDL_Rect dst_rect2 = {\n            dst_rect->x + bitmap->pbox.x + iter.shift_x - bitmap2->pbox.x,\n            dst_rect->y + bitmap->pbox.y + iter.shift_y - bitmap2->pbox.y,\n            bitmap2->pbox.w,\n            bitmap2->pbox.h\n        };\n\n        if(!rendergraph->prend->cache_bitmaps){\n            /* Recurse and continue */\n            err = rendergraph_render_to_surface(iter.rendergraph2, surface,\n                &dst_rect2,\n                iter.trf2.rot, iter.trf2.flip, iter.frame_i2, pal);\n            if(err)return err;\n            continue;\n        }\n\n        /* Get or render sub-bitmap for this rendergraph_trf */\n        /* NOTE: &bitmap2 should be redundant, it should result the same\n        pointer value we already had */\n        err = rendergraph_get_or_render_bitmap(iter.rendergraph2,\n            &bitmap2, iter.trf2.rot, iter.trf2.flip, iter.frame_i2, pal);\n\n        /* Blit sub-bitmap's surface onto ours */\n        SDL_Surface *surface2 = bitmap2->surface;\n        palettemapper_t *palmapper = iter.rendergraph_trf->palmapper;\n        Uint8 *table = NULL;\n        Uint8 _table[256];\n        if(rendergraph->palmapper){\n            for(int i = 0; i < 256; i++){\n                _table[i] = rendergraph->palmapper->table[i];\n            }\n            table = _table;\n        }\n        if(palmapper){\n            int n_applications =\n                iter.rendergraph_trf->palmapper_n_applications;\n            if(!table){\n                for(int i = 0; i < 256; i++)_table[i] = i;\n                table = _table;\n            }\n            for(int i = 0; i < n_applications; i++){\n                palettemapper_apply_to_table(palmapper, table);\n            }\n        }\n        RET_IF_SDL_NZ(SDL_PaletteMappedBlit(bitmap2->surface, NULL,\n            surface, &dst_rect2, table));\n    }\n\n    /* LET'S GO */\n    return 0;\n}\n\nint rendergraph_get_or_render_bitmap(rendergraph_t *rendergraph,\n    rendergraph_bitmap_t **bitmap_ptr,\n    rot_t rot, flip_t flip, int frame_i,\n    SDL_Palette *pal\n){\n    int err;\n    rendergraph_bitmap_t *bitmap = rendergraph_get_bitmap(rendergraph,\n        rot, flip, frame_i);\n\n    if(bitmap->surface == NULL){\n        err = rendergraph_render_bitmap(rendergraph, rot, flip, frame_i,\n            pal);\n        if(err)return err;\n    }\n\n    if(bitmap_ptr != NULL)*bitmap_ptr = bitmap;\n    return 0;\n}\n\nint rendergraph_bitmap_get_texture(rendergraph_t *rgraph,\n    rendergraph_bitmap_t *bitmap,\n    SDL_Renderer *renderer, bool force_create, SDL_Texture **texture_ptr\n){\n    if(force_create && bitmap->texture){\n        SDL_DestroyTexture(bitmap->texture);\n        rgraph->prend->n_textures--;\n        bitmap->texture = NULL;\n    }\n    if(bitmap->texture == NULL){\n        SDL_Texture *texture = SDL_CreateTextureFromSurface(renderer,\n            bitmap->surface);\n        RET_IF_SDL_NULL(texture);\n        bitmap->texture = texture;\n        rgraph->prend->n_textures++;\n    }\n    *texture_ptr = bitmap->texture;\n    return 0;\n}\n\nint rendergraph_render(rendergraph_t *rgraph,\n    SDL_Renderer *renderer, SDL_Surface *surface,\n    SDL_Palette *pal, prismelrenderer_t *prend,\n    int x0, int y0, int zoom,\n    vec_t pos, rot_t rot, flip_t flip, int frame_i,\n    prismelmapper_t *mapper\n){\n    int err;\n\n    bool cache_bitmaps = surface == NULL? true: prend->cache_bitmaps;\n\n    int animated_frame_i = get_animated_frame_i(\n        rgraph->animation_type, rgraph->n_frames, frame_i);\n\n    static const bool MAPPER_ZOOM = true;\n    if(MAPPER_ZOOM){\n        prismelmapper_t *zoom_mapper =\n            zoom == 2? prismelrenderer_get_mapper(prend, \"double\"):\n            zoom == 3? prismelrenderer_get_mapper(prend, \"triple\"):\n            zoom == 4? prismelrenderer_get_mapper(prend, \"quadruple\"):\n            NULL;\n        if(mapper == NULL)mapper = zoom_mapper;\n        else if(zoom_mapper != NULL){\n            err = prismelmapper_apply_to_mapper(zoom_mapper, prend, mapper,\n                NULL, rgraph->space, &mapper);\n            if(err)return err;\n        }\n    }\n\n    if(mapper != NULL){\n        err = prismelmapper_apply_to_rendergraph(mapper, prend, rgraph,\n            NULL, rgraph->space, NULL, &rgraph);\n        if(err)return err;\n\n        vec_mul(mapper->space, pos, mapper->unit);\n    }\n\n    err = rendergraph_calculate_bitmap_bounds(rgraph,\n        rot, flip, animated_frame_i);\n    if(err)return err;\n\n    rendergraph_bitmap_t *bitmap = rendergraph_get_bitmap(rgraph,\n        rot, flip, animated_frame_i);\n\n    /* Can't create a texture with either dimension 0, so exit early */\n    if(bitmap->pbox.w == 0 || bitmap->pbox.h == 0)return 0;\n\n    int x, y;\n    rgraph->space->vec_render(pos, &x, &y);\n\n    int rect_zoom = MAPPER_ZOOM? 1: zoom;\n    SDL_Rect dst_rect = {\n        x0 + (x - bitmap->pbox.x) * rect_zoom,\n        y0 + (y - bitmap->pbox.y) * rect_zoom,\n        bitmap->pbox.w * rect_zoom,\n        bitmap->pbox.h * rect_zoom\n    };\n\n    if(surface != NULL){\n        /* Exit early if rgraph wouldn't even show up on target surface. */\n        SDL_Rect target_rect = {0, 0, surface->w, surface->h};\n        if(!SDL_HasIntersection(&dst_rect, &target_rect))return 0;\n    }else if(renderer != NULL){\n        /* MAYBE TODO: exit early if rgraph woldn't even show up on target\n        renderer...\n        We can't implement this at the moment, because SDL_Renderer is\n        totally opaque, so we would have to pass its x, y, w, h into this\n        function somehow. */\n    }\n\n    if(cache_bitmaps){\n        /* Render rgraph and cache result on one of rgraph's bitmaps */\n\n        /* NOTE: Passing &bitmap in the following call is unnecessary,\n        it should end up being the same as what we got by calling\n        rendergraph_get_bitmap above */\n        err = rendergraph_get_or_render_bitmap(rgraph, &bitmap,\n            rot, flip, animated_frame_i, pal);\n        if(err)return err;\n    }\n\n    /* Finally render, blit, or copy the rgraph onto target surface\n    or renderer */\n    if(surface != NULL){\n        if(cache_bitmaps){\n            RET_IF_SDL_NZ(SDL_BlitScaled(bitmap->surface, NULL,\n                surface, &dst_rect));\n        }else{\n            err = rendergraph_render_to_surface(rgraph, surface, &dst_rect,\n                rot, flip, animated_frame_i, pal);\n            if(err)return err;\n        }\n    }else if(renderer != NULL){\n        SDL_Texture *bitmap_texture;\n        err = rendergraph_bitmap_get_texture(rgraph, bitmap, renderer,\n            false, &bitmap_texture);\n        if(err)return err;\n        RET_IF_SDL_NZ(SDL_RenderCopy(renderer, bitmap_texture,\n            NULL, &dst_rect));\n    }\n\n    return 0;\n}\n\nint rendergraph_render_all_bitmaps(rendergraph_t *rgraph, SDL_Palette *pal){\n    int err;\n    for(int frame_i = 0; frame_i < rgraph->n_frames; frame_i++){\n        for(int rot = 0; rot < rgraph->space->rot_max; rot++){\n            err = rendergraph_get_or_render_bitmap(\n                rgraph, NULL, rot, false, frame_i, pal);\n            if(err)return err;\n        }\n    }\n    return 0;\n}\n\n\n","\n/*\n    This file contains code from SDL2 (copyright below) which was\n    either not exported by the copiled library, or didn't quite do\n    what I needed, etc.\n     - BAG June 2018\n*/\n\n/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2018 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n\n#include <SDL2/SDL.h>\n#include \"sdl_util.h\"\n\n\nstatic void PaletteMappedBlit1to1Key(SDL_BlitInfo *info){\n    /* Copy-paste-modified from Blit1to1Key\n    (src/video/SDL_blit_1.c) - BAG */\n\n    int c;\n    int width = info->dst_w;\n    int height = info->dst_h;\n    Uint8 *src = info->src;\n    int srcskip = info->src_skip;\n    Uint8 *dst = info->dst;\n    int dstskip = info->dst_skip;\n    Uint8 *palmap = info->table;\n    Uint32 ckey = info->colorkey;\n\n    if (palmap) {\n        while (height--) {\n            for (c = width; c; --c) {\n                if ( *src != ckey ) {\n                  *dst = palmap[*src];\n                }\n                dst++;\n                src++;\n            }\n            src += srcskip;\n            dst += dstskip;\n        }\n    } else {\n        while (height--) {\n            for (c = width; c; --c) {\n                if ( *src != ckey ) {\n                  *dst = *src;\n                }\n                dst++;\n                src++;\n            }\n            src += srcskip;\n            dst += dstskip;\n        }\n    }\n}\n\nstatic void SDL_PaletteMappedSoftBlit_GetInfo(\n    SDL_Surface * src, SDL_Rect * srcrect,\n    SDL_Surface * dst, SDL_Rect * dstrect,\n    Uint8 *table, SDL_BlitInfo *info\n){\n    /* Factored out of SDL_SoftBlit\n    (src/video/SDL_blit.c) - BAG */\n\n    /* Set up the blit information */\n    info->src_fmt = src->format;\n    info->src = (Uint8 *) src->pixels +\n        (Uint16) srcrect->y * src->pitch +\n        (Uint16) srcrect->x * info->src_fmt->BytesPerPixel;\n    info->src_w = srcrect->w;\n    info->src_h = srcrect->h;\n    info->src_pitch = src->pitch;\n    info->src_skip =\n        info->src_pitch - info->src_w * info->src_fmt->BytesPerPixel;\n    info->dst_fmt = dst->format;\n    info->dst =\n        (Uint8 *) dst->pixels + (Uint16) dstrect->y * dst->pitch +\n        (Uint16) dstrect->x * info->dst_fmt->BytesPerPixel;\n    info->dst_w = dstrect->w;\n    info->dst_h = dstrect->h;\n    info->dst_pitch = dst->pitch;\n    info->dst_skip =\n        info->dst_pitch - info->dst_w * info->dst_fmt->BytesPerPixel;\n\n    info->colorkey = 0;\n    info->table = table;\n}\n\nstatic int SDL_PaletteMappedSoftBlit(\n    SDL_Surface * src, SDL_Rect * srcrect,\n    SDL_Surface * dst, SDL_Rect * dstrect,\n    Uint8 *table\n){\n    /* Copy-paste-modified from SDL_SoftBlit\n    (src/video/SDL_blit.c) - BAG */\n\n    int okay;\n    int src_locked;\n    int dst_locked;\n\n    /* Everything is okay at the beginning...  */\n    okay = 1;\n\n    /* Lock the destination if it's in hardware */\n    dst_locked = 0;\n    if (SDL_MUSTLOCK(dst)) {\n        if (SDL_LockSurface(dst) < 0) {\n            okay = 0;\n        } else {\n            dst_locked = 1;\n        }\n    }\n    /* Lock the source if it's in hardware */\n    src_locked = 0;\n    if (SDL_MUSTLOCK(src)) {\n        if (SDL_LockSurface(src) < 0) {\n            okay = 0;\n        } else {\n            src_locked = 1;\n        }\n    }\n\n    /* Set up source and destination buffer pointers, and BLIT! */\n    if (okay && !SDL_RectEmpty(srcrect)) {\n        SDL_BlitInfo info;\n        SDL_PaletteMappedSoftBlit_GetInfo(src, srcrect, dst,\n            dstrect, table, &info);\n        PaletteMappedBlit1to1Key(&info);\n    }\n\n    /* We need to unlock the surfaces if they're locked */\n    if (dst_locked) {\n        SDL_UnlockSurface(dst);\n    }\n    if (src_locked) {\n        SDL_UnlockSurface(src);\n    }\n    /* Blit is done! */\n    return (okay ? 0 : -1);\n}\n\nint SDL_PaletteMappedUpperBlit(\n    SDL_Surface * src, const SDL_Rect * srcrect,\n    SDL_Surface * dst, SDL_Rect * dstrect,\n    Uint8 *table\n){\n    /* Copy-paste-modified from SDL_UpperBlit\n    (src/video/SDL_surface.c) - BAG */\n\n    SDL_Rect fulldst;\n    int srcx, srcy, w, h;\n\n    /* Make sure the surfaces aren't locked */\n    if (!src || !dst) {\n        return SDL_SetError(\"SDL_UpperBlit: passed a NULL surface\");\n    }\n    if (src->locked || dst->locked) {\n        return SDL_SetError(\"Surfaces must not be locked during blit\");\n    }\n\n    /* If the destination rectangle is NULL, use the entire dest surface */\n    if (dstrect == NULL) {\n        fulldst.x = fulldst.y = 0;\n        fulldst.w = dst->w;\n        fulldst.h = dst->h;\n        dstrect = &fulldst;\n    }\n\n    /* clip the source rectangle to the source surface */\n    if (srcrect) {\n        int maxw, maxh;\n\n        srcx = srcrect->x;\n        w = srcrect->w;\n        if (srcx < 0) {\n            w += srcx;\n            dstrect->x -= srcx;\n            srcx = 0;\n        }\n        maxw = src->w - srcx;\n        if (maxw < w)\n            w = maxw;\n\n        srcy = srcrect->y;\n        h = srcrect->h;\n        if (srcy < 0) {\n            h += srcy;\n            dstrect->y -= srcy;\n            srcy = 0;\n        }\n        maxh = src->h - srcy;\n        if (maxh < h)\n            h = maxh;\n\n    } else {\n        srcx = srcy = 0;\n        w = src->w;\n        h = src->h;\n    }\n\n    /* clip the destination rectangle against the clip rectangle */\n    {\n        SDL_Rect *clip = &dst->clip_rect;\n        int dx, dy;\n\n        dx = clip->x - dstrect->x;\n        if (dx > 0) {\n            w -= dx;\n            dstrect->x += dx;\n            srcx += dx;\n        }\n        dx = dstrect->x + w - clip->x - clip->w;\n        if (dx > 0)\n            w -= dx;\n\n        dy = clip->y - dstrect->y;\n        if (dy > 0) {\n            h -= dy;\n            dstrect->y += dy;\n            srcy += dy;\n        }\n        dy = dstrect->y + h - clip->y - clip->h;\n        if (dy > 0)\n            h -= dy;\n    }\n\n    if (w > 0 && h > 0) {\n        SDL_Rect sr;\n        sr.x = srcx;\n        sr.y = srcy;\n        sr.w = dstrect->w = w;\n        sr.h = dstrect->h = h;\n        return SDL_PaletteMappedSoftBlit(src, &sr, dst, dstrect, table);\n    }\n    dstrect->w = dstrect->h = 0;\n    return 0;\n}\n\n\n","/*\n  Simple DirectMedia Layer\n  Copyright (C) 1997-2016 Sam Lantinga <slouken@libsdl.org>\n\n  This software is provided 'as-is', without any express or implied\n  warranty.  In no event will the authors be held liable for any damages\n  arising from the use of this software.\n\n  Permission is granted to anyone to use this software for any purpose,\n  including commercial applications, and to alter it and redistribute it\n  freely, subject to the following restrictions:\n\n  1. The origin of this software must not be misrepresented; you must not\n     claim that you wrote the original software. If you use this software\n     in a product, an acknowledgment in the product documentation would be\n     appreciated but is not required.\n  2. Altered source versions must be plainly marked as such, and must not be\n     misrepresented as being the original software.\n  3. This notice may not be removed or altered from any source distribution.\n*/\n\n/**\n *  \\file SDL_rect.h\n *\n *  Header file for SDL_rect definition and management functions.\n */\n\n#ifndef _SDL_rect_h\n#define _SDL_rect_h\n\n#include \"SDL_stdinc.h\"\n#include \"SDL_error.h\"\n#include \"SDL_pixels.h\"\n#include \"SDL_rwops.h\"\n\n#include \"begin_code.h\"\n/* Set up for C function definitions, even when using C++ */\n#ifdef __cplusplus\nextern \"C\" {\n#endif\n\n/**\n *  \\brief  The structure that defines a point\n *\n *  \\sa SDL_EnclosePoints\n *  \\sa SDL_PointInRect\n */\ntypedef struct SDL_Point\n{\n    int x;\n    int y;\n} SDL_Point;\n\n/**\n *  \\brief A rectangle, with the origin at the upper left.\n *\n *  \\sa SDL_RectEmpty\n *  \\sa SDL_RectEquals\n *  \\sa SDL_HasIntersection\n *  \\sa SDL_IntersectRect\n *  \\sa SDL_UnionRect\n *  \\sa SDL_EnclosePoints\n */\ntypedef struct SDL_Rect\n{\n    int x, y;\n    int w, h;\n} SDL_Rect;\n\n/**\n *  \\brief Returns true if point resides inside a rectangle.\n */\nSDL_FORCE_INLINE SDL_bool SDL_PointInRect(const SDL_Point *p, const SDL_Rect *r)\n{\n    return ( (p->x >= r->x) && (p->x < (r->x + r->w)) &&\n             (p->y >= r->y) && (p->y < (r->y + r->h)) ) ? SDL_TRUE : SDL_FALSE;\n}\n\n/**\n *  \\brief Returns true if the rectangle has no area.\n */\nSDL_FORCE_INLINE SDL_bool SDL_RectEmpty(const SDL_Rect *r)\n{\n    return ((!r) || (r->w <= 0) || (r->h <= 0)) ? SDL_TRUE : SDL_FALSE;\n}\n\n/**\n *  \\brief Returns true if the two rectangles are equal.\n */\nSDL_FORCE_INLINE SDL_bool SDL_RectEquals(const SDL_Rect *a, const SDL_Rect *b)\n{\n    return (a && b && (a->x == b->x) && (a->y == b->y) &&\n            (a->w == b->w) && (a->h == b->h)) ? SDL_TRUE : SDL_FALSE;\n}\n\n/**\n *  \\brief Determine whether two rectangles intersect.\n *\n *  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n */\nextern DECLSPEC SDL_bool SDLCALL SDL_HasIntersection(const SDL_Rect * A,\n                                                     const SDL_Rect * B);\n\n/**\n *  \\brief Calculate the intersection of two rectangles.\n *\n *  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n */\nextern DECLSPEC SDL_bool SDLCALL SDL_IntersectRect(const SDL_Rect * A,\n                                                   const SDL_Rect * B,\n                                                   SDL_Rect * result);\n\n/**\n *  \\brief Calculate the union of two rectangles.\n */\nextern DECLSPEC void SDLCALL SDL_UnionRect(const SDL_Rect * A,\n                                           const SDL_Rect * B,\n                                           SDL_Rect * result);\n\n/**\n *  \\brief Calculate a minimal rectangle enclosing a set of points\n *\n *  \\return SDL_TRUE if any points were within the clipping rect\n */\nextern DECLSPEC SDL_bool SDLCALL SDL_EnclosePoints(const SDL_Point * points,\n                                                   int count,\n                                                   const SDL_Rect * clip,\n                                                   SDL_Rect * result);\n\n/**\n *  \\brief Calculate the intersection of a rectangle and line segment.\n *\n *  \\return SDL_TRUE if there is an intersection, SDL_FALSE otherwise.\n */\nextern DECLSPEC SDL_bool SDLCALL SDL_IntersectRectAndLine(const SDL_Rect *\n                                                          rect, int *X1,\n                                                          int *Y1, int *X2,\n                                                          int *Y2);\n\n/* Ends C function definitions when using C++ */\n#ifdef __cplusplus\n}\n#endif\n#include \"close_code.h\"\n\n#endif /* _SDL_rect_h */\n\n/* vi: set ts=4 sw=4 expandtab: */\n","\n#include <stdio.h>\n#include <stdbool.h>\n#include <SDL2/SDL.h>\n\n#include \"test_app.h\"\n\n\n#define SCW 1024\n#define SCH 768\n\n/* How many milliseconds we want each frame to last */\n#define DELAY_GOAL 30\n\n\n#ifdef __EMSCRIPTEN__\n#include \"emscripten.h\"\nstatic void test_app_mainloop_emcc(void *arg){\n    test_app_t *app = arg;\n    int e = test_app_mainloop_step(app);\n    if(e){\n        fprintf(stderr, \"%s: Exiting with error: %i\\n\", __func__, e);\n        exit(e);\n    }\n}\n#endif\n\n\nint main(int n_args, char *args[]){\n    int e = 0;\n    Uint32 window_flags = SDL_WINDOW_SHOWN;\n    const char *prend_filename = \"data/test.fus\";\n    const char *stateset_filename = \"anim/player.fus\";\n    const char *hexmap_filename = \"data/maps/demo/worldmap.fus\";\n    bool use_textures = false;\n    bool cache_bitmaps = true;\n    int n_players = 1;\n\n    for(int arg_i = 1; arg_i < n_args; arg_i++){\n        char *arg = args[arg_i];\n        if(!strcmp(arg, \"-F\")){\n            window_flags |= SDL_WINDOW_FULLSCREEN;\n        }else if(!strcmp(arg, \"-FD\")){\n            window_flags |= SDL_WINDOW_FULLSCREEN_DESKTOP;\n        }else if(!strcmp(arg, \"-f\")){\n            arg_i++;\n            if(arg_i >= n_args){\n                fprintf(stderr, \"Missing filename after %s\\n\", arg);\n                return 2;}\n            arg = args[arg_i];\n            prend_filename = arg;\n        }else if(!strcmp(arg, \"--anim\")){\n            arg_i++;\n            if(arg_i >= n_args){\n                fprintf(stderr, \"Missing filename after %s\\n\", arg);\n                return 2;}\n            arg = args[arg_i];\n            stateset_filename = arg;\n        }else if(!strcmp(arg, \"--map\")){\n            arg_i++;\n            if(arg_i >= n_args){\n                fprintf(stderr, \"Missing filename after %s\\n\", arg);\n                return 2;}\n            arg = args[arg_i];\n            hexmap_filename = arg;\n        }else if(!strcmp(arg, \"--use_textures\")){\n            use_textures = true;\n        }else if(!strcmp(arg, \"--dont_cache_bitmaps\")){\n            cache_bitmaps = false;\n        }else if(!strcmp(arg, \"--players\")){\n            arg_i++;\n            if(arg_i >= n_args){\n                fprintf(stderr, \"Missing int after %s\\n\", arg);\n                return 2;}\n            arg = args[arg_i];\n            n_players = atoi(arg);\n            fprintf(stderr, \"Number of players set to %i\\n\", n_players);\n        }else{\n            fprintf(stderr, \"Unrecognized option: %s\\n\", arg);\n            return 2;\n        }\n    }\n\n    if(SDL_Init(SDL_INIT_VIDEO)){\n        e = 1;\n        fprintf(stderr, \"SDL_Init error: %s\\n\", SDL_GetError());\n    }else{\n        SDL_Window *window = SDL_CreateWindow(\"Depths of Uo\",\n            SDL_WINDOWPOS_CENTERED, SDL_WINDOWPOS_CENTERED,\n            SCW, SCH, window_flags);\n\n        if(!window){\n            e = 1;\n            fprintf(stderr, \"SDL_CreateWindow error: %s\\n\",\n                SDL_GetError());\n        }else{\n            SDL_Renderer *renderer = SDL_CreateRenderer(window, -1,\n                SDL_RENDERER_ACCELERATED | SDL_RENDERER_PRESENTVSYNC);\n\n            if(!renderer){\n                e = 1;\n                fprintf(stderr, \"SDL_CreateRenderer error: %s\\n\",\n                    SDL_GetError());\n            }else{\n                test_app_t app;\n                if(test_app_init(&app, SCW, SCH, DELAY_GOAL,\n                    window, renderer, prend_filename, stateset_filename,\n                    hexmap_filename, use_textures, cache_bitmaps, n_players)\n                ){\n                    e = 1;\n                    fprintf(stderr, \"Couldn't init test app\\n\");\n                }else{\n#ifdef __EMSCRIPTEN__\n                    SDL_StartTextInput();\n                    emscripten_set_main_loop_arg(&test_app_mainloop_emcc,\n                        &app, 0, true);\n#else\n                    e = test_app_mainloop(&app);\n#endif\n                    fprintf(stderr, \"Cleaning up...\\n\");\n                    test_app_cleanup(&app);\n                }\n                SDL_DestroyRenderer(renderer);\n            }\n            SDL_DestroyWindow(window);\n        }\n        SDL_Quit();\n    }\n    fprintf(stderr, \"Exiting with code: %i\\n\", e);\n    return e;\n}\n"]}