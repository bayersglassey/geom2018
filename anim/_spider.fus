
# Expected vars:
# NS (str), e.g. "spider_"
# SPIDER_AIMER (bool)
# SPIDER_BIRD (bool)
# SPIDER_FLIER (bool)
# SPIDER_SPIKEY (bool)
# SPIDER_ROLLER (bool)
# SPIDER_EYE (bool)

# NOTE: make sure "stand" is the first anim, so any imports
# should go below it


# So we know we're not just a "spiderlike" thing, e.g. coin_beast
$SET_BOOL SPIDER


$SET_BOOL DISABLE_RUNNING # !!! DISABLED FOR NOW


$SET_INT ROLLER_STAND_DELAY 0

$SET_STR STATE_STAND stand
$SET_STR STATE_STEP step
$SET_STR STATE_STEP_UP step
$SET_STR STATE_STEP_DOWN step_down
$SET_STR STATE_START_JUMP start_jump
$SET_STR STATE_RUN_STEP run_step
$SET_STR STATE_RUN_STEP_UP run_step
$SET_STR STATE_RUN_STEP_DOWN run_step_down
$SET_STR STATE_RUN_START_JUMP run_start_jump
$SET_STR STATE_JUMP jump


vars:
    "is_rollerspider": F
    $IF SPIDER_ROLLER: "is_rollerspider": T
    "is_aimerspider": F
    $IF SPIDER_AIMER: "is_aimerspider": T
    "is_spikeyspider": F
    $IF SPIDER_SPIKEY: "is_spikeyspider": T
    "is_flierspider": F
    $IF SPIDER_FLIER: "is_flierspider": T
    "is_birdspider": F
    $IF SPIDER_BIRD: "is_birdspider": T

    nosave "carrying": null
    nosave "carrying_respawn_mapvar": null
    nosave "carrying_rgraph": null


collmsgs:
    $IF !SPIDER_EYE: "touch"
    $IF !SPIDER_EYE: "enter_door"
on "crush": goto: dead


$IF !SPIDER_EYE: on "carryable":
    # "me" is a spider, "you" is a carryable thing (e.g. coin, food)

    if: not: exists myvar("carrying")
    then:
        # Transfer some vars from carryable thing to the spider who
        # will now be "carrying it"
        set myvar("carrying"): yourvar("carryable")
        set myvar("carrying_respawn_mapvar"): yourvar("respawn_mapvar")
        set myvar("carrying_rgraph"): yourvar("carryable_rgraph")
        set_label "carrying": myvar("carrying_rgraph")

        # Increment a mapvar tracking how many of this thing are
        # being carried
        if: exists myvar("carrying_respawn_mapvar")
        then: inc mapvar(myvar("carrying_respawn_mapvar"))

        # When a thing is carried, it is "collected"
        as you:
            goto immediate: _collected


proc _spawn_spit:
    # "me" is spider, "you" is spider's newly-spawned spit

    if: exists myvar("carrying")
    then:
        # Transfer the thing we're carrying over to our spit

        # Set spit's "carrying" to spider's "carrying"
        as you:
            set myvar("carrying"): yourvar("carrying")
            set myvar("carrying_respawn_mapvar"): yourvar("carrying_respawn_mapvar")
            set myvar("carrying_rgraph"): yourvar("carrying_rgraph")
            set_label "carrying": myvar("carrying_rgraph")

        # Unset spider's "carrying"
        set myvar("carrying"): null
        set_label "carrying": null

proc set_spit_anim:
    # We don't have functions, just procedures.
    # This procedure acts like a function in that it "returns" a value
    # in myvar("spit_anim").
    if: expr: myvar("is_spikeyspider")
    then: set myvar("spit_anim"): "anim/spikeyspit.fus"
    else: set myvar("spit_anim"): "anim/spit.fus"

proc spit:
    call: set_spit_anim
    spawn: myvar("spit_anim") "fly" (0 0) 0 f do:
        call: _spawn_spit
    goto delay: spit

proc looking_up_spit:
    call: set_spit_anim
    spawn: myvar("spit_anim") "fly" (1 0) 1 f do:
        call: _spawn_spit
    goto delay: looking_up_spit

proc crawl_spit:
    call: set_spit_anim
    spawn: myvar("spit_anim") "crouch_fly" (0 0) 0 f do:
        call: _spawn_spit
    goto delay: crawl_spit

proc crawl_looking_up_spit:
    call: set_spit_anim
    spawn: myvar("spit_anim") "crouch_fly" (1 0) 1 f do:
        call: _spawn_spit
    goto delay: crawl_looking_up_spit

proc swim_spit:
    call: set_spit_anim
    spawn: myvar("spit_anim") "fly" (0 0) 0 f do:
        call: _spawn_spit
    goto delay: swim_spit


collmap "stand":
    ;;   .   .
    ;;   *\*/*
    ;; . - + - .
    ;;   */*\*
    ;;  (.)  .
collmap "crawl":
    ;;     .
    ;;     *
    ;;  (.)  .


$UNSET_BOOL RUNNING
import "anim/_spider_stand.fus"


state "look_up":
    rgraph: $PREFIX NS "look_up"
    hitbox: collmap("stand")
    if() then: goto: looking_up

state "looking_up":
    rgraph: $PREFIX NS "looking_up"
    hitbox: collmap("stand")

    if:
        key: wentdown y
    then:
        call: looking_up_spit

    if:
        key: wasdown u
        coll: all no
            ;;    *\*/*
            ;;    - + -
            ;;       \*
            ;;
            ;;
            ;; ( )
    then:
        move: 1 0
        rot: 1
        goto immediate: start_jump

    if: key: wasdown f
    then: goto immediate: stand

    if: key: wasdown b
    then: goto immediate: stand

    if:
        key: wasdown d
    then:
        goto delay: crawling_looking_up

    if: key: not isdown x
    then: goto: stand

state "spit":
    rgraph: $PREFIX NS "spit"
    hitbox: collmap("stand")
    if() then: goto: stand

state "looking_up_spit":
    rgraph: $PREFIX NS "looking_up_spit"
    hitbox: collmap("stand")
    if() then: goto: looking_up

state "turn":
    rgraph: $PREFIX NS "turn"
    hitbox: collmap("stand")

    # Jump
    if:
        key: wasdown u
        coll: all no
            ;;       \*/*
            ;;        + -
            ;;       /*\*
            ;; ( )
    then:
        move: 1 0
        if:
            $IF DISABLE_RUNNING: false
            key: wasdown f
        then: goto immediate: $GET_SYM STATE_RUN_START_JUMP
        else: goto immediate: $GET_SYM STATE_START_JUMP

    if() then: goto immediate: step

state "stop_running":
    # (Expected to be "goto immediate"'d to)
    #
    # We were running, but now we should stop somehow.
    # Try to take a (regular, non-running) step forwards, to give a sense
    # of inertia.

    # Step up
    if:
        coll: all yes
            ;;        +
            ;;       /
            ;; ( )  +
    then:
        move: 1 0
        rot: 1
        goto delay: step

    # Step
    if:
        coll: all yes
            ;; ( )  + - +
        coll: all no
            ;;       \*/*
            ;;        + -
            ;;       /*\*
            ;; ( )
    then:
        move: 1 0
        goto delay: step

    # Step down
    if:
        coll: all yes
            ;; ( )  +
            ;;       \
            ;;        +
        coll: all no
            ;;       \*/*
            ;;        + -
            ;;       /*\*/*
            ;; ( )    - + -
            ;;        */*\*
    then:
        move: 1 0
        rot: -1
        goto delay: step_down

    # If we can't take a step forward, then just go to the non-running
    # "stand" state.
    if() then: goto: stand

state "sleep":
    rgraph: $PREFIX NS "sleep"
    hitbox: collmap("crawl")
    if: any:
        key: wasdown u
        key: wasdown d
        key: wasdown l
        key: wasdown r
    then: goto: crawl

$IF SPIDER_EYE:
    state "eye_closing":
        rgraph: $PREFIX NS "eye_closing"
        hitbox: collmap("stand")
        if() then: goto: eye_closed
    state "eye_unclosing":
        rgraph: $PREFIX NS "eye_unclosing"
        hitbox: collmap("stand")
        if() then: goto: stand
    state "eye_closed":
        rgraph: $PREFIX NS "eye_closed"
        hitbox: collmap("stand")
        if:
            key: not isdown x
        then: goto delay: eye_unclosing

state "mostly_dead":
    rgraph: "dead_cycle"
    unsafe
    if() then: die mostly

state "dead":
    rgraph: "dead_cycle"
    unsafe
    if() then: die

import "anim/_spider_crawl.fus"
import "anim/_spider_swim.fus"
import "anim/_spider_run.fus"
